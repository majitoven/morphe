/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/layout"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fmventura%2FDocuments%2FGitHub%2Fmorphe%2Fapp%2Flayout.jsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!":
/*!*************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fmventura%2FDocuments%2FGitHub%2Fmorphe%2Fapp%2Flayout.jsx%22%2C%22ids%22%3A%5B%5D%7D&server=false! ***!
  \*************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/layout.jsx */ \"(app-pages-browser)/./app/layout.jsx\"));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz0lN0IlMjJyZXF1ZXN0JTIyJTNBJTIyJTJGVXNlcnMlMkZtdmVudHVyYSUyRkRvY3VtZW50cyUyRkdpdEh1YiUyRm1vcnBoZSUyRmFwcCUyRmxheW91dC5qc3glMjIlMkMlMjJpZHMlMjIlM0ElNUIlNUQlN0Qmc2VydmVyPWZhbHNlISIsIm1hcHBpbmdzIjoiQUFBQSwwSkFBMkYiLCJzb3VyY2VzIjpbIiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQoLyogd2VicGFja01vZGU6IFwiZWFnZXJcIiAqLyBcIi9Vc2Vycy9tdmVudHVyYS9Eb2N1bWVudHMvR2l0SHViL21vcnBoZS9hcHAvbGF5b3V0LmpzeFwiKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fmventura%2FDocuments%2FGitHub%2Fmorphe%2Fapp%2Flayout.jsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/bezier-easing/src/index.js":
/*!*************************************************!*\
  !*** ./node_modules/bezier-easing/src/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("/**\n * https://github.com/gre/bezier-easing\n * BezierEasing - use bezier curve for transition easing function\n * by Gaëtan Renaudeau 2014 - 2015 – MIT License\n */\n\n// These values are established by empiricism with tests (tradeoff: performance VS precision)\nvar NEWTON_ITERATIONS = 4;\nvar NEWTON_MIN_SLOPE = 0.001;\nvar SUBDIVISION_PRECISION = 0.0000001;\nvar SUBDIVISION_MAX_ITERATIONS = 10;\n\nvar kSplineTableSize = 11;\nvar kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n\nvar float32ArraySupported = typeof Float32Array === 'function';\n\nfunction A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }\nfunction B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }\nfunction C (aA1)      { return 3.0 * aA1; }\n\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nfunction calcBezier (aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT; }\n\n// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\nfunction getSlope (aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1); }\n\nfunction binarySubdivide (aX, aA, aB, mX1, mX2) {\n  var currentX, currentT, i = 0;\n  do {\n    currentT = aA + (aB - aA) / 2.0;\n    currentX = calcBezier(currentT, mX1, mX2) - aX;\n    if (currentX > 0.0) {\n      aB = currentT;\n    } else {\n      aA = currentT;\n    }\n  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n  return currentT;\n}\n\nfunction newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {\n for (var i = 0; i < NEWTON_ITERATIONS; ++i) {\n   var currentSlope = getSlope(aGuessT, mX1, mX2);\n   if (currentSlope === 0.0) {\n     return aGuessT;\n   }\n   var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n   aGuessT -= currentX / currentSlope;\n }\n return aGuessT;\n}\n\nfunction LinearEasing (x) {\n  return x;\n}\n\nmodule.exports = function bezier (mX1, mY1, mX2, mY2) {\n  if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) {\n    throw new Error('bezier x values must be in [0, 1] range');\n  }\n\n  if (mX1 === mY1 && mX2 === mY2) {\n    return LinearEasing;\n  }\n\n  // Precompute samples table\n  var sampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n  for (var i = 0; i < kSplineTableSize; ++i) {\n    sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n  }\n\n  function getTForX (aX) {\n    var intervalStart = 0.0;\n    var currentSample = 1;\n    var lastSample = kSplineTableSize - 1;\n\n    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {\n      intervalStart += kSampleStepSize;\n    }\n    --currentSample;\n\n    // Interpolate to provide an initial guess for t\n    var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);\n    var guessForT = intervalStart + dist * kSampleStepSize;\n\n    var initialSlope = getSlope(guessForT, mX1, mX2);\n    if (initialSlope >= NEWTON_MIN_SLOPE) {\n      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n    } else if (initialSlope === 0.0) {\n      return guessForT;\n    } else {\n      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n    }\n  }\n\n  return function BezierEasing (x) {\n    // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n    if (x === 0) {\n      return 0;\n    }\n    if (x === 1) {\n      return 1;\n    }\n    return calcBezier(getTForX(x), mY1, mY2);\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9iZXppZXItZWFzaW5nL3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSx3QkFBd0I7QUFDeEIsd0JBQXdCO0FBQ3hCLHdCQUF3Qjs7QUFFeEI7QUFDQSxxQ0FBcUM7O0FBRXJDO0FBQ0EsbUNBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsdUJBQXVCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVyxtRUFBbUU7QUFDOUU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tdmVudHVyYS9Eb2N1bWVudHMvR2l0SHViL21vcnBoZS9ub2RlX21vZHVsZXMvYmV6aWVyLWVhc2luZy9zcmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vZ3JlL2Jlemllci1lYXNpbmdcbiAqIEJlemllckVhc2luZyAtIHVzZSBiZXppZXIgY3VydmUgZm9yIHRyYW5zaXRpb24gZWFzaW5nIGZ1bmN0aW9uXG4gKiBieSBHYcOrdGFuIFJlbmF1ZGVhdSAyMDE0IC0gMjAxNSDigJMgTUlUIExpY2Vuc2VcbiAqL1xuXG4vLyBUaGVzZSB2YWx1ZXMgYXJlIGVzdGFibGlzaGVkIGJ5IGVtcGlyaWNpc20gd2l0aCB0ZXN0cyAodHJhZGVvZmY6IHBlcmZvcm1hbmNlIFZTIHByZWNpc2lvbilcbnZhciBORVdUT05fSVRFUkFUSU9OUyA9IDQ7XG52YXIgTkVXVE9OX01JTl9TTE9QRSA9IDAuMDAxO1xudmFyIFNVQkRJVklTSU9OX1BSRUNJU0lPTiA9IDAuMDAwMDAwMTtcbnZhciBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyA9IDEwO1xuXG52YXIga1NwbGluZVRhYmxlU2l6ZSA9IDExO1xudmFyIGtTYW1wbGVTdGVwU2l6ZSA9IDEuMCAvIChrU3BsaW5lVGFibGVTaXplIC0gMS4wKTtcblxudmFyIGZsb2F0MzJBcnJheVN1cHBvcnRlZCA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICdmdW5jdGlvbic7XG5cbmZ1bmN0aW9uIEEgKGFBMSwgYUEyKSB7IHJldHVybiAxLjAgLSAzLjAgKiBhQTIgKyAzLjAgKiBhQTE7IH1cbmZ1bmN0aW9uIEIgKGFBMSwgYUEyKSB7IHJldHVybiAzLjAgKiBhQTIgLSA2LjAgKiBhQTE7IH1cbmZ1bmN0aW9uIEMgKGFBMSkgICAgICB7IHJldHVybiAzLjAgKiBhQTE7IH1cblxuLy8gUmV0dXJucyB4KHQpIGdpdmVuIHQsIHgxLCBhbmQgeDIsIG9yIHkodCkgZ2l2ZW4gdCwgeTEsIGFuZCB5Mi5cbmZ1bmN0aW9uIGNhbGNCZXppZXIgKGFULCBhQTEsIGFBMikgeyByZXR1cm4gKChBKGFBMSwgYUEyKSAqIGFUICsgQihhQTEsIGFBMikpICogYVQgKyBDKGFBMSkpICogYVQ7IH1cblxuLy8gUmV0dXJucyBkeC9kdCBnaXZlbiB0LCB4MSwgYW5kIHgyLCBvciBkeS9kdCBnaXZlbiB0LCB5MSwgYW5kIHkyLlxuZnVuY3Rpb24gZ2V0U2xvcGUgKGFULCBhQTEsIGFBMikgeyByZXR1cm4gMy4wICogQShhQTEsIGFBMikgKiBhVCAqIGFUICsgMi4wICogQihhQTEsIGFBMikgKiBhVCArIEMoYUExKTsgfVxuXG5mdW5jdGlvbiBiaW5hcnlTdWJkaXZpZGUgKGFYLCBhQSwgYUIsIG1YMSwgbVgyKSB7XG4gIHZhciBjdXJyZW50WCwgY3VycmVudFQsIGkgPSAwO1xuICBkbyB7XG4gICAgY3VycmVudFQgPSBhQSArIChhQiAtIGFBKSAvIDIuMDtcbiAgICBjdXJyZW50WCA9IGNhbGNCZXppZXIoY3VycmVudFQsIG1YMSwgbVgyKSAtIGFYO1xuICAgIGlmIChjdXJyZW50WCA+IDAuMCkge1xuICAgICAgYUIgPSBjdXJyZW50VDtcbiAgICB9IGVsc2Uge1xuICAgICAgYUEgPSBjdXJyZW50VDtcbiAgICB9XG4gIH0gd2hpbGUgKE1hdGguYWJzKGN1cnJlbnRYKSA+IFNVQkRJVklTSU9OX1BSRUNJU0lPTiAmJiArK2kgPCBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyk7XG4gIHJldHVybiBjdXJyZW50VDtcbn1cblxuZnVuY3Rpb24gbmV3dG9uUmFwaHNvbkl0ZXJhdGUgKGFYLCBhR3Vlc3NULCBtWDEsIG1YMikge1xuIGZvciAodmFyIGkgPSAwOyBpIDwgTkVXVE9OX0lURVJBVElPTlM7ICsraSkge1xuICAgdmFyIGN1cnJlbnRTbG9wZSA9IGdldFNsb3BlKGFHdWVzc1QsIG1YMSwgbVgyKTtcbiAgIGlmIChjdXJyZW50U2xvcGUgPT09IDAuMCkge1xuICAgICByZXR1cm4gYUd1ZXNzVDtcbiAgIH1cbiAgIHZhciBjdXJyZW50WCA9IGNhbGNCZXppZXIoYUd1ZXNzVCwgbVgxLCBtWDIpIC0gYVg7XG4gICBhR3Vlc3NUIC09IGN1cnJlbnRYIC8gY3VycmVudFNsb3BlO1xuIH1cbiByZXR1cm4gYUd1ZXNzVDtcbn1cblxuZnVuY3Rpb24gTGluZWFyRWFzaW5nICh4KSB7XG4gIHJldHVybiB4O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJlemllciAobVgxLCBtWTEsIG1YMiwgbVkyKSB7XG4gIGlmICghKDAgPD0gbVgxICYmIG1YMSA8PSAxICYmIDAgPD0gbVgyICYmIG1YMiA8PSAxKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignYmV6aWVyIHggdmFsdWVzIG11c3QgYmUgaW4gWzAsIDFdIHJhbmdlJyk7XG4gIH1cblxuICBpZiAobVgxID09PSBtWTEgJiYgbVgyID09PSBtWTIpIHtcbiAgICByZXR1cm4gTGluZWFyRWFzaW5nO1xuICB9XG5cbiAgLy8gUHJlY29tcHV0ZSBzYW1wbGVzIHRhYmxlXG4gIHZhciBzYW1wbGVWYWx1ZXMgPSBmbG9hdDMyQXJyYXlTdXBwb3J0ZWQgPyBuZXcgRmxvYXQzMkFycmF5KGtTcGxpbmVUYWJsZVNpemUpIDogbmV3IEFycmF5KGtTcGxpbmVUYWJsZVNpemUpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGtTcGxpbmVUYWJsZVNpemU7ICsraSkge1xuICAgIHNhbXBsZVZhbHVlc1tpXSA9IGNhbGNCZXppZXIoaSAqIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0VEZvclggKGFYKSB7XG4gICAgdmFyIGludGVydmFsU3RhcnQgPSAwLjA7XG4gICAgdmFyIGN1cnJlbnRTYW1wbGUgPSAxO1xuICAgIHZhciBsYXN0U2FtcGxlID0ga1NwbGluZVRhYmxlU2l6ZSAtIDE7XG5cbiAgICBmb3IgKDsgY3VycmVudFNhbXBsZSAhPT0gbGFzdFNhbXBsZSAmJiBzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0gPD0gYVg7ICsrY3VycmVudFNhbXBsZSkge1xuICAgICAgaW50ZXJ2YWxTdGFydCArPSBrU2FtcGxlU3RlcFNpemU7XG4gICAgfVxuICAgIC0tY3VycmVudFNhbXBsZTtcblxuICAgIC8vIEludGVycG9sYXRlIHRvIHByb3ZpZGUgYW4gaW5pdGlhbCBndWVzcyBmb3IgdFxuICAgIHZhciBkaXN0ID0gKGFYIC0gc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKSAvIChzYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZSArIDFdIC0gc2FtcGxlVmFsdWVzW2N1cnJlbnRTYW1wbGVdKTtcbiAgICB2YXIgZ3Vlc3NGb3JUID0gaW50ZXJ2YWxTdGFydCArIGRpc3QgKiBrU2FtcGxlU3RlcFNpemU7XG5cbiAgICB2YXIgaW5pdGlhbFNsb3BlID0gZ2V0U2xvcGUoZ3Vlc3NGb3JULCBtWDEsIG1YMik7XG4gICAgaWYgKGluaXRpYWxTbG9wZSA+PSBORVdUT05fTUlOX1NMT1BFKSB7XG4gICAgICByZXR1cm4gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuICAgIH0gZWxzZSBpZiAoaW5pdGlhbFNsb3BlID09PSAwLjApIHtcbiAgICAgIHJldHVybiBndWVzc0ZvclQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBiaW5hcnlTdWJkaXZpZGUoYVgsIGludGVydmFsU3RhcnQsIGludGVydmFsU3RhcnQgKyBrU2FtcGxlU3RlcFNpemUsIG1YMSwgbVgyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gQmV6aWVyRWFzaW5nICh4KSB7XG4gICAgLy8gQmVjYXVzZSBKYXZhU2NyaXB0IG51bWJlciBhcmUgaW1wcmVjaXNlLCB3ZSBzaG91bGQgZ3VhcmFudGVlIHRoZSBleHRyZW1lcyBhcmUgcmlnaHQuXG4gICAgaWYgKHggPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBpZiAoeCA9PT0gMSkge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIHJldHVybiBjYWxjQmV6aWVyKGdldFRGb3JYKHgpLCBtWTEsIG1ZMik7XG4gIH07XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/bezier-easing/src/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/api/navigation.js":
/*!**************************************************!*\
  !*** ./node_modules/next/dist/api/navigation.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../client/components/navigation */ \"(app-pages-browser)/./node_modules/next/dist/client/components/navigation.js\");\n/* harmony import */ var _client_components_navigation__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_client_components_navigation__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};\n/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__) if(__WEBPACK_IMPORT_KEY__ !== \"default\") __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => _client_components_navigation__WEBPACK_IMPORTED_MODULE_0__[__WEBPACK_IMPORT_KEY__]\n/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);\n\n\n//# sourceMappingURL=navigation.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL25hdmlnYXRpb24uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQWdEOztBQUVoRCIsInNvdXJjZXMiOlsiL1VzZXJzL212ZW50dXJhL0RvY3VtZW50cy9HaXRIdWIvbW9ycGhlL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYXBpL25hdmlnYXRpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnLi4vY2xpZW50L2NvbXBvbmVudHMvbmF2aWdhdGlvbic7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW5hdmlnYXRpb24uanMubWFwIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/api/navigation.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js ***!
  \*********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(()=>{\"use strict\";var e={413:(e,r,t)=>{var n=t(916);var i=Object.create(null);var a=typeof document===\"undefined\";var o=Array.prototype.forEach;function debounce(e,r){var t=0;return function(){var n=this;var i=arguments;var a=function functionCall(){return e.apply(n,i)};clearTimeout(t);t=setTimeout(a,r)}}function noop(){}function getCurrentScriptUrl(e){var r=i[e];if(!r){if(document.currentScript){r=document.currentScript.src}else{var t=document.getElementsByTagName(\"script\");var a=t[t.length-1];if(a){r=a.src}}i[e]=r}return function(e){if(!r){return null}var t=r.split(/([^\\\\/]+)\\.js$/);var i=t&&t[1];if(!i){return[r.replace(\".js\",\".css\")]}if(!e){return[r.replace(\".js\",\".css\")]}return e.split(\",\").map((function(e){var t=new RegExp(\"\".concat(i,\"\\\\.js$\"),\"g\");return n(r.replace(t,\"\".concat(e.replace(/{fileName}/g,i),\".css\")))}))}}function updateCss(e,r){if(!r){if(!e.href){return}r=e.href.split(\"?\")[0]}if(!isUrlRequest(r)){return}if(e.isLoaded===false){return}if(!r||!(r.indexOf(\".css\")>-1)){return}e.visited=true;var t=e.cloneNode();t.isLoaded=false;t.addEventListener(\"load\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.addEventListener(\"error\",(function(){if(t.isLoaded){return}t.isLoaded=true;e.parentNode.removeChild(e)}));t.href=\"\".concat(r,\"?\").concat(Date.now());if(e.nextSibling){e.parentNode.insertBefore(t,e.nextSibling)}else{e.parentNode.appendChild(t)}}function getReloadUrl(e,r){var t;e=n(e,{stripWWW:false});r.some((function(n){if(e.indexOf(r)>-1){t=n}}));return t}function reloadStyle(e){if(!e){return false}var r=document.querySelectorAll(\"link\");var t=false;o.call(r,(function(r){if(!r.href){return}var n=getReloadUrl(r.href,e);if(!isUrlRequest(n)){return}if(r.visited===true){return}if(n){updateCss(r,n);t=true}}));return t}function reloadAll(){var e=document.querySelectorAll(\"link\");o.call(e,(function(e){if(e.visited===true){return}updateCss(e)}))}function isUrlRequest(e){if(!/^[a-zA-Z][a-zA-Z\\d+\\-.]*:/.test(e)){return false}return true}e.exports=function(e,r){if(a){console.log(\"no window.document found, will not HMR CSS\");return noop}var t=getCurrentScriptUrl(e);function update(){var e=t(r.filename);var n=reloadStyle(e);if(r.locals){console.log(\"[HMR] Detected local css modules. Reload all css\");reloadAll();return}if(n){console.log(\"[HMR] css reload %s\",e.join(\" \"))}else{console.log(\"[HMR] Reload all css\");reloadAll()}}return debounce(update,50)}},916:e=>{function normalizeUrl(e){return e.reduce((function(e,r){switch(r){case\"..\":e.pop();break;case\".\":break;default:e.push(r)}return e}),[]).join(\"/\")}e.exports=function(e){e=e.trim();if(/^data:/i.test(e)){return e}var r=e.indexOf(\"//\")!==-1?e.split(\"//\")[0]+\"//\":\"\";var t=e.replace(new RegExp(r,\"i\"),\"\").split(\"/\");var n=t[0].toLowerCase().replace(/\\.$/,\"\");t[0]=\"\";var i=normalizeUrl(t);return r+n+i}}};var r={};function __nccwpck_require__(t){var n=r[t];if(n!==undefined){return n.exports}var i=r[t]={exports:{}};var a=true;try{e[t](i,i.exports,__nccwpck_require__);a=false}finally{if(a)delete r[t]}return i.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(413);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzIiwibWFwcGluZ3MiOiI7QUFBQSxNQUFNLGFBQWEsT0FBTyxjQUFjLGFBQWEsMEJBQTBCLG9DQUFvQyw4QkFBOEIsdUJBQXVCLFFBQVEsa0JBQWtCLFdBQVcsZ0JBQWdCLDhCQUE4QixxQkFBcUIsZ0JBQWdCLG1CQUFtQixpQkFBaUIsZ0NBQWdDLFdBQVcsT0FBTywyQkFBMkIsNkJBQTZCLEtBQUssOENBQThDLG9CQUFvQixNQUFNLFNBQVMsT0FBTyxtQkFBbUIsT0FBTyxZQUFZLGdDQUFnQyxjQUFjLE9BQU8sZ0NBQWdDLE9BQU8sZ0NBQWdDLHFDQUFxQyw0Q0FBNEMsMkNBQTJDLFNBQVMsZ0JBQWdCLElBQUksd0JBQXdCLE9BQU8sWUFBWSxPQUFPLHVCQUF1QixxQkFBcUIsT0FBTyx1QkFBdUIsT0FBTyxnQ0FBZ0MsT0FBTyxlQUFlLG9CQUFvQixpQkFBaUIsc0NBQXNDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsdUNBQXVDLGVBQWUsT0FBTyxnQkFBZ0IsNEJBQTRCLEdBQUcsMkNBQTJDLGtCQUFrQiwyQ0FBMkMsS0FBSyw2QkFBNkIsMkJBQTJCLE1BQU0sT0FBTyxlQUFlLEVBQUUsb0JBQW9CLG9CQUFvQixLQUFLLEdBQUcsU0FBUyx3QkFBd0IsT0FBTyxhQUFhLHdDQUF3QyxZQUFZLHNCQUFzQixZQUFZLE9BQU8sNkJBQTZCLHFCQUFxQixPQUFPLHFCQUFxQixPQUFPLE1BQU0sZUFBZSxRQUFRLEdBQUcsU0FBUyxxQkFBcUIsd0NBQXdDLHNCQUFzQixxQkFBcUIsT0FBTyxhQUFhLEdBQUcseUJBQXlCLHlDQUF5QyxhQUFhLFlBQVksd0JBQXdCLE1BQU0sMERBQTBELFlBQVksNkJBQTZCLGtCQUFrQixvQkFBb0IscUJBQXFCLGFBQWEsZ0VBQWdFLFlBQVksT0FBTyxNQUFNLCtDQUErQyxLQUFLLG9DQUFvQyxhQUFhLDRCQUE0QixTQUFTLHlCQUF5QiwrQkFBK0IsVUFBVSxpQkFBaUIsTUFBTSxjQUFjLGtCQUFrQixTQUFTLGdCQUFnQixzQkFBc0IsV0FBVyxzQkFBc0IsU0FBUyxvREFBb0QsaURBQWlELDJDQUEyQyxRQUFRLHNCQUFzQixnQkFBZ0IsU0FBUyxnQ0FBZ0MsV0FBVyxrQkFBa0IsaUJBQWlCLFlBQVksWUFBWSxXQUFXLElBQUksc0NBQXNDLFFBQVEsUUFBUSxpQkFBaUIsaUJBQWlCLG1FQUFtRSxTQUFTLEtBQUssK0JBQStCLGlCQUFpQiIsInNvdXJjZXMiOlsiL1VzZXJzL212ZW50dXJhL0RvY3VtZW50cy9HaXRIdWIvbW9ycGhlL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvbWluaS1jc3MtZXh0cmFjdC1wbHVnaW4vaG1yL2hvdE1vZHVsZVJlcGxhY2VtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIigoKT0+e1widXNlIHN0cmljdFwiO3ZhciBlPXs0MTM6KGUscix0KT0+e3ZhciBuPXQoOTE2KTt2YXIgaT1PYmplY3QuY3JlYXRlKG51bGwpO3ZhciBhPXR5cGVvZiBkb2N1bWVudD09PVwidW5kZWZpbmVkXCI7dmFyIG89QXJyYXkucHJvdG90eXBlLmZvckVhY2g7ZnVuY3Rpb24gZGVib3VuY2UoZSxyKXt2YXIgdD0wO3JldHVybiBmdW5jdGlvbigpe3ZhciBuPXRoaXM7dmFyIGk9YXJndW1lbnRzO3ZhciBhPWZ1bmN0aW9uIGZ1bmN0aW9uQ2FsbCgpe3JldHVybiBlLmFwcGx5KG4saSl9O2NsZWFyVGltZW91dCh0KTt0PXNldFRpbWVvdXQoYSxyKX19ZnVuY3Rpb24gbm9vcCgpe31mdW5jdGlvbiBnZXRDdXJyZW50U2NyaXB0VXJsKGUpe3ZhciByPWlbZV07aWYoIXIpe2lmKGRvY3VtZW50LmN1cnJlbnRTY3JpcHQpe3I9ZG9jdW1lbnQuY3VycmVudFNjcmlwdC5zcmN9ZWxzZXt2YXIgdD1kb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTt2YXIgYT10W3QubGVuZ3RoLTFdO2lmKGEpe3I9YS5zcmN9fWlbZV09cn1yZXR1cm4gZnVuY3Rpb24oZSl7aWYoIXIpe3JldHVybiBudWxsfXZhciB0PXIuc3BsaXQoLyhbXlxcXFwvXSspXFwuanMkLyk7dmFyIGk9dCYmdFsxXTtpZighaSl7cmV0dXJuW3IucmVwbGFjZShcIi5qc1wiLFwiLmNzc1wiKV19aWYoIWUpe3JldHVybltyLnJlcGxhY2UoXCIuanNcIixcIi5jc3NcIildfXJldHVybiBlLnNwbGl0KFwiLFwiKS5tYXAoKGZ1bmN0aW9uKGUpe3ZhciB0PW5ldyBSZWdFeHAoXCJcIi5jb25jYXQoaSxcIlxcXFwuanMkXCIpLFwiZ1wiKTtyZXR1cm4gbihyLnJlcGxhY2UodCxcIlwiLmNvbmNhdChlLnJlcGxhY2UoL3tmaWxlTmFtZX0vZyxpKSxcIi5jc3NcIikpKX0pKX19ZnVuY3Rpb24gdXBkYXRlQ3NzKGUscil7aWYoIXIpe2lmKCFlLmhyZWYpe3JldHVybn1yPWUuaHJlZi5zcGxpdChcIj9cIilbMF19aWYoIWlzVXJsUmVxdWVzdChyKSl7cmV0dXJufWlmKGUuaXNMb2FkZWQ9PT1mYWxzZSl7cmV0dXJufWlmKCFyfHwhKHIuaW5kZXhPZihcIi5jc3NcIik+LTEpKXtyZXR1cm59ZS52aXNpdGVkPXRydWU7dmFyIHQ9ZS5jbG9uZU5vZGUoKTt0LmlzTG9hZGVkPWZhbHNlO3QuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwoZnVuY3Rpb24oKXtpZih0LmlzTG9hZGVkKXtyZXR1cm59dC5pc0xvYWRlZD10cnVlO2UucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlKX0pKTt0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLChmdW5jdGlvbigpe2lmKHQuaXNMb2FkZWQpe3JldHVybn10LmlzTG9hZGVkPXRydWU7ZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGUpfSkpO3QuaHJlZj1cIlwiLmNvbmNhdChyLFwiP1wiKS5jb25jYXQoRGF0ZS5ub3coKSk7aWYoZS5uZXh0U2libGluZyl7ZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0LGUubmV4dFNpYmxpbmcpfWVsc2V7ZS5wYXJlbnROb2RlLmFwcGVuZENoaWxkKHQpfX1mdW5jdGlvbiBnZXRSZWxvYWRVcmwoZSxyKXt2YXIgdDtlPW4oZSx7c3RyaXBXV1c6ZmFsc2V9KTtyLnNvbWUoKGZ1bmN0aW9uKG4pe2lmKGUuaW5kZXhPZihyKT4tMSl7dD1ufX0pKTtyZXR1cm4gdH1mdW5jdGlvbiByZWxvYWRTdHlsZShlKXtpZighZSl7cmV0dXJuIGZhbHNlfXZhciByPWRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCJsaW5rXCIpO3ZhciB0PWZhbHNlO28uY2FsbChyLChmdW5jdGlvbihyKXtpZighci5ocmVmKXtyZXR1cm59dmFyIG49Z2V0UmVsb2FkVXJsKHIuaHJlZixlKTtpZighaXNVcmxSZXF1ZXN0KG4pKXtyZXR1cm59aWYoci52aXNpdGVkPT09dHJ1ZSl7cmV0dXJufWlmKG4pe3VwZGF0ZUNzcyhyLG4pO3Q9dHJ1ZX19KSk7cmV0dXJuIHR9ZnVuY3Rpb24gcmVsb2FkQWxsKCl7dmFyIGU9ZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImxpbmtcIik7by5jYWxsKGUsKGZ1bmN0aW9uKGUpe2lmKGUudmlzaXRlZD09PXRydWUpe3JldHVybn11cGRhdGVDc3MoZSl9KSl9ZnVuY3Rpb24gaXNVcmxSZXF1ZXN0KGUpe2lmKCEvXlthLXpBLVpdW2EtekEtWlxcZCtcXC0uXSo6Ly50ZXN0KGUpKXtyZXR1cm4gZmFsc2V9cmV0dXJuIHRydWV9ZS5leHBvcnRzPWZ1bmN0aW9uKGUscil7aWYoYSl7Y29uc29sZS5sb2coXCJubyB3aW5kb3cuZG9jdW1lbnQgZm91bmQsIHdpbGwgbm90IEhNUiBDU1NcIik7cmV0dXJuIG5vb3B9dmFyIHQ9Z2V0Q3VycmVudFNjcmlwdFVybChlKTtmdW5jdGlvbiB1cGRhdGUoKXt2YXIgZT10KHIuZmlsZW5hbWUpO3ZhciBuPXJlbG9hZFN0eWxlKGUpO2lmKHIubG9jYWxzKXtjb25zb2xlLmxvZyhcIltITVJdIERldGVjdGVkIGxvY2FsIGNzcyBtb2R1bGVzLiBSZWxvYWQgYWxsIGNzc1wiKTtyZWxvYWRBbGwoKTtyZXR1cm59aWYobil7Y29uc29sZS5sb2coXCJbSE1SXSBjc3MgcmVsb2FkICVzXCIsZS5qb2luKFwiIFwiKSl9ZWxzZXtjb25zb2xlLmxvZyhcIltITVJdIFJlbG9hZCBhbGwgY3NzXCIpO3JlbG9hZEFsbCgpfX1yZXR1cm4gZGVib3VuY2UodXBkYXRlLDUwKX19LDkxNjplPT57ZnVuY3Rpb24gbm9ybWFsaXplVXJsKGUpe3JldHVybiBlLnJlZHVjZSgoZnVuY3Rpb24oZSxyKXtzd2l0Y2gocil7Y2FzZVwiLi5cIjplLnBvcCgpO2JyZWFrO2Nhc2VcIi5cIjpicmVhaztkZWZhdWx0OmUucHVzaChyKX1yZXR1cm4gZX0pLFtdKS5qb2luKFwiL1wiKX1lLmV4cG9ydHM9ZnVuY3Rpb24oZSl7ZT1lLnRyaW0oKTtpZigvXmRhdGE6L2kudGVzdChlKSl7cmV0dXJuIGV9dmFyIHI9ZS5pbmRleE9mKFwiLy9cIikhPT0tMT9lLnNwbGl0KFwiLy9cIilbMF0rXCIvL1wiOlwiXCI7dmFyIHQ9ZS5yZXBsYWNlKG5ldyBSZWdFeHAocixcImlcIiksXCJcIikuc3BsaXQoXCIvXCIpO3ZhciBuPXRbMF0udG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXC4kLyxcIlwiKTt0WzBdPVwiXCI7dmFyIGk9bm9ybWFsaXplVXJsKHQpO3JldHVybiByK24raX19fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHQpe3ZhciBuPXJbdF07aWYobiE9PXVuZGVmaW5lZCl7cmV0dXJuIG4uZXhwb3J0c312YXIgaT1yW3RdPXtleHBvcnRzOnt9fTt2YXIgYT10cnVlO3RyeXtlW3RdKGksaS5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2E9ZmFsc2V9ZmluYWxseXtpZihhKWRlbGV0ZSByW3RdfXJldHVybiBpLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB0PV9fbmNjd3Bja19yZXF1aXJlX18oNDEzKTttb2R1bGUuZXhwb3J0cz10fSkoKTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/parallax-controller/dist/parallax-controller.esm.js":
/*!**************************************************************************!*\
  !*** ./node_modules/parallax-controller/dist/parallax-controller.esm.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EasingPreset: () => (/* binding */ EasingPreset),\n/* harmony export */   Element: () => (/* binding */ Element),\n/* harmony export */   Limits: () => (/* binding */ Limits),\n/* harmony export */   ParallaxController: () => (/* binding */ ParallaxController),\n/* harmony export */   Rect: () => (/* binding */ Rect),\n/* harmony export */   RotationUnits: () => (/* binding */ RotationUnits),\n/* harmony export */   ScaleUnits: () => (/* binding */ ScaleUnits),\n/* harmony export */   Scroll: () => (/* binding */ Scroll),\n/* harmony export */   ScrollAxis: () => (/* binding */ ScrollAxis),\n/* harmony export */   Units: () => (/* binding */ Units),\n/* harmony export */   ValidCSSEffects: () => (/* binding */ ValidCSSEffects),\n/* harmony export */   View: () => (/* binding */ View),\n/* harmony export */   createId: () => (/* binding */ createId),\n/* harmony export */   getProgressAmount: () => (/* binding */ getProgressAmount),\n/* harmony export */   isElementInView: () => (/* binding */ isElementInView),\n/* harmony export */   parseElementTransitionEffects: () => (/* binding */ parseElementTransitionEffects),\n/* harmony export */   parseValueAndUnit: () => (/* binding */ parseValueAndUnit),\n/* harmony export */   resetStyles: () => (/* binding */ resetStyles),\n/* harmony export */   scaleBetween: () => (/* binding */ scaleBetween),\n/* harmony export */   scaleEffectByProgress: () => (/* binding */ scaleEffectByProgress),\n/* harmony export */   setElementStyles: () => (/* binding */ setElementStyles),\n/* harmony export */   testForPassiveScroll: () => (/* binding */ testForPassiveScroll)\n/* harmony export */ });\n/* harmony import */ var bezier_easing__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bezier-easing */ \"(app-pages-browser)/./node_modules/bezier-easing/src/index.js\");\n/* harmony import */ var bezier_easing__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bezier_easing__WEBPACK_IMPORTED_MODULE_0__);\n\n\nvar Limits = function Limits(properties) {\n  this.startX = properties.startX;\n  this.startY = properties.startY;\n  this.endX = properties.endX;\n  this.endY = properties.endY; // Used to calculate the progress of the element\n\n  this.totalX = this.endX - this.startX;\n  this.totalY = this.endY - this.startY; // Used to scale translate effects\n\n  this.startMultiplierX = properties.startMultiplierX || 1;\n  this.endMultiplierX = properties.endMultiplierX || 1;\n  this.startMultiplierY = properties.startMultiplierY || 1;\n  this.endMultiplierY = properties.endMultiplierY || 1;\n};\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nvar ValidCSSEffects;\n\n(function (ValidCSSEffects) {\n  ValidCSSEffects[\"speed\"] = \"speed\";\n  ValidCSSEffects[\"translateX\"] = \"translateX\";\n  ValidCSSEffects[\"translateY\"] = \"translateY\";\n  ValidCSSEffects[\"rotate\"] = \"rotate\";\n  ValidCSSEffects[\"rotateX\"] = \"rotateX\";\n  ValidCSSEffects[\"rotateY\"] = \"rotateY\";\n  ValidCSSEffects[\"rotateZ\"] = \"rotateZ\";\n  ValidCSSEffects[\"scale\"] = \"scale\";\n  ValidCSSEffects[\"scaleX\"] = \"scaleX\";\n  ValidCSSEffects[\"scaleY\"] = \"scaleY\";\n  ValidCSSEffects[\"scaleZ\"] = \"scaleZ\";\n  ValidCSSEffects[\"opacity\"] = \"opacity\";\n})(ValidCSSEffects || (ValidCSSEffects = {}));\n\nvar Units;\n\n(function (Units) {\n  Units[\"px\"] = \"px\";\n  Units[\"%\"] = \"%\";\n  Units[\"vh\"] = \"vh\";\n  Units[\"vw\"] = \"vw\";\n})(Units || (Units = {}));\n\nvar RotationUnits;\n\n(function (RotationUnits) {\n  RotationUnits[\"deg\"] = \"deg\";\n  RotationUnits[\"turn\"] = \"turn\";\n  RotationUnits[\"rad\"] = \"rad\";\n})(RotationUnits || (RotationUnits = {}));\n\nvar ScaleUnits;\n\n(function (ScaleUnits) {\n  ScaleUnits[\"\"] = \"\";\n})(ScaleUnits || (ScaleUnits = {}));\n\nvar ScrollAxis;\n\n(function (ScrollAxis) {\n  ScrollAxis[\"vertical\"] = \"vertical\";\n  ScrollAxis[\"horizontal\"] = \"horizontal\";\n})(ScrollAxis || (ScrollAxis = {}));\n\nvar EasingPreset;\n\n(function (EasingPreset) {\n  EasingPreset[\"ease\"] = \"ease\";\n  EasingPreset[\"easeIn\"] = \"easeIn\";\n  EasingPreset[\"easeOut\"] = \"easeOut\";\n  EasingPreset[\"easeInOut\"] = \"easeInOut\";\n  EasingPreset[\"easeInQuad\"] = \"easeInQuad\";\n  EasingPreset[\"easeInCubic\"] = \"easeInCubic\";\n  EasingPreset[\"easeInQuart\"] = \"easeInQuart\";\n  EasingPreset[\"easeInQuint\"] = \"easeInQuint\";\n  EasingPreset[\"easeInSine\"] = \"easeInSine\";\n  EasingPreset[\"easeInExpo\"] = \"easeInExpo\";\n  EasingPreset[\"easeInCirc\"] = \"easeInCirc\";\n  EasingPreset[\"easeOutQuad\"] = \"easeOutQuad\";\n  EasingPreset[\"easeOutCubic\"] = \"easeOutCubic\";\n  EasingPreset[\"easeOutQuart\"] = \"easeOutQuart\";\n  EasingPreset[\"easeOutQuint\"] = \"easeOutQuint\";\n  EasingPreset[\"easeOutSine\"] = \"easeOutSine\";\n  EasingPreset[\"easeOutExpo\"] = \"easeOutExpo\";\n  EasingPreset[\"easeOutCirc\"] = \"easeOutCirc\";\n  EasingPreset[\"easeInOutQuad\"] = \"easeInOutQuad\";\n  EasingPreset[\"easeInOutCubic\"] = \"easeInOutCubic\";\n  EasingPreset[\"easeInOutQuart\"] = \"easeInOutQuart\";\n  EasingPreset[\"easeInOutQuint\"] = \"easeInOutQuint\";\n  EasingPreset[\"easeInOutSine\"] = \"easeInOutSine\";\n  EasingPreset[\"easeInOutExpo\"] = \"easeInOutExpo\";\n  EasingPreset[\"easeInOutCirc\"] = \"easeInOutCirc\";\n  EasingPreset[\"easeInBack\"] = \"easeInBack\";\n  EasingPreset[\"easeOutBack\"] = \"easeOutBack\";\n  EasingPreset[\"easeInOutBack\"] = \"easeInOutBack\";\n})(EasingPreset || (EasingPreset = {}));\n\n/**\r\n * Creates a unique id to distinguish parallax elements.\r\n */\nvar id = 0;\nfunction createId() {\n  ++id;\n  return id;\n}\n\nvar Rect = /*#__PURE__*/function () {\n  function Rect(options) {\n    var rect = options.el.getBoundingClientRect(); // rect is based on viewport -- must adjust for relative scroll container\n\n    if (options.view.scrollContainer) {\n      var scrollRect = options.view.scrollContainer.getBoundingClientRect();\n      rect = _extends({}, rect, {\n        top: rect.top - scrollRect.top,\n        right: rect.right - scrollRect.left,\n        bottom: rect.bottom - scrollRect.top,\n        left: rect.left - scrollRect.left\n      });\n    }\n\n    this.height = options.el.offsetHeight;\n    this.width = options.el.offsetWidth;\n    this.left = rect.left;\n    this.right = rect.right;\n    this.top = rect.top;\n    this.bottom = rect.bottom;\n\n    if (options.rootMargin) {\n      this._setRectWithRootMargin(options.rootMargin);\n    }\n  }\n  /**\r\n   * Apply root margin to all properties\r\n   */\n\n\n  var _proto = Rect.prototype;\n\n  _proto._setRectWithRootMargin = function _setRectWithRootMargin(rootMargin) {\n    var totalRootY = rootMargin.top + rootMargin.bottom;\n    var totalRootX = rootMargin.left + rootMargin.right;\n    this.top -= rootMargin.top;\n    this.right += rootMargin.right;\n    this.bottom += rootMargin.bottom;\n    this.left -= rootMargin.left;\n    this.height += totalRootY;\n    this.width += totalRootX;\n  };\n\n  return Rect;\n}();\n\nvar VALID_UNITS = [ScaleUnits[''], Units.px, Units['%'], Units['vh'], Units['vw'], RotationUnits.deg, RotationUnits.turn, RotationUnits.rad];\n/**\r\n * Determines the unit of a string and parses the value\r\n */\n\nfunction parseValueAndUnit(str, defaultUnit) {\n  if (defaultUnit === void 0) {\n    defaultUnit = Units['%'];\n  }\n\n  var out = {\n    value: 0,\n    unit: defaultUnit\n  };\n  if (typeof str === 'undefined') return out;\n  var isValid = typeof str === 'number' || typeof str === 'string';\n\n  if (!isValid) {\n    throw new Error('Invalid value provided. Must provide a value as a string or number');\n  }\n\n  str = String(str);\n  out.value = parseFloat(str); // @ts-ignore\n\n  out.unit = str.match(/[\\d.\\-+]*\\s*(.*)/)[1] || defaultUnit; // @ts-expect-error\n\n  var isValidUnit = VALID_UNITS.includes(out.unit);\n\n  if (!isValidUnit) {\n    throw new Error('Invalid unit provided.');\n  }\n\n  return out;\n}\n\nvar easingPresets = {\n  ease: [0.25, 0.1, 0.25, 1.0],\n  easeIn: [0.42, 0.0, 1.0, 1.0],\n  easeOut: [0.0, 0.0, 0.58, 1.0],\n  easeInOut: [0.42, 0.0, 0.58, 1.0],\n\n  /* Ease IN curves */\n  easeInQuad: [0.55, 0.085, 0.68, 0.53],\n  easeInCubic: [0.55, 0.055, 0.675, 0.19],\n  easeInQuart: [0.895, 0.03, 0.685, 0.22],\n  easeInQuint: [0.755, 0.05, 0.855, 0.06],\n  easeInSine: [0.47, 0.0, 0.745, 0.715],\n  easeInExpo: [0.95, 0.05, 0.795, 0.035],\n  easeInCirc: [0.6, 0.04, 0.98, 0.335],\n\n  /* Ease Out Curves */\n  easeOutQuad: [0.25, 0.46, 0.45, 0.94],\n  easeOutCubic: [0.215, 0.61, 0.355, 1.0],\n  easeOutQuart: [0.165, 0.84, 0.44, 1.0],\n  easeOutQuint: [0.23, 1.0, 0.32, 1.0],\n  easeOutSine: [0.39, 0.575, 0.565, 1.0],\n  easeOutExpo: [0.19, 1.0, 0.22, 1.0],\n  easeOutCirc: [0.075, 0.82, 0.165, 1.0],\n\n  /* Ease IN Out Curves */\n  easeInOutQuad: [0.455, 0.03, 0.515, 0.955],\n  easeInOutCubic: [0.645, 0.045, 0.355, 1.0],\n  easeInOutQuart: [0.77, 0.0, 0.175, 1.0],\n  easeInOutQuint: [0.86, 0.0, 0.07, 1.0],\n  easeInOutSine: [0.445, 0.05, 0.55, 0.95],\n  easeInOutExpo: [1.0, 0.0, 0.0, 1.0],\n  easeInOutCirc: [0.785, 0.135, 0.15, 0.86],\n\n  /* Ease Bounce Curves */\n  easeInBack: [0.6, -0.28, 0.735, 0.045],\n  easeOutBack: [0.175, 0.885, 0.32, 1.275],\n  easeInOutBack: [0.68, -0.55, 0.265, 1.55]\n};\n\nfunction createEasingFunction(easing) {\n  if (Array.isArray(easing)) {\n    return bezier_easing__WEBPACK_IMPORTED_MODULE_0___default()(easing[0], easing[1], easing[2], easing[3]);\n  }\n\n  if (typeof easing === 'string' && typeof easingPresets[easing] !== 'undefined') {\n    var params = easingPresets[easing];\n    return bezier_easing__WEBPACK_IMPORTED_MODULE_0___default()(params[0], params[1], params[2], params[3]);\n  }\n\n  return;\n}\n\nvar PARALLAX_EFFECTS = /*#__PURE__*/Object.values(ValidCSSEffects);\nvar MAP_EFFECT_TO_DEFAULT_UNIT = {\n  speed: 'px',\n  translateX: '%',\n  translateY: '%',\n  rotate: 'deg',\n  rotateX: 'deg',\n  rotateY: 'deg',\n  rotateZ: 'deg',\n  scale: '',\n  scaleX: '',\n  scaleY: '',\n  scaleZ: '',\n  opacity: ''\n};\n/**\r\n * Takes a parallax element effects and parses the properties to get the start and end values and units.\r\n */\n\nfunction parseElementTransitionEffects(props, scrollAxis) {\n  var parsedEffects = {};\n  PARALLAX_EFFECTS.forEach(function (key) {\n    var defaultValue = MAP_EFFECT_TO_DEFAULT_UNIT[key]; // If the provided type is a number, this must be the speed prop\n    // in which case we need to construct the proper translate config\n\n    if (typeof (props == null ? void 0 : props[key]) === 'number') {\n      var value = props == null ? void 0 : props[key];\n      var startSpeed = (value || 0) * 10 + \"px\";\n      var endSpeed = (value || 0) * -10 + \"px\";\n      var startParsed = parseValueAndUnit(startSpeed);\n      var endParsed = parseValueAndUnit(endSpeed);\n      var speedConfig = {\n        start: startParsed.value,\n        end: endParsed.value,\n        unit: startParsed.unit\n      }; // Manually set translate y value\n\n      if (scrollAxis === ScrollAxis.vertical) {\n        parsedEffects.translateY = speedConfig;\n      } // Manually set translate y value\n\n\n      if (scrollAxis === ScrollAxis.horizontal) {\n        parsedEffects.translateX = speedConfig;\n      }\n    } // The rest are standard effect being parsed\n\n\n    if (Array.isArray(props == null ? void 0 : props[key])) {\n      var _value = props == null ? void 0 : props[key];\n\n      if (typeof _value[0] !== 'undefined' && typeof _value[1] !== 'undefined') {\n        var _startParsed = parseValueAndUnit(_value == null ? void 0 : _value[0], defaultValue);\n\n        var _endParsed = parseValueAndUnit(_value == null ? void 0 : _value[1], defaultValue);\n\n        var easing = createEasingFunction(_value == null ? void 0 : _value[2]);\n        parsedEffects[key] = {\n          start: _startParsed.value,\n          end: _endParsed.value,\n          unit: _startParsed.unit,\n          easing: easing\n        };\n\n        if (_startParsed.unit !== _endParsed.unit) {\n          throw new Error('Must provide matching units for the min and max offset values of each axis.');\n        }\n      }\n    }\n  });\n  return parsedEffects;\n}\n\n/**\r\n * Returns the percent (0 - 100) moved based on position in the viewport\r\n */\nfunction getProgressAmount(\n/*\r\n * The start value from cache\r\n */\nstart,\n/*\r\n * total dist the element has to move to be 100% complete (view width/height + element width/height)\r\n */\ntotalDist,\n/*\r\n * Current scroll value\r\n */\ncurrentScroll,\n/*\r\n * an optional easing function to apply\r\n */\neasing) {\n  // adjust cached value\n  var startAdjustedScroll = currentScroll - start; // Amount the element has moved based on current and total distance to move\n\n  var amount = startAdjustedScroll / totalDist; // Apply bezier easing if provided\n\n  if (easing) {\n    amount = easing(amount);\n  }\n\n  return amount;\n}\n\n/**\r\n * Takes two values (start, end) and returns whether the current scroll is within range\r\n * @param {number} start - start of scroll (x/y)\r\n * @param {number} end - end of scroll (x/y)\r\n * @param {number} scroll - current scroll (x/y)\r\n * @return {boolean} isInView\r\n */\nfunction isElementInView(start, end, scroll) {\n  var isInView = scroll >= start && scroll <= end;\n  return isInView;\n}\n\n// Scale between AKA normalize\nfunction scaleBetween(value, newMin, newMax, oldMin, oldMax) {\n  return (newMax - newMin) * (value - oldMin) / (oldMax - oldMin) + newMin;\n}\n\n/**\r\n * Scales a start and end value of an effect based on percent moved and easing function\r\n */\n\nfunction scaleEffectByProgress(effect, progress) {\n  var value = scaleBetween(typeof effect.easing === 'function' ? effect.easing(progress) : progress, (effect == null ? void 0 : effect.start) || 0, (effect == null ? void 0 : effect.end) || 0, 0, 1);\n  return {\n    value: value,\n    unit: effect == null ? void 0 : effect.unit\n  };\n}\n\nvar TRANSFORM_EFFECTS = /*#__PURE__*/Object.values(ValidCSSEffects).filter(function (v) {\n  return v !== 'opacity';\n});\nfunction setWillChangeStyles(el, effects) {\n  var keys = Object.keys(effects);\n  var hasOpacity = keys.includes('opacity');\n  var willChange = \"transform\" + (hasOpacity ? ',opacity' : '');\n  el.style.willChange = willChange;\n}\nfunction setElementStyles(effects, progress, el) {\n  if (!el) return;\n  var transform = getTransformStyles(effects, progress);\n  var opacity = getOpacityStyles(effects, progress);\n  el.style.transform = transform;\n  el.style.opacity = opacity;\n}\nfunction getOpacityStyles(effects, progress) {\n  var scaledOpacity = effects['opacity'] && scaleEffectByProgress(effects['opacity'], progress);\n\n  if (typeof scaledOpacity === 'undefined' || typeof scaledOpacity.value === 'undefined' || typeof scaledOpacity.unit === 'undefined') {\n    return '';\n  }\n\n  var styleStr = \"\" + scaledOpacity.value;\n  return styleStr;\n}\nfunction getTransformStyles(effects, progress) {\n  var transform = TRANSFORM_EFFECTS.reduce(function (acc, key) {\n    var scaledEffect = // @ts-expect-error\n    effects[key] && scaleEffectByProgress(effects[key], progress);\n\n    if (typeof scaledEffect === 'undefined' || typeof scaledEffect.value === 'undefined' || typeof scaledEffect.unit === 'undefined') {\n      return acc;\n    }\n\n    var styleStr = key + \"(\" + scaledEffect.value + scaledEffect.unit + \")\";\n    return acc + styleStr;\n  }, '');\n  return transform;\n}\n/**\r\n * Takes a parallax element and removes parallax offset styles.\r\n * @param {object} element\r\n */\n\nfunction resetStyles(element) {\n  var el = element.el;\n  if (!el) return;\n  el.style.transform = '';\n  el.style.opacity = '';\n}\n\nfunction createLimitsForRelativeElements(rect, view, scroll, shouldAlwaysCompleteAnimation) {\n  var startY = rect.top - view.height;\n  var startX = rect.left - view.width;\n  var endY = rect.bottom;\n  var endX = rect.right; // add scroll\n\n  startX += scroll.x;\n  endX += scroll.x;\n  startY += scroll.y;\n  endY += scroll.y;\n\n  if (shouldAlwaysCompleteAnimation) {\n    if (scroll.y + rect.top < view.height) {\n      startY = 0;\n    }\n\n    if (scroll.x + rect.left < view.width) {\n      startX = 0;\n    }\n\n    if (endY > view.scrollHeight - view.height) {\n      endY = view.scrollHeight - view.height;\n    }\n\n    if (endX > view.scrollWidth - view.width) {\n      endX = view.scrollWidth - view.width;\n    }\n  }\n\n  var limits = new Limits({\n    startX: startX,\n    startY: startY,\n    endX: endX,\n    endY: endY\n  });\n  return limits;\n}\n\nfunction getTranslateScalar(startTranslatePx, endTranslatePx, totalDist) {\n  var slow = endTranslatePx > startTranslatePx; // calculating necessary scale to increase translations\n\n  var totalAbsOff = (Math.abs(startTranslatePx) + Math.abs(endTranslatePx)) * (slow ? -1 : 1);\n  var totalDistTrue = totalDist + totalAbsOff; // Determine multiple to scale by, only values greater than 1\n\n  var scale = Math.max(totalDist / totalDistTrue, 1);\n  return scale;\n}\n\n/**\r\n * Return the start and end pixel values for an elements translations\r\n */\nfunction getStartEndValueInPx(translate, elementSize) {\n  var start = translate.start,\n      end = translate.end,\n      unit = translate.unit;\n\n  if (unit === '%') {\n    var scale = elementSize / 100;\n    start = start * scale;\n    end = end * scale;\n  }\n\n  if (unit === 'vw') {\n    var startScale = start / 100;\n    var endScale = end / 100;\n    start = window.innerWidth * startScale;\n    end = window.innerWidth * endScale;\n  }\n\n  if (unit === 'vh') {\n    var _startScale = start / 100;\n\n    var _endScale = end / 100;\n\n    start = window.innerHeight * _startScale;\n    end = window.innerHeight * _endScale;\n  }\n\n  return {\n    start: start,\n    end: end\n  };\n}\n\nvar DEFAULT_VALUE = {\n  start: 0,\n  end: 0,\n  unit: ''\n};\nfunction createLimitsWithTranslationsForRelativeElements(rect, view, effects, scroll, scrollAxis, shouldAlwaysCompleteAnimation) {\n  // get start and end accounting for percent effects\n  var translateX = effects.translateX || DEFAULT_VALUE;\n  var translateY = effects.translateY || DEFAULT_VALUE;\n\n  var _getStartEndValueInPx = getStartEndValueInPx(translateX, rect.width),\n      startTranslateXPx = _getStartEndValueInPx.start,\n      endTranslateXPx = _getStartEndValueInPx.end;\n\n  var _getStartEndValueInPx2 = getStartEndValueInPx(translateY, rect.height),\n      startTranslateYPx = _getStartEndValueInPx2.start,\n      endTranslateYPx = _getStartEndValueInPx2.end; // default starting values\n\n\n  var startY = rect.top - view.height;\n  var startX = rect.left - view.width;\n  var endY = rect.bottom;\n  var endX = rect.right;\n  var startMultiplierY = 1;\n  var endMultiplierY = 1;\n\n  if (scrollAxis === ScrollAxis.vertical) {\n    startMultiplierY = getTranslateScalar(startTranslateYPx, endTranslateYPx, view.height + rect.height);\n    endMultiplierY = startMultiplierY;\n  }\n\n  var startMultiplierX = 1;\n  var endMultiplierX = 1;\n\n  if (scrollAxis === ScrollAxis.horizontal) {\n    startMultiplierX = getTranslateScalar(startTranslateXPx, endTranslateXPx, view.width + rect.width);\n    endMultiplierX = startMultiplierX;\n  } // Apply the scale to initial values\n\n\n  if (startTranslateYPx < 0) {\n    startY = startY + startTranslateYPx * startMultiplierY;\n  }\n\n  if (endTranslateYPx > 0) {\n    endY = endY + endTranslateYPx * endMultiplierY;\n  }\n\n  if (startTranslateXPx < 0) {\n    startX = startX + startTranslateXPx * startMultiplierX;\n  }\n\n  if (endTranslateXPx > 0) {\n    endX = endX + endTranslateXPx * endMultiplierX;\n  } // add scroll\n\n\n  startX += scroll.x;\n  endX += scroll.x;\n  startY += scroll.y;\n  endY += scroll.y; // NOTE: please refactor and isolate this :(\n\n  if (shouldAlwaysCompleteAnimation) {\n    var topBeginsInView = scroll.y + rect.top < view.height;\n    var leftBeginsInView = scroll.x + rect.left < view.width;\n    var bottomEndsInView = scroll.y + rect.bottom > view.scrollHeight - view.height;\n    var rightEndsInView = scroll.x + rect.right > view.scrollWidth - view.height;\n\n    if (topBeginsInView && bottomEndsInView) {\n      startMultiplierY = 1;\n      endMultiplierY = 1;\n      startY = 0;\n      endY = view.scrollHeight - view.height;\n    }\n\n    if (leftBeginsInView && rightEndsInView) {\n      startMultiplierX = 1;\n      endMultiplierX = 1;\n      startX = 0;\n      endX = view.scrollWidth - view.width;\n    }\n\n    if (!topBeginsInView && bottomEndsInView) {\n      startY = rect.top - view.height + scroll.y;\n      endY = view.scrollHeight - view.height;\n      var totalDist = endY - startY;\n      startMultiplierY = getTranslateScalar(startTranslateYPx, endTranslateYPx, totalDist);\n      endMultiplierY = 1;\n\n      if (startTranslateYPx < 0) {\n        startY = startY + startTranslateYPx * startMultiplierY;\n      }\n    }\n\n    if (!leftBeginsInView && rightEndsInView) {\n      startX = rect.left - view.width + scroll.x;\n      endX = view.scrollWidth - view.width;\n\n      var _totalDist = endX - startX;\n\n      startMultiplierX = getTranslateScalar(startTranslateXPx, endTranslateXPx, _totalDist);\n      endMultiplierX = 1;\n\n      if (startTranslateXPx < 0) {\n        startX = startX + startTranslateXPx * startMultiplierX;\n      }\n    }\n\n    if (topBeginsInView && !bottomEndsInView) {\n      startY = 0;\n      endY = rect.bottom + scroll.y;\n\n      var _totalDist2 = endY - startY;\n\n      startMultiplierY = 1;\n      endMultiplierY = getTranslateScalar(startTranslateYPx, endTranslateYPx, _totalDist2);\n\n      if (endTranslateYPx > 0) {\n        endY = endY + endTranslateYPx * endMultiplierY;\n      }\n    }\n\n    if (leftBeginsInView && !rightEndsInView) {\n      startX = 0;\n      endX = rect.right + scroll.x;\n\n      var _totalDist3 = endX - startX;\n\n      startMultiplierX = 1;\n      endMultiplierX = getTranslateScalar(startTranslateXPx, endTranslateXPx, _totalDist3);\n\n      if (endTranslateXPx > 0) {\n        endX = endX + endTranslateXPx * endMultiplierX;\n      }\n    }\n  }\n\n  var limits = new Limits({\n    startX: startX,\n    startY: startY,\n    endX: endX,\n    endY: endY,\n    startMultiplierX: startMultiplierX,\n    endMultiplierX: endMultiplierX,\n    startMultiplierY: startMultiplierY,\n    endMultiplierY: endMultiplierY\n  });\n  return limits;\n}\n\nfunction scaleTranslateEffectsForSlowerScroll(effects, limits) {\n  var effectsCopy = _extends({}, effects);\n\n  if (effectsCopy.translateX) {\n    effectsCopy.translateX = _extends({}, effects.translateX, {\n      start: effectsCopy.translateX.start * limits.startMultiplierX,\n      end: effectsCopy.translateX.end * limits.endMultiplierX\n    });\n  }\n\n  if (effectsCopy.translateY) {\n    effectsCopy.translateY = _extends({}, effects.translateY, {\n      start: effectsCopy.translateY.start * limits.startMultiplierY,\n      end: effectsCopy.translateY.end * limits.endMultiplierY\n    });\n  }\n\n  return effectsCopy;\n}\n\nfunction getShouldScaleTranslateEffects(props, effects, scrollAxis) {\n  if (props.rootMargin || props.targetElement || props.shouldDisableScalingTranslations) {\n    return false;\n  }\n\n  if (!!effects.translateX && scrollAxis === ScrollAxis.horizontal || !!effects.translateY && scrollAxis === ScrollAxis.vertical) {\n    return true;\n  }\n\n  return false;\n}\n\nvar clamp = function clamp(num, min, max) {\n  return Math.min(Math.max(num, min), max);\n};\n\nvar Element = /*#__PURE__*/function () {\n  function Element(options) {\n    this.el = options.el;\n    this.props = options.props;\n    this.scrollAxis = options.scrollAxis;\n    this.disabledParallaxController = options.disabledParallaxController || false;\n    this.id = createId();\n    this.effects = parseElementTransitionEffects(this.props, this.scrollAxis);\n    this.isInView = null;\n    this.progress = 0;\n\n    this._setElementEasing(options.props.easing);\n\n    setWillChangeStyles(options.el, this.effects);\n  }\n\n  var _proto = Element.prototype;\n\n  _proto.updateProps = function updateProps(nextProps) {\n    this.props = _extends({}, this.props, nextProps);\n    this.effects = parseElementTransitionEffects(nextProps, this.scrollAxis);\n\n    this._setElementEasing(nextProps.easing);\n\n    return this;\n  };\n\n  _proto.setCachedAttributes = function setCachedAttributes(view, scroll) {\n    // NOTE: Must reset styles before getting the rect, as it might impact the natural position\n    resetStyles(this);\n    this.rect = new Rect({\n      el: this.props.targetElement || this.el,\n      rootMargin: this.props.rootMargin,\n      view: view\n    });\n    var shouldScaleTranslateEffects = getShouldScaleTranslateEffects(this.props, this.effects, this.scrollAxis);\n\n    if (typeof this.props.startScroll === 'number' && typeof this.props.endScroll === 'number') {\n      this.limits = new Limits({\n        startX: this.props.startScroll,\n        startY: this.props.startScroll,\n        endX: this.props.endScroll,\n        endY: this.props.endScroll\n      }); // Undo the reset -- place it back at current position with styles\n\n      this._setElementStyles();\n\n      return this;\n    }\n\n    if (shouldScaleTranslateEffects) {\n      this.limits = createLimitsWithTranslationsForRelativeElements(this.rect, view, this.effects, scroll, this.scrollAxis, this.props.shouldAlwaysCompleteAnimation);\n      this.scaledEffects = scaleTranslateEffectsForSlowerScroll(this.effects, this.limits);\n    } else {\n      this.limits = createLimitsForRelativeElements(this.rect, view, scroll, this.props.shouldAlwaysCompleteAnimation);\n    } // Undo the reset -- place it back at current position with styles\n\n\n    this._setElementStyles();\n\n    return this;\n  };\n\n  _proto._updateElementIsInView = function _updateElementIsInView(nextIsInView) {\n    // NOTE: Check if this is the first change to make sure onExit isn't called\n    var isFirstChange = this.isInView === null;\n\n    if (nextIsInView !== this.isInView) {\n      if (nextIsInView) {\n        this.props.onEnter && this.props.onEnter(this);\n      } else if (!isFirstChange) {\n        this._setFinalProgress();\n\n        this._setElementStyles();\n\n        this.props.onExit && this.props.onExit(this);\n      }\n    }\n\n    this.isInView = nextIsInView;\n  };\n\n  _proto._setFinalProgress = function _setFinalProgress() {\n    var finalProgress = clamp(Math.round(this.progress), 0, 1);\n\n    this._updateElementProgress(finalProgress);\n  };\n\n  _proto._setElementStyles = function _setElementStyles() {\n    if (this.props.disabled || this.disabledParallaxController) return;\n    var effects = this.scaledEffects || this.effects;\n    setElementStyles(effects, this.progress, this.el);\n  };\n\n  _proto._updateElementProgress = function _updateElementProgress(nextProgress) {\n    this.progress = nextProgress;\n    this.props.onProgressChange && this.props.onProgressChange(this.progress);\n    this.props.onChange && this.props.onChange(this);\n  };\n\n  _proto._setElementEasing = function _setElementEasing(easing) {\n    this.easing = createEasingFunction(easing);\n  };\n\n  _proto.updateElementOptions = function updateElementOptions(options) {\n    this.scrollAxis = options.scrollAxis;\n    this.disabledParallaxController = options.disabledParallaxController || false;\n  };\n\n  _proto.updatePosition = function updatePosition(scroll) {\n    if (!this.limits) return this;\n    var isVertical = this.scrollAxis === ScrollAxis.vertical;\n    var isFirstChange = this.isInView === null; // based on scroll axis\n\n    var start = isVertical ? this.limits.startY : this.limits.startX;\n    var end = isVertical ? this.limits.endY : this.limits.endX;\n    var total = isVertical ? this.limits.totalY : this.limits.totalX;\n    var s = isVertical ? scroll.y : scroll.x; // check if in view\n\n    var nextIsInView = isElementInView(start, end, s);\n\n    this._updateElementIsInView(nextIsInView); // set the progress if in view or this is the first change\n\n\n    if (nextIsInView) {\n      var nextProgress = getProgressAmount(start, total, s, this.easing);\n\n      this._updateElementProgress(nextProgress);\n\n      this._setElementStyles();\n    } else if (isFirstChange) {\n      // NOTE: this._updateElementProgress -- dont use this because it will trigger onChange\n      this.progress = clamp(Math.round(getProgressAmount(start, total, s, this.easing)), 0, 1);\n\n      this._setElementStyles();\n    }\n\n    return this;\n  };\n\n  return Element;\n}();\n\nvar View = /*#__PURE__*/function () {\n  function View(config) {\n    this.scrollContainer = config.scrollContainer;\n    this.width = config.width;\n    this.height = config.height;\n    this.scrollHeight = config.scrollHeight;\n    this.scrollWidth = config.scrollWidth;\n  }\n\n  var _proto = View.prototype;\n\n  _proto.hasChanged = function hasChanged(params) {\n    if (params.width !== this.width || params.height !== this.height || params.scrollWidth !== this.scrollWidth || params.scrollHeight !== this.scrollHeight) {\n      return true;\n    }\n\n    return false;\n  };\n\n  _proto.setSize = function setSize(params) {\n    this.width = params.width;\n    this.height = params.height;\n    this.scrollHeight = params.scrollHeight;\n    this.scrollWidth = params.scrollWidth;\n    return this;\n  };\n\n  return View;\n}();\n\nvar Scroll = /*#__PURE__*/function () {\n  function Scroll(x, y) {\n    this.x = x;\n    this.y = y;\n    this.dx = 0;\n    this.dy = 0;\n  }\n\n  var _proto = Scroll.prototype;\n\n  _proto.setScroll = function setScroll(x, y) {\n    this.dx = x - this.x;\n    this.dy = y - this.y;\n    this.x = x;\n    this.y = y;\n    return this;\n  };\n\n  return Scroll;\n}();\n\nfunction testForPassiveScroll() {\n  var supportsPassiveOption = false;\n\n  try {\n    var opts = Object.defineProperty({}, 'passive', {\n      get: function get() {\n        supportsPassiveOption = true;\n        return true;\n      }\n    }); // @ts-expect-error\n\n    window.addEventListener('test', null, opts); // @ts-expect-error\n\n    window.removeEventListener('test', null, opts);\n  } catch (e) {}\n\n  return supportsPassiveOption;\n}\n\n/**\r\n * -------------------------------------------------------\r\n * Parallax Controller\r\n * -------------------------------------------------------\r\n *\r\n * The global controller for setting up and managing a scroll view of elements.\r\n *\r\n */\n\nvar ParallaxController = /*#__PURE__*/function () {\n  function ParallaxController(_ref) {\n    var _ref$scrollAxis = _ref.scrollAxis,\n        scrollAxis = _ref$scrollAxis === void 0 ? ScrollAxis.vertical : _ref$scrollAxis,\n        scrollContainer = _ref.scrollContainer,\n        _ref$disabled = _ref.disabled,\n        disabled = _ref$disabled === void 0 ? false : _ref$disabled;\n    this.disabled = disabled;\n    this.scrollAxis = scrollAxis; // All parallax elements to be updated\n\n    this.elements = [];\n    this._hasScrollContainer = !!scrollContainer;\n    this.viewEl = scrollContainer != null ? scrollContainer : window; // Scroll and View\n\n    var _this$_getScrollPosit = this._getScrollPosition(),\n        x = _this$_getScrollPosit[0],\n        y = _this$_getScrollPosit[1];\n\n    this.scroll = new Scroll(x, y);\n    this.view = new View({\n      width: 0,\n      height: 0,\n      scrollWidth: 0,\n      scrollHeight: 0,\n      scrollContainer: this._hasScrollContainer ? scrollContainer : undefined\n    }); // Ticking\n\n    this._ticking = false; // Passive support\n\n    this._supportsPassive = testForPassiveScroll(); // Bind methods to class\n\n    this._bindAllMethods(); // If this is initialized disabled, don't do anything below.\n\n\n    if (this.disabled) return;\n\n    this._addListeners(this.viewEl);\n\n    this._addResizeObserver();\n\n    this._setViewSize();\n  }\n  /**\r\n   * Static method to instantiate the ParallaxController.\r\n   * @returns {Class} ParallaxController\r\n   */\n\n\n  ParallaxController.init = function init(options) {\n    var hasWindow = typeof window !== 'undefined';\n\n    if (!hasWindow) {\n      throw new Error('Looks like ParallaxController.init() was called on the server. This method must be called on the client.');\n    }\n\n    return new ParallaxController(options);\n  };\n\n  var _proto = ParallaxController.prototype;\n\n  _proto._bindAllMethods = function _bindAllMethods() {\n    var _this = this;\n\n    ['_addListeners', '_removeListeners', '_getScrollPosition', '_handleScroll', '_handleUpdateCache', '_updateAllElements', '_updateElementPosition', '_setViewSize', '_addResizeObserver', '_checkIfViewHasChanged', '_getViewParams', 'getElements', 'createElement', 'removeElementById', 'resetElementStyles', 'updateElementPropsById', 'update', 'updateScrollContainer', 'destroy'].forEach(function (method) {\n      // @ts-expect-error\n      _this[method] = _this[method].bind(_this);\n    });\n  };\n\n  _proto._addListeners = function _addListeners(el) {\n    el.addEventListener('scroll', this._handleScroll, this._supportsPassive ? {\n      passive: true\n    } : false);\n    window.addEventListener('resize', this._handleUpdateCache, false);\n    window.addEventListener('blur', this._handleUpdateCache, false);\n    window.addEventListener('focus', this._handleUpdateCache, false);\n    window.addEventListener('load', this._handleUpdateCache, false);\n  };\n\n  _proto._removeListeners = function _removeListeners(el) {\n    var _this$_resizeObserver;\n\n    el.removeEventListener('scroll', this._handleScroll, false);\n    window.removeEventListener('resize', this._handleUpdateCache, false);\n    window.removeEventListener('blur', this._handleUpdateCache, false);\n    window.removeEventListener('focus', this._handleUpdateCache, false);\n    window.removeEventListener('load', this._handleUpdateCache, false);\n    (_this$_resizeObserver = this._resizeObserver) == null ? void 0 : _this$_resizeObserver.disconnect();\n  };\n\n  _proto._addResizeObserver = function _addResizeObserver() {\n    var _this2 = this;\n\n    try {\n      var observedEl = this._hasScrollContainer ? this.viewEl : document.documentElement;\n      this._resizeObserver = new ResizeObserver(function () {\n        return _this2.update();\n      });\n\n      this._resizeObserver.observe(observedEl);\n    } catch (e) {\n      console.warn('Failed to create the resize observer in the ParallaxContoller');\n    }\n  };\n\n  _proto._getScrollPosition = function _getScrollPosition() {\n    // Save current scroll\n    // Supports IE 9 and up.\n    var nx = this._hasScrollContainer ? // @ts-expect-error\n    this.viewEl.scrollLeft : window.pageXOffset;\n    var ny = this._hasScrollContainer ? // @ts-expect-error\n    this.viewEl.scrollTop : window.pageYOffset;\n    return [nx, ny];\n  }\n  /**\r\n   * Window scroll handler sets scroll position\r\n   * and then calls '_updateAllElements()'.\r\n   */\n  ;\n\n  _proto._handleScroll = function _handleScroll() {\n    var _this$elements;\n\n    var _this$_getScrollPosit2 = this._getScrollPosition(),\n        nx = _this$_getScrollPosit2[0],\n        ny = _this$_getScrollPosit2[1];\n\n    this.scroll.setScroll(nx, ny); // Only called if the last animation request has been\n    // completed and there are parallax elements to update\n\n    if (!this._ticking && ((_this$elements = this.elements) == null ? void 0 : _this$elements.length) > 0) {\n      this._ticking = true; // @ts-ignore\n\n      window.requestAnimationFrame(this._updateAllElements);\n    }\n  }\n  /**\r\n   * Window resize handler. Sets the new window inner height\r\n   * then updates parallax element attributes and positions.\r\n   */\n  ;\n\n  _proto._handleUpdateCache = function _handleUpdateCache() {\n    this._setViewSize();\n\n    this._updateAllElements({\n      updateCache: true\n    });\n  }\n  /**\r\n   * Update element positions.\r\n   * Determines if the element is in view based on the cached\r\n   * attributes, if so set the elements parallax styles.\r\n   */\n  ;\n\n  _proto._updateAllElements = function _updateAllElements(_temp) {\n    var _this3 = this;\n\n    var _ref2 = _temp === void 0 ? {} : _temp,\n        updateCache = _ref2.updateCache;\n\n    if (this.elements) {\n      this.elements.forEach(function (element) {\n        if (updateCache) {\n          element.setCachedAttributes(_this3.view, _this3.scroll);\n        }\n\n        _this3._updateElementPosition(element);\n      });\n    } // reset ticking so more animations can be called\n\n\n    this._ticking = false;\n  }\n  /**\r\n   * Update element positions.\r\n   * Determines if the element is in view based on the cached\r\n   * attributes, if so set the elements parallax styles.\r\n   */\n  ;\n\n  _proto._updateElementPosition = function _updateElementPosition(element) {\n    if (element.props.disabled || this.disabled) return;\n    element.updatePosition(this.scroll);\n  }\n  /**\r\n   * Gets the params to set in the View from the scroll container or the window\r\n   */\n  ;\n\n  _proto._getViewParams = function _getViewParams() {\n    if (this._hasScrollContainer) {\n      // @ts-expect-error\n      var _width = this.viewEl.offsetWidth; // @ts-expect-error\n\n      var _height = this.viewEl.offsetHeight; // @ts-expect-error\n\n      var _scrollHeight = this.viewEl.scrollHeight; // @ts-expect-error\n\n      var _scrollWidth = this.viewEl.scrollWidth;\n      return this.view.setSize({\n        width: _width,\n        height: _height,\n        scrollHeight: _scrollHeight,\n        scrollWidth: _scrollWidth\n      });\n    }\n\n    var html = document.documentElement;\n    var width = window.innerWidth || html.clientWidth;\n    var height = window.innerHeight || html.clientHeight;\n    var scrollHeight = html.scrollHeight;\n    var scrollWidth = html.scrollWidth;\n    return {\n      width: width,\n      height: height,\n      scrollHeight: scrollHeight,\n      scrollWidth: scrollWidth\n    };\n  }\n  /**\r\n   * Cache the view attributes\r\n   */\n  ;\n\n  _proto._setViewSize = function _setViewSize() {\n    return this.view.setSize(this._getViewParams());\n  }\n  /**\r\n   * Checks if any of the cached attributes of the view have changed.\r\n   * @returns boolean\r\n   */\n  ;\n\n  _proto._checkIfViewHasChanged = function _checkIfViewHasChanged() {\n    return this.view.hasChanged(this._getViewParams());\n  }\n  /**\r\n   * -------------------------------------------------------\r\n   * Public methods\r\n   * -------------------------------------------------------\r\n   */\n\n  /**\r\n   * Returns all the parallax elements in the controller\r\n   */\n  ;\n\n  _proto.getElements = function getElements() {\n    return this.elements;\n  }\n  /**\r\n   * Creates and returns new parallax element with provided options to be managed by the controller.\r\n   */\n  ;\n\n  _proto.createElement = function createElement(options) {\n    var newElement = new Element(_extends({}, options, {\n      scrollAxis: this.scrollAxis,\n      disabledParallaxController: this.disabled\n    }));\n    newElement.setCachedAttributes(this.view, this.scroll);\n    this.elements = this.elements ? [].concat(this.elements, [newElement]) : [newElement];\n\n    this._updateElementPosition(newElement); // NOTE: This checks if the view has changed then update the controller and all elements if it has\n    // This shouldn't always be necessary with a resize observer watching the view element\n    // but there seems to be cases where the resize observer does not catch and update.\n\n\n    if (this._checkIfViewHasChanged()) {\n      this.update();\n    }\n\n    return newElement;\n  }\n  /**\r\n   * Remove an element by id\r\n   */\n  ;\n\n  _proto.removeElementById = function removeElementById(id) {\n    if (!this.elements) return;\n    this.elements = this.elements.filter(function (el) {\n      return el.id !== id;\n    });\n  }\n  /**\r\n   * Updates an existing parallax element object with new options.\r\n   */\n  ;\n\n  _proto.updateElementPropsById = function updateElementPropsById(id, props) {\n    if (this.elements) {\n      this.elements = this.elements.map(function (el) {\n        if (el.id === id) {\n          return el.updateProps(props);\n        }\n\n        return el;\n      });\n    }\n\n    this.update();\n  }\n  /**\r\n   * Remove a target elements parallax styles\r\n   */\n  ;\n\n  _proto.resetElementStyles = function resetElementStyles(element) {\n    resetStyles(element);\n  }\n  /**\r\n   * Updates all cached attributes on parallax elements.\r\n   */\n  ;\n\n  _proto.update = function update() {\n    // Save the latest scroll position because window.scroll\n    // may be called and the handle scroll event may not be called.\n    var _this$_getScrollPosit3 = this._getScrollPosition(),\n        nx = _this$_getScrollPosit3[0],\n        ny = _this$_getScrollPosit3[1];\n\n    this.scroll.setScroll(nx, ny);\n\n    this._setViewSize();\n\n    this._updateAllElements({\n      updateCache: true\n    });\n  }\n  /**\r\n   * Updates the scroll container of the parallax controller\r\n   */\n  ;\n\n  _proto.updateScrollContainer = function updateScrollContainer(el) {\n    // remove existing listeners with current el first\n    this._removeListeners(this.viewEl);\n\n    this.viewEl = el;\n    this._hasScrollContainer = !!el;\n    this.view = new View({\n      width: 0,\n      height: 0,\n      scrollWidth: 0,\n      scrollHeight: 0,\n      scrollContainer: el\n    });\n\n    this._setViewSize();\n\n    this._addListeners(this.viewEl);\n\n    this._updateAllElements({\n      updateCache: true\n    });\n  };\n\n  _proto.disableParallaxController = function disableParallaxController() {\n    this.disabled = true; // remove listeners\n\n    this._removeListeners(this.viewEl); // reset all styles\n\n\n    if (this.elements) {\n      this.elements.forEach(function (element) {\n        return resetStyles(element);\n      });\n    }\n  };\n\n  _proto.enableParallaxController = function enableParallaxController() {\n    var _this4 = this;\n\n    this.disabled = false;\n\n    if (this.elements) {\n      this.elements.forEach(function (element) {\n        return element.updateElementOptions({\n          disabledParallaxController: false,\n          scrollAxis: _this4.scrollAxis\n        });\n      });\n    } // add back listeners\n\n\n    this._addListeners(this.viewEl);\n\n    this._addResizeObserver();\n\n    this._setViewSize();\n  }\n  /**\r\n   * Disable all parallax elements\r\n   */\n  ;\n\n  _proto.disableAllElements = function disableAllElements() {\n    console.warn('deprecated: use disableParallaxController() instead');\n\n    if (this.elements) {\n      this.elements = this.elements.map(function (el) {\n        return el.updateProps({\n          disabled: true\n        });\n      });\n    }\n\n    this.update();\n  }\n  /**\r\n   * Enable all parallax elements\r\n   */\n  ;\n\n  _proto.enableAllElements = function enableAllElements() {\n    console.warn('deprecated: use enableParallaxController() instead');\n\n    if (this.elements) {\n      this.elements = this.elements.map(function (el) {\n        return el.updateProps({\n          disabled: false\n        });\n      });\n    }\n\n    this.update();\n  }\n  /**\r\n   * Removes all listeners and resets all styles on managed elements.\r\n   */\n  ;\n\n  _proto.destroy = function destroy() {\n    this._removeListeners(this.viewEl);\n\n    if (this.elements) {\n      this.elements.forEach(function (element) {\n        return resetStyles(element);\n      });\n    } // @ts-expect-error\n\n\n    this.elements = undefined;\n  };\n\n  return ParallaxController;\n}();\n\n\n//# sourceMappingURL=parallax-controller.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wYXJhbGxheC1jb250cm9sbGVyL2Rpc3QvcGFyYWxsYXgtY29udHJvbGxlci5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW1DOztBQUVuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjs7QUFFL0I7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQixzQkFBc0I7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsMENBQTBDOztBQUUzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQkFBc0I7O0FBRXZCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7O0FBRXZDOztBQUVBO0FBQ0E7QUFDQSxDQUFDLGdDQUFnQzs7QUFFakM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7O0FBRWpDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbURBQW1EOztBQUVuRDtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0I7O0FBRS9CLDhEQUE4RDs7QUFFOUQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLG9EQUFNO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQSxXQUFXLG9EQUFNO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1EOztBQUVuRCxnREFBZ0Q7O0FBRWhEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25COztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSxnREFBZ0Q7O0FBRWhEO0FBQ0EsK0NBQStDOztBQUUvQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvREFBb0Q7OztBQUdwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0Esb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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T0FBTztBQUNQLE1BQU07OztBQUdOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7O0FBRTVDLDhDQUE4Qzs7QUFFOUMsb0RBQW9EOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSw2Q0FBNkM7QUFDN0M7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLDBCQUEwQjs7QUFFMUIsd0NBQXdDOzs7QUFHeEM7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUCxNQUFNOzs7QUFHTjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNOzs7QUFHTjtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFeVU7QUFDMVUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tdmVudHVyYS9Eb2N1bWVudHMvR2l0SHViL21vcnBoZS9ub2RlX21vZHVsZXMvcGFyYWxsYXgtY29udHJvbGxlci9kaXN0L3BhcmFsbGF4LWNvbnRyb2xsZXIuZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBiZXppZXIgZnJvbSAnYmV6aWVyLWVhc2luZyc7XG5cbnZhciBMaW1pdHMgPSBmdW5jdGlvbiBMaW1pdHMocHJvcGVydGllcykge1xuICB0aGlzLnN0YXJ0WCA9IHByb3BlcnRpZXMuc3RhcnRYO1xuICB0aGlzLnN0YXJ0WSA9IHByb3BlcnRpZXMuc3RhcnRZO1xuICB0aGlzLmVuZFggPSBwcm9wZXJ0aWVzLmVuZFg7XG4gIHRoaXMuZW5kWSA9IHByb3BlcnRpZXMuZW5kWTsgLy8gVXNlZCB0byBjYWxjdWxhdGUgdGhlIHByb2dyZXNzIG9mIHRoZSBlbGVtZW50XG5cbiAgdGhpcy50b3RhbFggPSB0aGlzLmVuZFggLSB0aGlzLnN0YXJ0WDtcbiAgdGhpcy50b3RhbFkgPSB0aGlzLmVuZFkgLSB0aGlzLnN0YXJ0WTsgLy8gVXNlZCB0byBzY2FsZSB0cmFuc2xhdGUgZWZmZWN0c1xuXG4gIHRoaXMuc3RhcnRNdWx0aXBsaWVyWCA9IHByb3BlcnRpZXMuc3RhcnRNdWx0aXBsaWVyWCB8fCAxO1xuICB0aGlzLmVuZE11bHRpcGxpZXJYID0gcHJvcGVydGllcy5lbmRNdWx0aXBsaWVyWCB8fCAxO1xuICB0aGlzLnN0YXJ0TXVsdGlwbGllclkgPSBwcm9wZXJ0aWVzLnN0YXJ0TXVsdGlwbGllclkgfHwgMTtcbiAgdGhpcy5lbmRNdWx0aXBsaWVyWSA9IHByb3BlcnRpZXMuZW5kTXVsdGlwbGllclkgfHwgMTtcbn07XG5cbmZ1bmN0aW9uIF9leHRlbmRzKCkge1xuICBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXQ7XG4gIH07XG5cbiAgcmV0dXJuIF9leHRlbmRzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cbnZhciBWYWxpZENTU0VmZmVjdHM7XG5cbihmdW5jdGlvbiAoVmFsaWRDU1NFZmZlY3RzKSB7XG4gIFZhbGlkQ1NTRWZmZWN0c1tcInNwZWVkXCJdID0gXCJzcGVlZFwiO1xuICBWYWxpZENTU0VmZmVjdHNbXCJ0cmFuc2xhdGVYXCJdID0gXCJ0cmFuc2xhdGVYXCI7XG4gIFZhbGlkQ1NTRWZmZWN0c1tcInRyYW5zbGF0ZVlcIl0gPSBcInRyYW5zbGF0ZVlcIjtcbiAgVmFsaWRDU1NFZmZlY3RzW1wicm90YXRlXCJdID0gXCJyb3RhdGVcIjtcbiAgVmFsaWRDU1NFZmZlY3RzW1wicm90YXRlWFwiXSA9IFwicm90YXRlWFwiO1xuICBWYWxpZENTU0VmZmVjdHNbXCJyb3RhdGVZXCJdID0gXCJyb3RhdGVZXCI7XG4gIFZhbGlkQ1NTRWZmZWN0c1tcInJvdGF0ZVpcIl0gPSBcInJvdGF0ZVpcIjtcbiAgVmFsaWRDU1NFZmZlY3RzW1wic2NhbGVcIl0gPSBcInNjYWxlXCI7XG4gIFZhbGlkQ1NTRWZmZWN0c1tcInNjYWxlWFwiXSA9IFwic2NhbGVYXCI7XG4gIFZhbGlkQ1NTRWZmZWN0c1tcInNjYWxlWVwiXSA9IFwic2NhbGVZXCI7XG4gIFZhbGlkQ1NTRWZmZWN0c1tcInNjYWxlWlwiXSA9IFwic2NhbGVaXCI7XG4gIFZhbGlkQ1NTRWZmZWN0c1tcIm9wYWNpdHlcIl0gPSBcIm9wYWNpdHlcIjtcbn0pKFZhbGlkQ1NTRWZmZWN0cyB8fCAoVmFsaWRDU1NFZmZlY3RzID0ge30pKTtcblxudmFyIFVuaXRzO1xuXG4oZnVuY3Rpb24gKFVuaXRzKSB7XG4gIFVuaXRzW1wicHhcIl0gPSBcInB4XCI7XG4gIFVuaXRzW1wiJVwiXSA9IFwiJVwiO1xuICBVbml0c1tcInZoXCJdID0gXCJ2aFwiO1xuICBVbml0c1tcInZ3XCJdID0gXCJ2d1wiO1xufSkoVW5pdHMgfHwgKFVuaXRzID0ge30pKTtcblxudmFyIFJvdGF0aW9uVW5pdHM7XG5cbihmdW5jdGlvbiAoUm90YXRpb25Vbml0cykge1xuICBSb3RhdGlvblVuaXRzW1wiZGVnXCJdID0gXCJkZWdcIjtcbiAgUm90YXRpb25Vbml0c1tcInR1cm5cIl0gPSBcInR1cm5cIjtcbiAgUm90YXRpb25Vbml0c1tcInJhZFwiXSA9IFwicmFkXCI7XG59KShSb3RhdGlvblVuaXRzIHx8IChSb3RhdGlvblVuaXRzID0ge30pKTtcblxudmFyIFNjYWxlVW5pdHM7XG5cbihmdW5jdGlvbiAoU2NhbGVVbml0cykge1xuICBTY2FsZVVuaXRzW1wiXCJdID0gXCJcIjtcbn0pKFNjYWxlVW5pdHMgfHwgKFNjYWxlVW5pdHMgPSB7fSkpO1xuXG52YXIgU2Nyb2xsQXhpcztcblxuKGZ1bmN0aW9uIChTY3JvbGxBeGlzKSB7XG4gIFNjcm9sbEF4aXNbXCJ2ZXJ0aWNhbFwiXSA9IFwidmVydGljYWxcIjtcbiAgU2Nyb2xsQXhpc1tcImhvcml6b250YWxcIl0gPSBcImhvcml6b250YWxcIjtcbn0pKFNjcm9sbEF4aXMgfHwgKFNjcm9sbEF4aXMgPSB7fSkpO1xuXG52YXIgRWFzaW5nUHJlc2V0O1xuXG4oZnVuY3Rpb24gKEVhc2luZ1ByZXNldCkge1xuICBFYXNpbmdQcmVzZXRbXCJlYXNlXCJdID0gXCJlYXNlXCI7XG4gIEVhc2luZ1ByZXNldFtcImVhc2VJblwiXSA9IFwiZWFzZUluXCI7XG4gIEVhc2luZ1ByZXNldFtcImVhc2VPdXRcIl0gPSBcImVhc2VPdXRcIjtcbiAgRWFzaW5nUHJlc2V0W1wiZWFzZUluT3V0XCJdID0gXCJlYXNlSW5PdXRcIjtcbiAgRWFzaW5nUHJlc2V0W1wiZWFzZUluUXVhZFwiXSA9IFwiZWFzZUluUXVhZFwiO1xuICBFYXNpbmdQcmVzZXRbXCJlYXNlSW5DdWJpY1wiXSA9IFwiZWFzZUluQ3ViaWNcIjtcbiAgRWFzaW5nUHJlc2V0W1wiZWFzZUluUXVhcnRcIl0gPSBcImVhc2VJblF1YXJ0XCI7XG4gIEVhc2luZ1ByZXNldFtcImVhc2VJblF1aW50XCJdID0gXCJlYXNlSW5RdWludFwiO1xuICBFYXNpbmdQcmVzZXRbXCJlYXNlSW5TaW5lXCJdID0gXCJlYXNlSW5TaW5lXCI7XG4gIEVhc2luZ1ByZXNldFtcImVhc2VJbkV4cG9cIl0gPSBcImVhc2VJbkV4cG9cIjtcbiAgRWFzaW5nUHJlc2V0W1wiZWFzZUluQ2lyY1wiXSA9IFwiZWFzZUluQ2lyY1wiO1xuICBFYXNpbmdQcmVzZXRbXCJlYXNlT3V0UXVhZFwiXSA9IFwiZWFzZU91dFF1YWRcIjtcbiAgRWFzaW5nUHJlc2V0W1wiZWFzZU91dEN1YmljXCJdID0gXCJlYXNlT3V0Q3ViaWNcIjtcbiAgRWFzaW5nUHJlc2V0W1wiZWFzZU91dFF1YXJ0XCJdID0gXCJlYXNlT3V0UXVhcnRcIjtcbiAgRWFzaW5nUHJlc2V0W1wiZWFzZU91dFF1aW50XCJdID0gXCJlYXNlT3V0UXVpbnRcIjtcbiAgRWFzaW5nUHJlc2V0W1wiZWFzZU91dFNpbmVcIl0gPSBcImVhc2VPdXRTaW5lXCI7XG4gIEVhc2luZ1ByZXNldFtcImVhc2VPdXRFeHBvXCJdID0gXCJlYXNlT3V0RXhwb1wiO1xuICBFYXNpbmdQcmVzZXRbXCJlYXNlT3V0Q2lyY1wiXSA9IFwiZWFzZU91dENpcmNcIjtcbiAgRWFzaW5nUHJlc2V0W1wiZWFzZUluT3V0UXVhZFwiXSA9IFwiZWFzZUluT3V0UXVhZFwiO1xuICBFYXNpbmdQcmVzZXRbXCJlYXNlSW5PdXRDdWJpY1wiXSA9IFwiZWFzZUluT3V0Q3ViaWNcIjtcbiAgRWFzaW5nUHJlc2V0W1wiZWFzZUluT3V0UXVhcnRcIl0gPSBcImVhc2VJbk91dFF1YXJ0XCI7XG4gIEVhc2luZ1ByZXNldFtcImVhc2VJbk91dFF1aW50XCJdID0gXCJlYXNlSW5PdXRRdWludFwiO1xuICBFYXNpbmdQcmVzZXRbXCJlYXNlSW5PdXRTaW5lXCJdID0gXCJlYXNlSW5PdXRTaW5lXCI7XG4gIEVhc2luZ1ByZXNldFtcImVhc2VJbk91dEV4cG9cIl0gPSBcImVhc2VJbk91dEV4cG9cIjtcbiAgRWFzaW5nUHJlc2V0W1wiZWFzZUluT3V0Q2lyY1wiXSA9IFwiZWFzZUluT3V0Q2lyY1wiO1xuICBFYXNpbmdQcmVzZXRbXCJlYXNlSW5CYWNrXCJdID0gXCJlYXNlSW5CYWNrXCI7XG4gIEVhc2luZ1ByZXNldFtcImVhc2VPdXRCYWNrXCJdID0gXCJlYXNlT3V0QmFja1wiO1xuICBFYXNpbmdQcmVzZXRbXCJlYXNlSW5PdXRCYWNrXCJdID0gXCJlYXNlSW5PdXRCYWNrXCI7XG59KShFYXNpbmdQcmVzZXQgfHwgKEVhc2luZ1ByZXNldCA9IHt9KSk7XG5cbi8qKlxyXG4gKiBDcmVhdGVzIGEgdW5pcXVlIGlkIHRvIGRpc3Rpbmd1aXNoIHBhcmFsbGF4IGVsZW1lbnRzLlxyXG4gKi9cbnZhciBpZCA9IDA7XG5mdW5jdGlvbiBjcmVhdGVJZCgpIHtcbiAgKytpZDtcbiAgcmV0dXJuIGlkO1xufVxuXG52YXIgUmVjdCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFJlY3Qob3B0aW9ucykge1xuICAgIHZhciByZWN0ID0gb3B0aW9ucy5lbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTsgLy8gcmVjdCBpcyBiYXNlZCBvbiB2aWV3cG9ydCAtLSBtdXN0IGFkanVzdCBmb3IgcmVsYXRpdmUgc2Nyb2xsIGNvbnRhaW5lclxuXG4gICAgaWYgKG9wdGlvbnMudmlldy5zY3JvbGxDb250YWluZXIpIHtcbiAgICAgIHZhciBzY3JvbGxSZWN0ID0gb3B0aW9ucy52aWV3LnNjcm9sbENvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIHJlY3QgPSBfZXh0ZW5kcyh7fSwgcmVjdCwge1xuICAgICAgICB0b3A6IHJlY3QudG9wIC0gc2Nyb2xsUmVjdC50b3AsXG4gICAgICAgIHJpZ2h0OiByZWN0LnJpZ2h0IC0gc2Nyb2xsUmVjdC5sZWZ0LFxuICAgICAgICBib3R0b206IHJlY3QuYm90dG9tIC0gc2Nyb2xsUmVjdC50b3AsXG4gICAgICAgIGxlZnQ6IHJlY3QubGVmdCAtIHNjcm9sbFJlY3QubGVmdFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5oZWlnaHQgPSBvcHRpb25zLmVsLm9mZnNldEhlaWdodDtcbiAgICB0aGlzLndpZHRoID0gb3B0aW9ucy5lbC5vZmZzZXRXaWR0aDtcbiAgICB0aGlzLmxlZnQgPSByZWN0LmxlZnQ7XG4gICAgdGhpcy5yaWdodCA9IHJlY3QucmlnaHQ7XG4gICAgdGhpcy50b3AgPSByZWN0LnRvcDtcbiAgICB0aGlzLmJvdHRvbSA9IHJlY3QuYm90dG9tO1xuXG4gICAgaWYgKG9wdGlvbnMucm9vdE1hcmdpbikge1xuICAgICAgdGhpcy5fc2V0UmVjdFdpdGhSb290TWFyZ2luKG9wdGlvbnMucm9vdE1hcmdpbik7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIEFwcGx5IHJvb3QgbWFyZ2luIHRvIGFsbCBwcm9wZXJ0aWVzXHJcbiAgICovXG5cblxuICB2YXIgX3Byb3RvID0gUmVjdC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLl9zZXRSZWN0V2l0aFJvb3RNYXJnaW4gPSBmdW5jdGlvbiBfc2V0UmVjdFdpdGhSb290TWFyZ2luKHJvb3RNYXJnaW4pIHtcbiAgICB2YXIgdG90YWxSb290WSA9IHJvb3RNYXJnaW4udG9wICsgcm9vdE1hcmdpbi5ib3R0b207XG4gICAgdmFyIHRvdGFsUm9vdFggPSByb290TWFyZ2luLmxlZnQgKyByb290TWFyZ2luLnJpZ2h0O1xuICAgIHRoaXMudG9wIC09IHJvb3RNYXJnaW4udG9wO1xuICAgIHRoaXMucmlnaHQgKz0gcm9vdE1hcmdpbi5yaWdodDtcbiAgICB0aGlzLmJvdHRvbSArPSByb290TWFyZ2luLmJvdHRvbTtcbiAgICB0aGlzLmxlZnQgLT0gcm9vdE1hcmdpbi5sZWZ0O1xuICAgIHRoaXMuaGVpZ2h0ICs9IHRvdGFsUm9vdFk7XG4gICAgdGhpcy53aWR0aCArPSB0b3RhbFJvb3RYO1xuICB9O1xuXG4gIHJldHVybiBSZWN0O1xufSgpO1xuXG52YXIgVkFMSURfVU5JVFMgPSBbU2NhbGVVbml0c1snJ10sIFVuaXRzLnB4LCBVbml0c1snJSddLCBVbml0c1sndmgnXSwgVW5pdHNbJ3Z3J10sIFJvdGF0aW9uVW5pdHMuZGVnLCBSb3RhdGlvblVuaXRzLnR1cm4sIFJvdGF0aW9uVW5pdHMucmFkXTtcbi8qKlxyXG4gKiBEZXRlcm1pbmVzIHRoZSB1bml0IG9mIGEgc3RyaW5nIGFuZCBwYXJzZXMgdGhlIHZhbHVlXHJcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZVZhbHVlQW5kVW5pdChzdHIsIGRlZmF1bHRVbml0KSB7XG4gIGlmIChkZWZhdWx0VW5pdCA9PT0gdm9pZCAwKSB7XG4gICAgZGVmYXVsdFVuaXQgPSBVbml0c1snJSddO1xuICB9XG5cbiAgdmFyIG91dCA9IHtcbiAgICB2YWx1ZTogMCxcbiAgICB1bml0OiBkZWZhdWx0VW5pdFxuICB9O1xuICBpZiAodHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHJldHVybiBvdXQ7XG4gIHZhciBpc1ZhbGlkID0gdHlwZW9mIHN0ciA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHN0ciA9PT0gJ3N0cmluZyc7XG5cbiAgaWYgKCFpc1ZhbGlkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlIHByb3ZpZGVkLiBNdXN0IHByb3ZpZGUgYSB2YWx1ZSBhcyBhIHN0cmluZyBvciBudW1iZXInKTtcbiAgfVxuXG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBvdXQudmFsdWUgPSBwYXJzZUZsb2F0KHN0cik7IC8vIEB0cy1pZ25vcmVcblxuICBvdXQudW5pdCA9IHN0ci5tYXRjaCgvW1xcZC5cXC0rXSpcXHMqKC4qKS8pWzFdIHx8IGRlZmF1bHRVbml0OyAvLyBAdHMtZXhwZWN0LWVycm9yXG5cbiAgdmFyIGlzVmFsaWRVbml0ID0gVkFMSURfVU5JVFMuaW5jbHVkZXMob3V0LnVuaXQpO1xuXG4gIGlmICghaXNWYWxpZFVuaXQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdW5pdCBwcm92aWRlZC4nKTtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59XG5cbnZhciBlYXNpbmdQcmVzZXRzID0ge1xuICBlYXNlOiBbMC4yNSwgMC4xLCAwLjI1LCAxLjBdLFxuICBlYXNlSW46IFswLjQyLCAwLjAsIDEuMCwgMS4wXSxcbiAgZWFzZU91dDogWzAuMCwgMC4wLCAwLjU4LCAxLjBdLFxuICBlYXNlSW5PdXQ6IFswLjQyLCAwLjAsIDAuNTgsIDEuMF0sXG5cbiAgLyogRWFzZSBJTiBjdXJ2ZXMgKi9cbiAgZWFzZUluUXVhZDogWzAuNTUsIDAuMDg1LCAwLjY4LCAwLjUzXSxcbiAgZWFzZUluQ3ViaWM6IFswLjU1LCAwLjA1NSwgMC42NzUsIDAuMTldLFxuICBlYXNlSW5RdWFydDogWzAuODk1LCAwLjAzLCAwLjY4NSwgMC4yMl0sXG4gIGVhc2VJblF1aW50OiBbMC43NTUsIDAuMDUsIDAuODU1LCAwLjA2XSxcbiAgZWFzZUluU2luZTogWzAuNDcsIDAuMCwgMC43NDUsIDAuNzE1XSxcbiAgZWFzZUluRXhwbzogWzAuOTUsIDAuMDUsIDAuNzk1LCAwLjAzNV0sXG4gIGVhc2VJbkNpcmM6IFswLjYsIDAuMDQsIDAuOTgsIDAuMzM1XSxcblxuICAvKiBFYXNlIE91dCBDdXJ2ZXMgKi9cbiAgZWFzZU91dFF1YWQ6IFswLjI1LCAwLjQ2LCAwLjQ1LCAwLjk0XSxcbiAgZWFzZU91dEN1YmljOiBbMC4yMTUsIDAuNjEsIDAuMzU1LCAxLjBdLFxuICBlYXNlT3V0UXVhcnQ6IFswLjE2NSwgMC44NCwgMC40NCwgMS4wXSxcbiAgZWFzZU91dFF1aW50OiBbMC4yMywgMS4wLCAwLjMyLCAxLjBdLFxuICBlYXNlT3V0U2luZTogWzAuMzksIDAuNTc1LCAwLjU2NSwgMS4wXSxcbiAgZWFzZU91dEV4cG86IFswLjE5LCAxLjAsIDAuMjIsIDEuMF0sXG4gIGVhc2VPdXRDaXJjOiBbMC4wNzUsIDAuODIsIDAuMTY1LCAxLjBdLFxuXG4gIC8qIEVhc2UgSU4gT3V0IEN1cnZlcyAqL1xuICBlYXNlSW5PdXRRdWFkOiBbMC40NTUsIDAuMDMsIDAuNTE1LCAwLjk1NV0sXG4gIGVhc2VJbk91dEN1YmljOiBbMC42NDUsIDAuMDQ1LCAwLjM1NSwgMS4wXSxcbiAgZWFzZUluT3V0UXVhcnQ6IFswLjc3LCAwLjAsIDAuMTc1LCAxLjBdLFxuICBlYXNlSW5PdXRRdWludDogWzAuODYsIDAuMCwgMC4wNywgMS4wXSxcbiAgZWFzZUluT3V0U2luZTogWzAuNDQ1LCAwLjA1LCAwLjU1LCAwLjk1XSxcbiAgZWFzZUluT3V0RXhwbzogWzEuMCwgMC4wLCAwLjAsIDEuMF0sXG4gIGVhc2VJbk91dENpcmM6IFswLjc4NSwgMC4xMzUsIDAuMTUsIDAuODZdLFxuXG4gIC8qIEVhc2UgQm91bmNlIEN1cnZlcyAqL1xuICBlYXNlSW5CYWNrOiBbMC42LCAtMC4yOCwgMC43MzUsIDAuMDQ1XSxcbiAgZWFzZU91dEJhY2s6IFswLjE3NSwgMC44ODUsIDAuMzIsIDEuMjc1XSxcbiAgZWFzZUluT3V0QmFjazogWzAuNjgsIC0wLjU1LCAwLjI2NSwgMS41NV1cbn07XG5cbmZ1bmN0aW9uIGNyZWF0ZUVhc2luZ0Z1bmN0aW9uKGVhc2luZykge1xuICBpZiAoQXJyYXkuaXNBcnJheShlYXNpbmcpKSB7XG4gICAgcmV0dXJuIGJlemllcihlYXNpbmdbMF0sIGVhc2luZ1sxXSwgZWFzaW5nWzJdLCBlYXNpbmdbM10pO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlYXNpbmcgPT09ICdzdHJpbmcnICYmIHR5cGVvZiBlYXNpbmdQcmVzZXRzW2Vhc2luZ10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgdmFyIHBhcmFtcyA9IGVhc2luZ1ByZXNldHNbZWFzaW5nXTtcbiAgICByZXR1cm4gYmV6aWVyKHBhcmFtc1swXSwgcGFyYW1zWzFdLCBwYXJhbXNbMl0sIHBhcmFtc1szXSk7XG4gIH1cblxuICByZXR1cm47XG59XG5cbnZhciBQQVJBTExBWF9FRkZFQ1RTID0gLyojX19QVVJFX18qL09iamVjdC52YWx1ZXMoVmFsaWRDU1NFZmZlY3RzKTtcbnZhciBNQVBfRUZGRUNUX1RPX0RFRkFVTFRfVU5JVCA9IHtcbiAgc3BlZWQ6ICdweCcsXG4gIHRyYW5zbGF0ZVg6ICclJyxcbiAgdHJhbnNsYXRlWTogJyUnLFxuICByb3RhdGU6ICdkZWcnLFxuICByb3RhdGVYOiAnZGVnJyxcbiAgcm90YXRlWTogJ2RlZycsXG4gIHJvdGF0ZVo6ICdkZWcnLFxuICBzY2FsZTogJycsXG4gIHNjYWxlWDogJycsXG4gIHNjYWxlWTogJycsXG4gIHNjYWxlWjogJycsXG4gIG9wYWNpdHk6ICcnXG59O1xuLyoqXHJcbiAqIFRha2VzIGEgcGFyYWxsYXggZWxlbWVudCBlZmZlY3RzIGFuZCBwYXJzZXMgdGhlIHByb3BlcnRpZXMgdG8gZ2V0IHRoZSBzdGFydCBhbmQgZW5kIHZhbHVlcyBhbmQgdW5pdHMuXHJcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZUVsZW1lbnRUcmFuc2l0aW9uRWZmZWN0cyhwcm9wcywgc2Nyb2xsQXhpcykge1xuICB2YXIgcGFyc2VkRWZmZWN0cyA9IHt9O1xuICBQQVJBTExBWF9FRkZFQ1RTLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBNQVBfRUZGRUNUX1RPX0RFRkFVTFRfVU5JVFtrZXldOyAvLyBJZiB0aGUgcHJvdmlkZWQgdHlwZSBpcyBhIG51bWJlciwgdGhpcyBtdXN0IGJlIHRoZSBzcGVlZCBwcm9wXG4gICAgLy8gaW4gd2hpY2ggY2FzZSB3ZSBuZWVkIHRvIGNvbnN0cnVjdCB0aGUgcHJvcGVyIHRyYW5zbGF0ZSBjb25maWdcblxuICAgIGlmICh0eXBlb2YgKHByb3BzID09IG51bGwgPyB2b2lkIDAgOiBwcm9wc1trZXldKSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhciB2YWx1ZSA9IHByb3BzID09IG51bGwgPyB2b2lkIDAgOiBwcm9wc1trZXldO1xuICAgICAgdmFyIHN0YXJ0U3BlZWQgPSAodmFsdWUgfHwgMCkgKiAxMCArIFwicHhcIjtcbiAgICAgIHZhciBlbmRTcGVlZCA9ICh2YWx1ZSB8fCAwKSAqIC0xMCArIFwicHhcIjtcbiAgICAgIHZhciBzdGFydFBhcnNlZCA9IHBhcnNlVmFsdWVBbmRVbml0KHN0YXJ0U3BlZWQpO1xuICAgICAgdmFyIGVuZFBhcnNlZCA9IHBhcnNlVmFsdWVBbmRVbml0KGVuZFNwZWVkKTtcbiAgICAgIHZhciBzcGVlZENvbmZpZyA9IHtcbiAgICAgICAgc3RhcnQ6IHN0YXJ0UGFyc2VkLnZhbHVlLFxuICAgICAgICBlbmQ6IGVuZFBhcnNlZC52YWx1ZSxcbiAgICAgICAgdW5pdDogc3RhcnRQYXJzZWQudW5pdFxuICAgICAgfTsgLy8gTWFudWFsbHkgc2V0IHRyYW5zbGF0ZSB5IHZhbHVlXG5cbiAgICAgIGlmIChzY3JvbGxBeGlzID09PSBTY3JvbGxBeGlzLnZlcnRpY2FsKSB7XG4gICAgICAgIHBhcnNlZEVmZmVjdHMudHJhbnNsYXRlWSA9IHNwZWVkQ29uZmlnO1xuICAgICAgfSAvLyBNYW51YWxseSBzZXQgdHJhbnNsYXRlIHkgdmFsdWVcblxuXG4gICAgICBpZiAoc2Nyb2xsQXhpcyA9PT0gU2Nyb2xsQXhpcy5ob3Jpem9udGFsKSB7XG4gICAgICAgIHBhcnNlZEVmZmVjdHMudHJhbnNsYXRlWCA9IHNwZWVkQ29uZmlnO1xuICAgICAgfVxuICAgIH0gLy8gVGhlIHJlc3QgYXJlIHN0YW5kYXJkIGVmZmVjdCBiZWluZyBwYXJzZWRcblxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcHMgPT0gbnVsbCA/IHZvaWQgMCA6IHByb3BzW2tleV0pKSB7XG4gICAgICB2YXIgX3ZhbHVlID0gcHJvcHMgPT0gbnVsbCA/IHZvaWQgMCA6IHByb3BzW2tleV07XG5cbiAgICAgIGlmICh0eXBlb2YgX3ZhbHVlWzBdICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgX3ZhbHVlWzFdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgX3N0YXJ0UGFyc2VkID0gcGFyc2VWYWx1ZUFuZFVuaXQoX3ZhbHVlID09IG51bGwgPyB2b2lkIDAgOiBfdmFsdWVbMF0sIGRlZmF1bHRWYWx1ZSk7XG5cbiAgICAgICAgdmFyIF9lbmRQYXJzZWQgPSBwYXJzZVZhbHVlQW5kVW5pdChfdmFsdWUgPT0gbnVsbCA/IHZvaWQgMCA6IF92YWx1ZVsxXSwgZGVmYXVsdFZhbHVlKTtcblxuICAgICAgICB2YXIgZWFzaW5nID0gY3JlYXRlRWFzaW5nRnVuY3Rpb24oX3ZhbHVlID09IG51bGwgPyB2b2lkIDAgOiBfdmFsdWVbMl0pO1xuICAgICAgICBwYXJzZWRFZmZlY3RzW2tleV0gPSB7XG4gICAgICAgICAgc3RhcnQ6IF9zdGFydFBhcnNlZC52YWx1ZSxcbiAgICAgICAgICBlbmQ6IF9lbmRQYXJzZWQudmFsdWUsXG4gICAgICAgICAgdW5pdDogX3N0YXJ0UGFyc2VkLnVuaXQsXG4gICAgICAgICAgZWFzaW5nOiBlYXNpbmdcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoX3N0YXJ0UGFyc2VkLnVuaXQgIT09IF9lbmRQYXJzZWQudW5pdCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIG1hdGNoaW5nIHVuaXRzIGZvciB0aGUgbWluIGFuZCBtYXggb2Zmc2V0IHZhbHVlcyBvZiBlYWNoIGF4aXMuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcGFyc2VkRWZmZWN0cztcbn1cblxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHBlcmNlbnQgKDAgLSAxMDApIG1vdmVkIGJhc2VkIG9uIHBvc2l0aW9uIGluIHRoZSB2aWV3cG9ydFxyXG4gKi9cbmZ1bmN0aW9uIGdldFByb2dyZXNzQW1vdW50KFxuLypcclxuICogVGhlIHN0YXJ0IHZhbHVlIGZyb20gY2FjaGVcclxuICovXG5zdGFydCxcbi8qXHJcbiAqIHRvdGFsIGRpc3QgdGhlIGVsZW1lbnQgaGFzIHRvIG1vdmUgdG8gYmUgMTAwJSBjb21wbGV0ZSAodmlldyB3aWR0aC9oZWlnaHQgKyBlbGVtZW50IHdpZHRoL2hlaWdodClcclxuICovXG50b3RhbERpc3QsXG4vKlxyXG4gKiBDdXJyZW50IHNjcm9sbCB2YWx1ZVxyXG4gKi9cbmN1cnJlbnRTY3JvbGwsXG4vKlxyXG4gKiBhbiBvcHRpb25hbCBlYXNpbmcgZnVuY3Rpb24gdG8gYXBwbHlcclxuICovXG5lYXNpbmcpIHtcbiAgLy8gYWRqdXN0IGNhY2hlZCB2YWx1ZVxuICB2YXIgc3RhcnRBZGp1c3RlZFNjcm9sbCA9IGN1cnJlbnRTY3JvbGwgLSBzdGFydDsgLy8gQW1vdW50IHRoZSBlbGVtZW50IGhhcyBtb3ZlZCBiYXNlZCBvbiBjdXJyZW50IGFuZCB0b3RhbCBkaXN0YW5jZSB0byBtb3ZlXG5cbiAgdmFyIGFtb3VudCA9IHN0YXJ0QWRqdXN0ZWRTY3JvbGwgLyB0b3RhbERpc3Q7IC8vIEFwcGx5IGJlemllciBlYXNpbmcgaWYgcHJvdmlkZWRcblxuICBpZiAoZWFzaW5nKSB7XG4gICAgYW1vdW50ID0gZWFzaW5nKGFtb3VudCk7XG4gIH1cblxuICByZXR1cm4gYW1vdW50O1xufVxuXG4vKipcclxuICogVGFrZXMgdHdvIHZhbHVlcyAoc3RhcnQsIGVuZCkgYW5kIHJldHVybnMgd2hldGhlciB0aGUgY3VycmVudCBzY3JvbGwgaXMgd2l0aGluIHJhbmdlXHJcbiAqIEBwYXJhbSB7bnVtYmVyfSBzdGFydCAtIHN0YXJ0IG9mIHNjcm9sbCAoeC95KVxyXG4gKiBAcGFyYW0ge251bWJlcn0gZW5kIC0gZW5kIG9mIHNjcm9sbCAoeC95KVxyXG4gKiBAcGFyYW0ge251bWJlcn0gc2Nyb2xsIC0gY3VycmVudCBzY3JvbGwgKHgveSlcclxuICogQHJldHVybiB7Ym9vbGVhbn0gaXNJblZpZXdcclxuICovXG5mdW5jdGlvbiBpc0VsZW1lbnRJblZpZXcoc3RhcnQsIGVuZCwgc2Nyb2xsKSB7XG4gIHZhciBpc0luVmlldyA9IHNjcm9sbCA+PSBzdGFydCAmJiBzY3JvbGwgPD0gZW5kO1xuICByZXR1cm4gaXNJblZpZXc7XG59XG5cbi8vIFNjYWxlIGJldHdlZW4gQUtBIG5vcm1hbGl6ZVxuZnVuY3Rpb24gc2NhbGVCZXR3ZWVuKHZhbHVlLCBuZXdNaW4sIG5ld01heCwgb2xkTWluLCBvbGRNYXgpIHtcbiAgcmV0dXJuIChuZXdNYXggLSBuZXdNaW4pICogKHZhbHVlIC0gb2xkTWluKSAvIChvbGRNYXggLSBvbGRNaW4pICsgbmV3TWluO1xufVxuXG4vKipcclxuICogU2NhbGVzIGEgc3RhcnQgYW5kIGVuZCB2YWx1ZSBvZiBhbiBlZmZlY3QgYmFzZWQgb24gcGVyY2VudCBtb3ZlZCBhbmQgZWFzaW5nIGZ1bmN0aW9uXHJcbiAqL1xuXG5mdW5jdGlvbiBzY2FsZUVmZmVjdEJ5UHJvZ3Jlc3MoZWZmZWN0LCBwcm9ncmVzcykge1xuICB2YXIgdmFsdWUgPSBzY2FsZUJldHdlZW4odHlwZW9mIGVmZmVjdC5lYXNpbmcgPT09ICdmdW5jdGlvbicgPyBlZmZlY3QuZWFzaW5nKHByb2dyZXNzKSA6IHByb2dyZXNzLCAoZWZmZWN0ID09IG51bGwgPyB2b2lkIDAgOiBlZmZlY3Quc3RhcnQpIHx8IDAsIChlZmZlY3QgPT0gbnVsbCA/IHZvaWQgMCA6IGVmZmVjdC5lbmQpIHx8IDAsIDAsIDEpO1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICB1bml0OiBlZmZlY3QgPT0gbnVsbCA/IHZvaWQgMCA6IGVmZmVjdC51bml0XG4gIH07XG59XG5cbnZhciBUUkFOU0ZPUk1fRUZGRUNUUyA9IC8qI19fUFVSRV9fKi9PYmplY3QudmFsdWVzKFZhbGlkQ1NTRWZmZWN0cykuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XG4gIHJldHVybiB2ICE9PSAnb3BhY2l0eSc7XG59KTtcbmZ1bmN0aW9uIHNldFdpbGxDaGFuZ2VTdHlsZXMoZWwsIGVmZmVjdHMpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhlZmZlY3RzKTtcbiAgdmFyIGhhc09wYWNpdHkgPSBrZXlzLmluY2x1ZGVzKCdvcGFjaXR5Jyk7XG4gIHZhciB3aWxsQ2hhbmdlID0gXCJ0cmFuc2Zvcm1cIiArIChoYXNPcGFjaXR5ID8gJyxvcGFjaXR5JyA6ICcnKTtcbiAgZWwuc3R5bGUud2lsbENoYW5nZSA9IHdpbGxDaGFuZ2U7XG59XG5mdW5jdGlvbiBzZXRFbGVtZW50U3R5bGVzKGVmZmVjdHMsIHByb2dyZXNzLCBlbCkge1xuICBpZiAoIWVsKSByZXR1cm47XG4gIHZhciB0cmFuc2Zvcm0gPSBnZXRUcmFuc2Zvcm1TdHlsZXMoZWZmZWN0cywgcHJvZ3Jlc3MpO1xuICB2YXIgb3BhY2l0eSA9IGdldE9wYWNpdHlTdHlsZXMoZWZmZWN0cywgcHJvZ3Jlc3MpO1xuICBlbC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gIGVsLnN0eWxlLm9wYWNpdHkgPSBvcGFjaXR5O1xufVxuZnVuY3Rpb24gZ2V0T3BhY2l0eVN0eWxlcyhlZmZlY3RzLCBwcm9ncmVzcykge1xuICB2YXIgc2NhbGVkT3BhY2l0eSA9IGVmZmVjdHNbJ29wYWNpdHknXSAmJiBzY2FsZUVmZmVjdEJ5UHJvZ3Jlc3MoZWZmZWN0c1snb3BhY2l0eSddLCBwcm9ncmVzcyk7XG5cbiAgaWYgKHR5cGVvZiBzY2FsZWRPcGFjaXR5ID09PSAndW5kZWZpbmVkJyB8fCB0eXBlb2Ygc2NhbGVkT3BhY2l0eS52YWx1ZSA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHNjYWxlZE9wYWNpdHkudW5pdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB2YXIgc3R5bGVTdHIgPSBcIlwiICsgc2NhbGVkT3BhY2l0eS52YWx1ZTtcbiAgcmV0dXJuIHN0eWxlU3RyO1xufVxuZnVuY3Rpb24gZ2V0VHJhbnNmb3JtU3R5bGVzKGVmZmVjdHMsIHByb2dyZXNzKSB7XG4gIHZhciB0cmFuc2Zvcm0gPSBUUkFOU0ZPUk1fRUZGRUNUUy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XG4gICAgdmFyIHNjYWxlZEVmZmVjdCA9IC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICBlZmZlY3RzW2tleV0gJiYgc2NhbGVFZmZlY3RCeVByb2dyZXNzKGVmZmVjdHNba2V5XSwgcHJvZ3Jlc3MpO1xuXG4gICAgaWYgKHR5cGVvZiBzY2FsZWRFZmZlY3QgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBzY2FsZWRFZmZlY3QudmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBzY2FsZWRFZmZlY3QudW5pdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfVxuXG4gICAgdmFyIHN0eWxlU3RyID0ga2V5ICsgXCIoXCIgKyBzY2FsZWRFZmZlY3QudmFsdWUgKyBzY2FsZWRFZmZlY3QudW5pdCArIFwiKVwiO1xuICAgIHJldHVybiBhY2MgKyBzdHlsZVN0cjtcbiAgfSwgJycpO1xuICByZXR1cm4gdHJhbnNmb3JtO1xufVxuLyoqXHJcbiAqIFRha2VzIGEgcGFyYWxsYXggZWxlbWVudCBhbmQgcmVtb3ZlcyBwYXJhbGxheCBvZmZzZXQgc3R5bGVzLlxyXG4gKiBAcGFyYW0ge29iamVjdH0gZWxlbWVudFxyXG4gKi9cblxuZnVuY3Rpb24gcmVzZXRTdHlsZXMoZWxlbWVudCkge1xuICB2YXIgZWwgPSBlbGVtZW50LmVsO1xuICBpZiAoIWVsKSByZXR1cm47XG4gIGVsLnN0eWxlLnRyYW5zZm9ybSA9ICcnO1xuICBlbC5zdHlsZS5vcGFjaXR5ID0gJyc7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbWl0c0ZvclJlbGF0aXZlRWxlbWVudHMocmVjdCwgdmlldywgc2Nyb2xsLCBzaG91bGRBbHdheXNDb21wbGV0ZUFuaW1hdGlvbikge1xuICB2YXIgc3RhcnRZID0gcmVjdC50b3AgLSB2aWV3LmhlaWdodDtcbiAgdmFyIHN0YXJ0WCA9IHJlY3QubGVmdCAtIHZpZXcud2lkdGg7XG4gIHZhciBlbmRZID0gcmVjdC5ib3R0b207XG4gIHZhciBlbmRYID0gcmVjdC5yaWdodDsgLy8gYWRkIHNjcm9sbFxuXG4gIHN0YXJ0WCArPSBzY3JvbGwueDtcbiAgZW5kWCArPSBzY3JvbGwueDtcbiAgc3RhcnRZICs9IHNjcm9sbC55O1xuICBlbmRZICs9IHNjcm9sbC55O1xuXG4gIGlmIChzaG91bGRBbHdheXNDb21wbGV0ZUFuaW1hdGlvbikge1xuICAgIGlmIChzY3JvbGwueSArIHJlY3QudG9wIDwgdmlldy5oZWlnaHQpIHtcbiAgICAgIHN0YXJ0WSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKHNjcm9sbC54ICsgcmVjdC5sZWZ0IDwgdmlldy53aWR0aCkge1xuICAgICAgc3RhcnRYID0gMDtcbiAgICB9XG5cbiAgICBpZiAoZW5kWSA+IHZpZXcuc2Nyb2xsSGVpZ2h0IC0gdmlldy5oZWlnaHQpIHtcbiAgICAgIGVuZFkgPSB2aWV3LnNjcm9sbEhlaWdodCAtIHZpZXcuaGVpZ2h0O1xuICAgIH1cblxuICAgIGlmIChlbmRYID4gdmlldy5zY3JvbGxXaWR0aCAtIHZpZXcud2lkdGgpIHtcbiAgICAgIGVuZFggPSB2aWV3LnNjcm9sbFdpZHRoIC0gdmlldy53aWR0aDtcbiAgICB9XG4gIH1cblxuICB2YXIgbGltaXRzID0gbmV3IExpbWl0cyh7XG4gICAgc3RhcnRYOiBzdGFydFgsXG4gICAgc3RhcnRZOiBzdGFydFksXG4gICAgZW5kWDogZW5kWCxcbiAgICBlbmRZOiBlbmRZXG4gIH0pO1xuICByZXR1cm4gbGltaXRzO1xufVxuXG5mdW5jdGlvbiBnZXRUcmFuc2xhdGVTY2FsYXIoc3RhcnRUcmFuc2xhdGVQeCwgZW5kVHJhbnNsYXRlUHgsIHRvdGFsRGlzdCkge1xuICB2YXIgc2xvdyA9IGVuZFRyYW5zbGF0ZVB4ID4gc3RhcnRUcmFuc2xhdGVQeDsgLy8gY2FsY3VsYXRpbmcgbmVjZXNzYXJ5IHNjYWxlIHRvIGluY3JlYXNlIHRyYW5zbGF0aW9uc1xuXG4gIHZhciB0b3RhbEFic09mZiA9IChNYXRoLmFicyhzdGFydFRyYW5zbGF0ZVB4KSArIE1hdGguYWJzKGVuZFRyYW5zbGF0ZVB4KSkgKiAoc2xvdyA/IC0xIDogMSk7XG4gIHZhciB0b3RhbERpc3RUcnVlID0gdG90YWxEaXN0ICsgdG90YWxBYnNPZmY7IC8vIERldGVybWluZSBtdWx0aXBsZSB0byBzY2FsZSBieSwgb25seSB2YWx1ZXMgZ3JlYXRlciB0aGFuIDFcblxuICB2YXIgc2NhbGUgPSBNYXRoLm1heCh0b3RhbERpc3QgLyB0b3RhbERpc3RUcnVlLCAxKTtcbiAgcmV0dXJuIHNjYWxlO1xufVxuXG4vKipcclxuICogUmV0dXJuIHRoZSBzdGFydCBhbmQgZW5kIHBpeGVsIHZhbHVlcyBmb3IgYW4gZWxlbWVudHMgdHJhbnNsYXRpb25zXHJcbiAqL1xuZnVuY3Rpb24gZ2V0U3RhcnRFbmRWYWx1ZUluUHgodHJhbnNsYXRlLCBlbGVtZW50U2l6ZSkge1xuICB2YXIgc3RhcnQgPSB0cmFuc2xhdGUuc3RhcnQsXG4gICAgICBlbmQgPSB0cmFuc2xhdGUuZW5kLFxuICAgICAgdW5pdCA9IHRyYW5zbGF0ZS51bml0O1xuXG4gIGlmICh1bml0ID09PSAnJScpIHtcbiAgICB2YXIgc2NhbGUgPSBlbGVtZW50U2l6ZSAvIDEwMDtcbiAgICBzdGFydCA9IHN0YXJ0ICogc2NhbGU7XG4gICAgZW5kID0gZW5kICogc2NhbGU7XG4gIH1cblxuICBpZiAodW5pdCA9PT0gJ3Z3Jykge1xuICAgIHZhciBzdGFydFNjYWxlID0gc3RhcnQgLyAxMDA7XG4gICAgdmFyIGVuZFNjYWxlID0gZW5kIC8gMTAwO1xuICAgIHN0YXJ0ID0gd2luZG93LmlubmVyV2lkdGggKiBzdGFydFNjYWxlO1xuICAgIGVuZCA9IHdpbmRvdy5pbm5lcldpZHRoICogZW5kU2NhbGU7XG4gIH1cblxuICBpZiAodW5pdCA9PT0gJ3ZoJykge1xuICAgIHZhciBfc3RhcnRTY2FsZSA9IHN0YXJ0IC8gMTAwO1xuXG4gICAgdmFyIF9lbmRTY2FsZSA9IGVuZCAvIDEwMDtcblxuICAgIHN0YXJ0ID0gd2luZG93LmlubmVySGVpZ2h0ICogX3N0YXJ0U2NhbGU7XG4gICAgZW5kID0gd2luZG93LmlubmVySGVpZ2h0ICogX2VuZFNjYWxlO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogc3RhcnQsXG4gICAgZW5kOiBlbmRcbiAgfTtcbn1cblxudmFyIERFRkFVTFRfVkFMVUUgPSB7XG4gIHN0YXJ0OiAwLFxuICBlbmQ6IDAsXG4gIHVuaXQ6ICcnXG59O1xuZnVuY3Rpb24gY3JlYXRlTGltaXRzV2l0aFRyYW5zbGF0aW9uc0ZvclJlbGF0aXZlRWxlbWVudHMocmVjdCwgdmlldywgZWZmZWN0cywgc2Nyb2xsLCBzY3JvbGxBeGlzLCBzaG91bGRBbHdheXNDb21wbGV0ZUFuaW1hdGlvbikge1xuICAvLyBnZXQgc3RhcnQgYW5kIGVuZCBhY2NvdW50aW5nIGZvciBwZXJjZW50IGVmZmVjdHNcbiAgdmFyIHRyYW5zbGF0ZVggPSBlZmZlY3RzLnRyYW5zbGF0ZVggfHwgREVGQVVMVF9WQUxVRTtcbiAgdmFyIHRyYW5zbGF0ZVkgPSBlZmZlY3RzLnRyYW5zbGF0ZVkgfHwgREVGQVVMVF9WQUxVRTtcblxuICB2YXIgX2dldFN0YXJ0RW5kVmFsdWVJblB4ID0gZ2V0U3RhcnRFbmRWYWx1ZUluUHgodHJhbnNsYXRlWCwgcmVjdC53aWR0aCksXG4gICAgICBzdGFydFRyYW5zbGF0ZVhQeCA9IF9nZXRTdGFydEVuZFZhbHVlSW5QeC5zdGFydCxcbiAgICAgIGVuZFRyYW5zbGF0ZVhQeCA9IF9nZXRTdGFydEVuZFZhbHVlSW5QeC5lbmQ7XG5cbiAgdmFyIF9nZXRTdGFydEVuZFZhbHVlSW5QeDIgPSBnZXRTdGFydEVuZFZhbHVlSW5QeCh0cmFuc2xhdGVZLCByZWN0LmhlaWdodCksXG4gICAgICBzdGFydFRyYW5zbGF0ZVlQeCA9IF9nZXRTdGFydEVuZFZhbHVlSW5QeDIuc3RhcnQsXG4gICAgICBlbmRUcmFuc2xhdGVZUHggPSBfZ2V0U3RhcnRFbmRWYWx1ZUluUHgyLmVuZDsgLy8gZGVmYXVsdCBzdGFydGluZyB2YWx1ZXNcblxuXG4gIHZhciBzdGFydFkgPSByZWN0LnRvcCAtIHZpZXcuaGVpZ2h0O1xuICB2YXIgc3RhcnRYID0gcmVjdC5sZWZ0IC0gdmlldy53aWR0aDtcbiAgdmFyIGVuZFkgPSByZWN0LmJvdHRvbTtcbiAgdmFyIGVuZFggPSByZWN0LnJpZ2h0O1xuICB2YXIgc3RhcnRNdWx0aXBsaWVyWSA9IDE7XG4gIHZhciBlbmRNdWx0aXBsaWVyWSA9IDE7XG5cbiAgaWYgKHNjcm9sbEF4aXMgPT09IFNjcm9sbEF4aXMudmVydGljYWwpIHtcbiAgICBzdGFydE11bHRpcGxpZXJZID0gZ2V0VHJhbnNsYXRlU2NhbGFyKHN0YXJ0VHJhbnNsYXRlWVB4LCBlbmRUcmFuc2xhdGVZUHgsIHZpZXcuaGVpZ2h0ICsgcmVjdC5oZWlnaHQpO1xuICAgIGVuZE11bHRpcGxpZXJZID0gc3RhcnRNdWx0aXBsaWVyWTtcbiAgfVxuXG4gIHZhciBzdGFydE11bHRpcGxpZXJYID0gMTtcbiAgdmFyIGVuZE11bHRpcGxpZXJYID0gMTtcblxuICBpZiAoc2Nyb2xsQXhpcyA9PT0gU2Nyb2xsQXhpcy5ob3Jpem9udGFsKSB7XG4gICAgc3RhcnRNdWx0aXBsaWVyWCA9IGdldFRyYW5zbGF0ZVNjYWxhcihzdGFydFRyYW5zbGF0ZVhQeCwgZW5kVHJhbnNsYXRlWFB4LCB2aWV3LndpZHRoICsgcmVjdC53aWR0aCk7XG4gICAgZW5kTXVsdGlwbGllclggPSBzdGFydE11bHRpcGxpZXJYO1xuICB9IC8vIEFwcGx5IHRoZSBzY2FsZSB0byBpbml0aWFsIHZhbHVlc1xuXG5cbiAgaWYgKHN0YXJ0VHJhbnNsYXRlWVB4IDwgMCkge1xuICAgIHN0YXJ0WSA9IHN0YXJ0WSArIHN0YXJ0VHJhbnNsYXRlWVB4ICogc3RhcnRNdWx0aXBsaWVyWTtcbiAgfVxuXG4gIGlmIChlbmRUcmFuc2xhdGVZUHggPiAwKSB7XG4gICAgZW5kWSA9IGVuZFkgKyBlbmRUcmFuc2xhdGVZUHggKiBlbmRNdWx0aXBsaWVyWTtcbiAgfVxuXG4gIGlmIChzdGFydFRyYW5zbGF0ZVhQeCA8IDApIHtcbiAgICBzdGFydFggPSBzdGFydFggKyBzdGFydFRyYW5zbGF0ZVhQeCAqIHN0YXJ0TXVsdGlwbGllclg7XG4gIH1cblxuICBpZiAoZW5kVHJhbnNsYXRlWFB4ID4gMCkge1xuICAgIGVuZFggPSBlbmRYICsgZW5kVHJhbnNsYXRlWFB4ICogZW5kTXVsdGlwbGllclg7XG4gIH0gLy8gYWRkIHNjcm9sbFxuXG5cbiAgc3RhcnRYICs9IHNjcm9sbC54O1xuICBlbmRYICs9IHNjcm9sbC54O1xuICBzdGFydFkgKz0gc2Nyb2xsLnk7XG4gIGVuZFkgKz0gc2Nyb2xsLnk7IC8vIE5PVEU6IHBsZWFzZSByZWZhY3RvciBhbmQgaXNvbGF0ZSB0aGlzIDooXG5cbiAgaWYgKHNob3VsZEFsd2F5c0NvbXBsZXRlQW5pbWF0aW9uKSB7XG4gICAgdmFyIHRvcEJlZ2luc0luVmlldyA9IHNjcm9sbC55ICsgcmVjdC50b3AgPCB2aWV3LmhlaWdodDtcbiAgICB2YXIgbGVmdEJlZ2luc0luVmlldyA9IHNjcm9sbC54ICsgcmVjdC5sZWZ0IDwgdmlldy53aWR0aDtcbiAgICB2YXIgYm90dG9tRW5kc0luVmlldyA9IHNjcm9sbC55ICsgcmVjdC5ib3R0b20gPiB2aWV3LnNjcm9sbEhlaWdodCAtIHZpZXcuaGVpZ2h0O1xuICAgIHZhciByaWdodEVuZHNJblZpZXcgPSBzY3JvbGwueCArIHJlY3QucmlnaHQgPiB2aWV3LnNjcm9sbFdpZHRoIC0gdmlldy5oZWlnaHQ7XG5cbiAgICBpZiAodG9wQmVnaW5zSW5WaWV3ICYmIGJvdHRvbUVuZHNJblZpZXcpIHtcbiAgICAgIHN0YXJ0TXVsdGlwbGllclkgPSAxO1xuICAgICAgZW5kTXVsdGlwbGllclkgPSAxO1xuICAgICAgc3RhcnRZID0gMDtcbiAgICAgIGVuZFkgPSB2aWV3LnNjcm9sbEhlaWdodCAtIHZpZXcuaGVpZ2h0O1xuICAgIH1cblxuICAgIGlmIChsZWZ0QmVnaW5zSW5WaWV3ICYmIHJpZ2h0RW5kc0luVmlldykge1xuICAgICAgc3RhcnRNdWx0aXBsaWVyWCA9IDE7XG4gICAgICBlbmRNdWx0aXBsaWVyWCA9IDE7XG4gICAgICBzdGFydFggPSAwO1xuICAgICAgZW5kWCA9IHZpZXcuc2Nyb2xsV2lkdGggLSB2aWV3LndpZHRoO1xuICAgIH1cblxuICAgIGlmICghdG9wQmVnaW5zSW5WaWV3ICYmIGJvdHRvbUVuZHNJblZpZXcpIHtcbiAgICAgIHN0YXJ0WSA9IHJlY3QudG9wIC0gdmlldy5oZWlnaHQgKyBzY3JvbGwueTtcbiAgICAgIGVuZFkgPSB2aWV3LnNjcm9sbEhlaWdodCAtIHZpZXcuaGVpZ2h0O1xuICAgICAgdmFyIHRvdGFsRGlzdCA9IGVuZFkgLSBzdGFydFk7XG4gICAgICBzdGFydE11bHRpcGxpZXJZID0gZ2V0VHJhbnNsYXRlU2NhbGFyKHN0YXJ0VHJhbnNsYXRlWVB4LCBlbmRUcmFuc2xhdGVZUHgsIHRvdGFsRGlzdCk7XG4gICAgICBlbmRNdWx0aXBsaWVyWSA9IDE7XG5cbiAgICAgIGlmIChzdGFydFRyYW5zbGF0ZVlQeCA8IDApIHtcbiAgICAgICAgc3RhcnRZID0gc3RhcnRZICsgc3RhcnRUcmFuc2xhdGVZUHggKiBzdGFydE11bHRpcGxpZXJZO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghbGVmdEJlZ2luc0luVmlldyAmJiByaWdodEVuZHNJblZpZXcpIHtcbiAgICAgIHN0YXJ0WCA9IHJlY3QubGVmdCAtIHZpZXcud2lkdGggKyBzY3JvbGwueDtcbiAgICAgIGVuZFggPSB2aWV3LnNjcm9sbFdpZHRoIC0gdmlldy53aWR0aDtcblxuICAgICAgdmFyIF90b3RhbERpc3QgPSBlbmRYIC0gc3RhcnRYO1xuXG4gICAgICBzdGFydE11bHRpcGxpZXJYID0gZ2V0VHJhbnNsYXRlU2NhbGFyKHN0YXJ0VHJhbnNsYXRlWFB4LCBlbmRUcmFuc2xhdGVYUHgsIF90b3RhbERpc3QpO1xuICAgICAgZW5kTXVsdGlwbGllclggPSAxO1xuXG4gICAgICBpZiAoc3RhcnRUcmFuc2xhdGVYUHggPCAwKSB7XG4gICAgICAgIHN0YXJ0WCA9IHN0YXJ0WCArIHN0YXJ0VHJhbnNsYXRlWFB4ICogc3RhcnRNdWx0aXBsaWVyWDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodG9wQmVnaW5zSW5WaWV3ICYmICFib3R0b21FbmRzSW5WaWV3KSB7XG4gICAgICBzdGFydFkgPSAwO1xuICAgICAgZW5kWSA9IHJlY3QuYm90dG9tICsgc2Nyb2xsLnk7XG5cbiAgICAgIHZhciBfdG90YWxEaXN0MiA9IGVuZFkgLSBzdGFydFk7XG5cbiAgICAgIHN0YXJ0TXVsdGlwbGllclkgPSAxO1xuICAgICAgZW5kTXVsdGlwbGllclkgPSBnZXRUcmFuc2xhdGVTY2FsYXIoc3RhcnRUcmFuc2xhdGVZUHgsIGVuZFRyYW5zbGF0ZVlQeCwgX3RvdGFsRGlzdDIpO1xuXG4gICAgICBpZiAoZW5kVHJhbnNsYXRlWVB4ID4gMCkge1xuICAgICAgICBlbmRZID0gZW5kWSArIGVuZFRyYW5zbGF0ZVlQeCAqIGVuZE11bHRpcGxpZXJZO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChsZWZ0QmVnaW5zSW5WaWV3ICYmICFyaWdodEVuZHNJblZpZXcpIHtcbiAgICAgIHN0YXJ0WCA9IDA7XG4gICAgICBlbmRYID0gcmVjdC5yaWdodCArIHNjcm9sbC54O1xuXG4gICAgICB2YXIgX3RvdGFsRGlzdDMgPSBlbmRYIC0gc3RhcnRYO1xuXG4gICAgICBzdGFydE11bHRpcGxpZXJYID0gMTtcbiAgICAgIGVuZE11bHRpcGxpZXJYID0gZ2V0VHJhbnNsYXRlU2NhbGFyKHN0YXJ0VHJhbnNsYXRlWFB4LCBlbmRUcmFuc2xhdGVYUHgsIF90b3RhbERpc3QzKTtcblxuICAgICAgaWYgKGVuZFRyYW5zbGF0ZVhQeCA+IDApIHtcbiAgICAgICAgZW5kWCA9IGVuZFggKyBlbmRUcmFuc2xhdGVYUHggKiBlbmRNdWx0aXBsaWVyWDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgbGltaXRzID0gbmV3IExpbWl0cyh7XG4gICAgc3RhcnRYOiBzdGFydFgsXG4gICAgc3RhcnRZOiBzdGFydFksXG4gICAgZW5kWDogZW5kWCxcbiAgICBlbmRZOiBlbmRZLFxuICAgIHN0YXJ0TXVsdGlwbGllclg6IHN0YXJ0TXVsdGlwbGllclgsXG4gICAgZW5kTXVsdGlwbGllclg6IGVuZE11bHRpcGxpZXJYLFxuICAgIHN0YXJ0TXVsdGlwbGllclk6IHN0YXJ0TXVsdGlwbGllclksXG4gICAgZW5kTXVsdGlwbGllclk6IGVuZE11bHRpcGxpZXJZXG4gIH0pO1xuICByZXR1cm4gbGltaXRzO1xufVxuXG5mdW5jdGlvbiBzY2FsZVRyYW5zbGF0ZUVmZmVjdHNGb3JTbG93ZXJTY3JvbGwoZWZmZWN0cywgbGltaXRzKSB7XG4gIHZhciBlZmZlY3RzQ29weSA9IF9leHRlbmRzKHt9LCBlZmZlY3RzKTtcblxuICBpZiAoZWZmZWN0c0NvcHkudHJhbnNsYXRlWCkge1xuICAgIGVmZmVjdHNDb3B5LnRyYW5zbGF0ZVggPSBfZXh0ZW5kcyh7fSwgZWZmZWN0cy50cmFuc2xhdGVYLCB7XG4gICAgICBzdGFydDogZWZmZWN0c0NvcHkudHJhbnNsYXRlWC5zdGFydCAqIGxpbWl0cy5zdGFydE11bHRpcGxpZXJYLFxuICAgICAgZW5kOiBlZmZlY3RzQ29weS50cmFuc2xhdGVYLmVuZCAqIGxpbWl0cy5lbmRNdWx0aXBsaWVyWFxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGVmZmVjdHNDb3B5LnRyYW5zbGF0ZVkpIHtcbiAgICBlZmZlY3RzQ29weS50cmFuc2xhdGVZID0gX2V4dGVuZHMoe30sIGVmZmVjdHMudHJhbnNsYXRlWSwge1xuICAgICAgc3RhcnQ6IGVmZmVjdHNDb3B5LnRyYW5zbGF0ZVkuc3RhcnQgKiBsaW1pdHMuc3RhcnRNdWx0aXBsaWVyWSxcbiAgICAgIGVuZDogZWZmZWN0c0NvcHkudHJhbnNsYXRlWS5lbmQgKiBsaW1pdHMuZW5kTXVsdGlwbGllcllcbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBlZmZlY3RzQ29weTtcbn1cblxuZnVuY3Rpb24gZ2V0U2hvdWxkU2NhbGVUcmFuc2xhdGVFZmZlY3RzKHByb3BzLCBlZmZlY3RzLCBzY3JvbGxBeGlzKSB7XG4gIGlmIChwcm9wcy5yb290TWFyZ2luIHx8IHByb3BzLnRhcmdldEVsZW1lbnQgfHwgcHJvcHMuc2hvdWxkRGlzYWJsZVNjYWxpbmdUcmFuc2xhdGlvbnMpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoISFlZmZlY3RzLnRyYW5zbGF0ZVggJiYgc2Nyb2xsQXhpcyA9PT0gU2Nyb2xsQXhpcy5ob3Jpem9udGFsIHx8ICEhZWZmZWN0cy50cmFuc2xhdGVZICYmIHNjcm9sbEF4aXMgPT09IFNjcm9sbEF4aXMudmVydGljYWwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGNsYW1wID0gZnVuY3Rpb24gY2xhbXAobnVtLCBtaW4sIG1heCkge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgobnVtLCBtaW4pLCBtYXgpO1xufTtcblxudmFyIEVsZW1lbnQgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBFbGVtZW50KG9wdGlvbnMpIHtcbiAgICB0aGlzLmVsID0gb3B0aW9ucy5lbDtcbiAgICB0aGlzLnByb3BzID0gb3B0aW9ucy5wcm9wcztcbiAgICB0aGlzLnNjcm9sbEF4aXMgPSBvcHRpb25zLnNjcm9sbEF4aXM7XG4gICAgdGhpcy5kaXNhYmxlZFBhcmFsbGF4Q29udHJvbGxlciA9IG9wdGlvbnMuZGlzYWJsZWRQYXJhbGxheENvbnRyb2xsZXIgfHwgZmFsc2U7XG4gICAgdGhpcy5pZCA9IGNyZWF0ZUlkKCk7XG4gICAgdGhpcy5lZmZlY3RzID0gcGFyc2VFbGVtZW50VHJhbnNpdGlvbkVmZmVjdHModGhpcy5wcm9wcywgdGhpcy5zY3JvbGxBeGlzKTtcbiAgICB0aGlzLmlzSW5WaWV3ID0gbnVsbDtcbiAgICB0aGlzLnByb2dyZXNzID0gMDtcblxuICAgIHRoaXMuX3NldEVsZW1lbnRFYXNpbmcob3B0aW9ucy5wcm9wcy5lYXNpbmcpO1xuXG4gICAgc2V0V2lsbENoYW5nZVN0eWxlcyhvcHRpb25zLmVsLCB0aGlzLmVmZmVjdHMpO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IEVsZW1lbnQucHJvdG90eXBlO1xuXG4gIF9wcm90by51cGRhdGVQcm9wcyA9IGZ1bmN0aW9uIHVwZGF0ZVByb3BzKG5leHRQcm9wcykge1xuICAgIHRoaXMucHJvcHMgPSBfZXh0ZW5kcyh7fSwgdGhpcy5wcm9wcywgbmV4dFByb3BzKTtcbiAgICB0aGlzLmVmZmVjdHMgPSBwYXJzZUVsZW1lbnRUcmFuc2l0aW9uRWZmZWN0cyhuZXh0UHJvcHMsIHRoaXMuc2Nyb2xsQXhpcyk7XG5cbiAgICB0aGlzLl9zZXRFbGVtZW50RWFzaW5nKG5leHRQcm9wcy5lYXNpbmcpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLnNldENhY2hlZEF0dHJpYnV0ZXMgPSBmdW5jdGlvbiBzZXRDYWNoZWRBdHRyaWJ1dGVzKHZpZXcsIHNjcm9sbCkge1xuICAgIC8vIE5PVEU6IE11c3QgcmVzZXQgc3R5bGVzIGJlZm9yZSBnZXR0aW5nIHRoZSByZWN0LCBhcyBpdCBtaWdodCBpbXBhY3QgdGhlIG5hdHVyYWwgcG9zaXRpb25cbiAgICByZXNldFN0eWxlcyh0aGlzKTtcbiAgICB0aGlzLnJlY3QgPSBuZXcgUmVjdCh7XG4gICAgICBlbDogdGhpcy5wcm9wcy50YXJnZXRFbGVtZW50IHx8IHRoaXMuZWwsXG4gICAgICByb290TWFyZ2luOiB0aGlzLnByb3BzLnJvb3RNYXJnaW4sXG4gICAgICB2aWV3OiB2aWV3XG4gICAgfSk7XG4gICAgdmFyIHNob3VsZFNjYWxlVHJhbnNsYXRlRWZmZWN0cyA9IGdldFNob3VsZFNjYWxlVHJhbnNsYXRlRWZmZWN0cyh0aGlzLnByb3BzLCB0aGlzLmVmZmVjdHMsIHRoaXMuc2Nyb2xsQXhpcyk7XG5cbiAgICBpZiAodHlwZW9mIHRoaXMucHJvcHMuc3RhcnRTY3JvbGwgPT09ICdudW1iZXInICYmIHR5cGVvZiB0aGlzLnByb3BzLmVuZFNjcm9sbCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMubGltaXRzID0gbmV3IExpbWl0cyh7XG4gICAgICAgIHN0YXJ0WDogdGhpcy5wcm9wcy5zdGFydFNjcm9sbCxcbiAgICAgICAgc3RhcnRZOiB0aGlzLnByb3BzLnN0YXJ0U2Nyb2xsLFxuICAgICAgICBlbmRYOiB0aGlzLnByb3BzLmVuZFNjcm9sbCxcbiAgICAgICAgZW5kWTogdGhpcy5wcm9wcy5lbmRTY3JvbGxcbiAgICAgIH0pOyAvLyBVbmRvIHRoZSByZXNldCAtLSBwbGFjZSBpdCBiYWNrIGF0IGN1cnJlbnQgcG9zaXRpb24gd2l0aCBzdHlsZXNcblxuICAgICAgdGhpcy5fc2V0RWxlbWVudFN0eWxlcygpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkU2NhbGVUcmFuc2xhdGVFZmZlY3RzKSB7XG4gICAgICB0aGlzLmxpbWl0cyA9IGNyZWF0ZUxpbWl0c1dpdGhUcmFuc2xhdGlvbnNGb3JSZWxhdGl2ZUVsZW1lbnRzKHRoaXMucmVjdCwgdmlldywgdGhpcy5lZmZlY3RzLCBzY3JvbGwsIHRoaXMuc2Nyb2xsQXhpcywgdGhpcy5wcm9wcy5zaG91bGRBbHdheXNDb21wbGV0ZUFuaW1hdGlvbik7XG4gICAgICB0aGlzLnNjYWxlZEVmZmVjdHMgPSBzY2FsZVRyYW5zbGF0ZUVmZmVjdHNGb3JTbG93ZXJTY3JvbGwodGhpcy5lZmZlY3RzLCB0aGlzLmxpbWl0cyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGltaXRzID0gY3JlYXRlTGltaXRzRm9yUmVsYXRpdmVFbGVtZW50cyh0aGlzLnJlY3QsIHZpZXcsIHNjcm9sbCwgdGhpcy5wcm9wcy5zaG91bGRBbHdheXNDb21wbGV0ZUFuaW1hdGlvbik7XG4gICAgfSAvLyBVbmRvIHRoZSByZXNldCAtLSBwbGFjZSBpdCBiYWNrIGF0IGN1cnJlbnQgcG9zaXRpb24gd2l0aCBzdHlsZXNcblxuXG4gICAgdGhpcy5fc2V0RWxlbWVudFN0eWxlcygpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgX3Byb3RvLl91cGRhdGVFbGVtZW50SXNJblZpZXcgPSBmdW5jdGlvbiBfdXBkYXRlRWxlbWVudElzSW5WaWV3KG5leHRJc0luVmlldykge1xuICAgIC8vIE5PVEU6IENoZWNrIGlmIHRoaXMgaXMgdGhlIGZpcnN0IGNoYW5nZSB0byBtYWtlIHN1cmUgb25FeGl0IGlzbid0IGNhbGxlZFxuICAgIHZhciBpc0ZpcnN0Q2hhbmdlID0gdGhpcy5pc0luVmlldyA9PT0gbnVsbDtcblxuICAgIGlmIChuZXh0SXNJblZpZXcgIT09IHRoaXMuaXNJblZpZXcpIHtcbiAgICAgIGlmIChuZXh0SXNJblZpZXcpIHtcbiAgICAgICAgdGhpcy5wcm9wcy5vbkVudGVyICYmIHRoaXMucHJvcHMub25FbnRlcih0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoIWlzRmlyc3RDaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5fc2V0RmluYWxQcm9ncmVzcygpO1xuXG4gICAgICAgIHRoaXMuX3NldEVsZW1lbnRTdHlsZXMoKTtcblxuICAgICAgICB0aGlzLnByb3BzLm9uRXhpdCAmJiB0aGlzLnByb3BzLm9uRXhpdCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmlzSW5WaWV3ID0gbmV4dElzSW5WaWV3O1xuICB9O1xuXG4gIF9wcm90by5fc2V0RmluYWxQcm9ncmVzcyA9IGZ1bmN0aW9uIF9zZXRGaW5hbFByb2dyZXNzKCkge1xuICAgIHZhciBmaW5hbFByb2dyZXNzID0gY2xhbXAoTWF0aC5yb3VuZCh0aGlzLnByb2dyZXNzKSwgMCwgMSk7XG5cbiAgICB0aGlzLl91cGRhdGVFbGVtZW50UHJvZ3Jlc3MoZmluYWxQcm9ncmVzcyk7XG4gIH07XG5cbiAgX3Byb3RvLl9zZXRFbGVtZW50U3R5bGVzID0gZnVuY3Rpb24gX3NldEVsZW1lbnRTdHlsZXMoKSB7XG4gICAgaWYgKHRoaXMucHJvcHMuZGlzYWJsZWQgfHwgdGhpcy5kaXNhYmxlZFBhcmFsbGF4Q29udHJvbGxlcikgcmV0dXJuO1xuICAgIHZhciBlZmZlY3RzID0gdGhpcy5zY2FsZWRFZmZlY3RzIHx8IHRoaXMuZWZmZWN0cztcbiAgICBzZXRFbGVtZW50U3R5bGVzKGVmZmVjdHMsIHRoaXMucHJvZ3Jlc3MsIHRoaXMuZWwpO1xuICB9O1xuXG4gIF9wcm90by5fdXBkYXRlRWxlbWVudFByb2dyZXNzID0gZnVuY3Rpb24gX3VwZGF0ZUVsZW1lbnRQcm9ncmVzcyhuZXh0UHJvZ3Jlc3MpIHtcbiAgICB0aGlzLnByb2dyZXNzID0gbmV4dFByb2dyZXNzO1xuICAgIHRoaXMucHJvcHMub25Qcm9ncmVzc0NoYW5nZSAmJiB0aGlzLnByb3BzLm9uUHJvZ3Jlc3NDaGFuZ2UodGhpcy5wcm9ncmVzcyk7XG4gICAgdGhpcy5wcm9wcy5vbkNoYW5nZSAmJiB0aGlzLnByb3BzLm9uQ2hhbmdlKHRoaXMpO1xuICB9O1xuXG4gIF9wcm90by5fc2V0RWxlbWVudEVhc2luZyA9IGZ1bmN0aW9uIF9zZXRFbGVtZW50RWFzaW5nKGVhc2luZykge1xuICAgIHRoaXMuZWFzaW5nID0gY3JlYXRlRWFzaW5nRnVuY3Rpb24oZWFzaW5nKTtcbiAgfTtcblxuICBfcHJvdG8udXBkYXRlRWxlbWVudE9wdGlvbnMgPSBmdW5jdGlvbiB1cGRhdGVFbGVtZW50T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdGhpcy5zY3JvbGxBeGlzID0gb3B0aW9ucy5zY3JvbGxBeGlzO1xuICAgIHRoaXMuZGlzYWJsZWRQYXJhbGxheENvbnRyb2xsZXIgPSBvcHRpb25zLmRpc2FibGVkUGFyYWxsYXhDb250cm9sbGVyIHx8IGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by51cGRhdGVQb3NpdGlvbiA9IGZ1bmN0aW9uIHVwZGF0ZVBvc2l0aW9uKHNjcm9sbCkge1xuICAgIGlmICghdGhpcy5saW1pdHMpIHJldHVybiB0aGlzO1xuICAgIHZhciBpc1ZlcnRpY2FsID0gdGhpcy5zY3JvbGxBeGlzID09PSBTY3JvbGxBeGlzLnZlcnRpY2FsO1xuICAgIHZhciBpc0ZpcnN0Q2hhbmdlID0gdGhpcy5pc0luVmlldyA9PT0gbnVsbDsgLy8gYmFzZWQgb24gc2Nyb2xsIGF4aXNcblxuICAgIHZhciBzdGFydCA9IGlzVmVydGljYWwgPyB0aGlzLmxpbWl0cy5zdGFydFkgOiB0aGlzLmxpbWl0cy5zdGFydFg7XG4gICAgdmFyIGVuZCA9IGlzVmVydGljYWwgPyB0aGlzLmxpbWl0cy5lbmRZIDogdGhpcy5saW1pdHMuZW5kWDtcbiAgICB2YXIgdG90YWwgPSBpc1ZlcnRpY2FsID8gdGhpcy5saW1pdHMudG90YWxZIDogdGhpcy5saW1pdHMudG90YWxYO1xuICAgIHZhciBzID0gaXNWZXJ0aWNhbCA/IHNjcm9sbC55IDogc2Nyb2xsLng7IC8vIGNoZWNrIGlmIGluIHZpZXdcblxuICAgIHZhciBuZXh0SXNJblZpZXcgPSBpc0VsZW1lbnRJblZpZXcoc3RhcnQsIGVuZCwgcyk7XG5cbiAgICB0aGlzLl91cGRhdGVFbGVtZW50SXNJblZpZXcobmV4dElzSW5WaWV3KTsgLy8gc2V0IHRoZSBwcm9ncmVzcyBpZiBpbiB2aWV3IG9yIHRoaXMgaXMgdGhlIGZpcnN0IGNoYW5nZVxuXG5cbiAgICBpZiAobmV4dElzSW5WaWV3KSB7XG4gICAgICB2YXIgbmV4dFByb2dyZXNzID0gZ2V0UHJvZ3Jlc3NBbW91bnQoc3RhcnQsIHRvdGFsLCBzLCB0aGlzLmVhc2luZyk7XG5cbiAgICAgIHRoaXMuX3VwZGF0ZUVsZW1lbnRQcm9ncmVzcyhuZXh0UHJvZ3Jlc3MpO1xuXG4gICAgICB0aGlzLl9zZXRFbGVtZW50U3R5bGVzKCk7XG4gICAgfSBlbHNlIGlmIChpc0ZpcnN0Q2hhbmdlKSB7XG4gICAgICAvLyBOT1RFOiB0aGlzLl91cGRhdGVFbGVtZW50UHJvZ3Jlc3MgLS0gZG9udCB1c2UgdGhpcyBiZWNhdXNlIGl0IHdpbGwgdHJpZ2dlciBvbkNoYW5nZVxuICAgICAgdGhpcy5wcm9ncmVzcyA9IGNsYW1wKE1hdGgucm91bmQoZ2V0UHJvZ3Jlc3NBbW91bnQoc3RhcnQsIHRvdGFsLCBzLCB0aGlzLmVhc2luZykpLCAwLCAxKTtcblxuICAgICAgdGhpcy5fc2V0RWxlbWVudFN0eWxlcygpO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJldHVybiBFbGVtZW50O1xufSgpO1xuXG52YXIgVmlldyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFZpZXcoY29uZmlnKSB7XG4gICAgdGhpcy5zY3JvbGxDb250YWluZXIgPSBjb25maWcuc2Nyb2xsQ29udGFpbmVyO1xuICAgIHRoaXMud2lkdGggPSBjb25maWcud2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBjb25maWcuaGVpZ2h0O1xuICAgIHRoaXMuc2Nyb2xsSGVpZ2h0ID0gY29uZmlnLnNjcm9sbEhlaWdodDtcbiAgICB0aGlzLnNjcm9sbFdpZHRoID0gY29uZmlnLnNjcm9sbFdpZHRoO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFZpZXcucHJvdG90eXBlO1xuXG4gIF9wcm90by5oYXNDaGFuZ2VkID0gZnVuY3Rpb24gaGFzQ2hhbmdlZChwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zLndpZHRoICE9PSB0aGlzLndpZHRoIHx8IHBhcmFtcy5oZWlnaHQgIT09IHRoaXMuaGVpZ2h0IHx8IHBhcmFtcy5zY3JvbGxXaWR0aCAhPT0gdGhpcy5zY3JvbGxXaWR0aCB8fCBwYXJhbXMuc2Nyb2xsSGVpZ2h0ICE9PSB0aGlzLnNjcm9sbEhlaWdodCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIF9wcm90by5zZXRTaXplID0gZnVuY3Rpb24gc2V0U2l6ZShwYXJhbXMpIHtcbiAgICB0aGlzLndpZHRoID0gcGFyYW1zLndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gcGFyYW1zLmhlaWdodDtcbiAgICB0aGlzLnNjcm9sbEhlaWdodCA9IHBhcmFtcy5zY3JvbGxIZWlnaHQ7XG4gICAgdGhpcy5zY3JvbGxXaWR0aCA9IHBhcmFtcy5zY3JvbGxXaWR0aDtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICByZXR1cm4gVmlldztcbn0oKTtcblxudmFyIFNjcm9sbCA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFNjcm9sbCh4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHRoaXMuZHggPSAwO1xuICAgIHRoaXMuZHkgPSAwO1xuICB9XG5cbiAgdmFyIF9wcm90byA9IFNjcm9sbC5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLnNldFNjcm9sbCA9IGZ1bmN0aW9uIHNldFNjcm9sbCh4LCB5KSB7XG4gICAgdGhpcy5keCA9IHggLSB0aGlzLng7XG4gICAgdGhpcy5keSA9IHkgLSB0aGlzLnk7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIHJldHVybiBTY3JvbGw7XG59KCk7XG5cbmZ1bmN0aW9uIHRlc3RGb3JQYXNzaXZlU2Nyb2xsKCkge1xuICB2YXIgc3VwcG9ydHNQYXNzaXZlT3B0aW9uID0gZmFsc2U7XG5cbiAgdHJ5IHtcbiAgICB2YXIgb3B0cyA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3Bhc3NpdmUnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgc3VwcG9ydHNQYXNzaXZlT3B0aW9uID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7IC8vIEB0cy1leHBlY3QtZXJyb3JcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0cyk7IC8vIEB0cy1leHBlY3QtZXJyb3JcblxuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwgb3B0cyk7XG4gIH0gY2F0Y2ggKGUpIHt9XG5cbiAgcmV0dXJuIHN1cHBvcnRzUGFzc2l2ZU9wdGlvbjtcbn1cblxuLyoqXHJcbiAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICogUGFyYWxsYXggQ29udHJvbGxlclxyXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAqXHJcbiAqIFRoZSBnbG9iYWwgY29udHJvbGxlciBmb3Igc2V0dGluZyB1cCBhbmQgbWFuYWdpbmcgYSBzY3JvbGwgdmlldyBvZiBlbGVtZW50cy5cclxuICpcclxuICovXG5cbnZhciBQYXJhbGxheENvbnRyb2xsZXIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBQYXJhbGxheENvbnRyb2xsZXIoX3JlZikge1xuICAgIHZhciBfcmVmJHNjcm9sbEF4aXMgPSBfcmVmLnNjcm9sbEF4aXMsXG4gICAgICAgIHNjcm9sbEF4aXMgPSBfcmVmJHNjcm9sbEF4aXMgPT09IHZvaWQgMCA/IFNjcm9sbEF4aXMudmVydGljYWwgOiBfcmVmJHNjcm9sbEF4aXMsXG4gICAgICAgIHNjcm9sbENvbnRhaW5lciA9IF9yZWYuc2Nyb2xsQ29udGFpbmVyLFxuICAgICAgICBfcmVmJGRpc2FibGVkID0gX3JlZi5kaXNhYmxlZCxcbiAgICAgICAgZGlzYWJsZWQgPSBfcmVmJGRpc2FibGVkID09PSB2b2lkIDAgPyBmYWxzZSA6IF9yZWYkZGlzYWJsZWQ7XG4gICAgdGhpcy5kaXNhYmxlZCA9IGRpc2FibGVkO1xuICAgIHRoaXMuc2Nyb2xsQXhpcyA9IHNjcm9sbEF4aXM7IC8vIEFsbCBwYXJhbGxheCBlbGVtZW50cyB0byBiZSB1cGRhdGVkXG5cbiAgICB0aGlzLmVsZW1lbnRzID0gW107XG4gICAgdGhpcy5faGFzU2Nyb2xsQ29udGFpbmVyID0gISFzY3JvbGxDb250YWluZXI7XG4gICAgdGhpcy52aWV3RWwgPSBzY3JvbGxDb250YWluZXIgIT0gbnVsbCA/IHNjcm9sbENvbnRhaW5lciA6IHdpbmRvdzsgLy8gU2Nyb2xsIGFuZCBWaWV3XG5cbiAgICB2YXIgX3RoaXMkX2dldFNjcm9sbFBvc2l0ID0gdGhpcy5fZ2V0U2Nyb2xsUG9zaXRpb24oKSxcbiAgICAgICAgeCA9IF90aGlzJF9nZXRTY3JvbGxQb3NpdFswXSxcbiAgICAgICAgeSA9IF90aGlzJF9nZXRTY3JvbGxQb3NpdFsxXTtcblxuICAgIHRoaXMuc2Nyb2xsID0gbmV3IFNjcm9sbCh4LCB5KTtcbiAgICB0aGlzLnZpZXcgPSBuZXcgVmlldyh7XG4gICAgICB3aWR0aDogMCxcbiAgICAgIGhlaWdodDogMCxcbiAgICAgIHNjcm9sbFdpZHRoOiAwLFxuICAgICAgc2Nyb2xsSGVpZ2h0OiAwLFxuICAgICAgc2Nyb2xsQ29udGFpbmVyOiB0aGlzLl9oYXNTY3JvbGxDb250YWluZXIgPyBzY3JvbGxDb250YWluZXIgOiB1bmRlZmluZWRcbiAgICB9KTsgLy8gVGlja2luZ1xuXG4gICAgdGhpcy5fdGlja2luZyA9IGZhbHNlOyAvLyBQYXNzaXZlIHN1cHBvcnRcblxuICAgIHRoaXMuX3N1cHBvcnRzUGFzc2l2ZSA9IHRlc3RGb3JQYXNzaXZlU2Nyb2xsKCk7IC8vIEJpbmQgbWV0aG9kcyB0byBjbGFzc1xuXG4gICAgdGhpcy5fYmluZEFsbE1ldGhvZHMoKTsgLy8gSWYgdGhpcyBpcyBpbml0aWFsaXplZCBkaXNhYmxlZCwgZG9uJ3QgZG8gYW55dGhpbmcgYmVsb3cuXG5cblxuICAgIGlmICh0aGlzLmRpc2FibGVkKSByZXR1cm47XG5cbiAgICB0aGlzLl9hZGRMaXN0ZW5lcnModGhpcy52aWV3RWwpO1xuXG4gICAgdGhpcy5fYWRkUmVzaXplT2JzZXJ2ZXIoKTtcblxuICAgIHRoaXMuX3NldFZpZXdTaXplKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogU3RhdGljIG1ldGhvZCB0byBpbnN0YW50aWF0ZSB0aGUgUGFyYWxsYXhDb250cm9sbGVyLlxyXG4gICAqIEByZXR1cm5zIHtDbGFzc30gUGFyYWxsYXhDb250cm9sbGVyXHJcbiAgICovXG5cblxuICBQYXJhbGxheENvbnRyb2xsZXIuaW5pdCA9IGZ1bmN0aW9uIGluaXQob3B0aW9ucykge1xuICAgIHZhciBoYXNXaW5kb3cgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJztcblxuICAgIGlmICghaGFzV2luZG93KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvb2tzIGxpa2UgUGFyYWxsYXhDb250cm9sbGVyLmluaXQoKSB3YXMgY2FsbGVkIG9uIHRoZSBzZXJ2ZXIuIFRoaXMgbWV0aG9kIG11c3QgYmUgY2FsbGVkIG9uIHRoZSBjbGllbnQuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQYXJhbGxheENvbnRyb2xsZXIob3B0aW9ucyk7XG4gIH07XG5cbiAgdmFyIF9wcm90byA9IFBhcmFsbGF4Q29udHJvbGxlci5wcm90b3R5cGU7XG5cbiAgX3Byb3RvLl9iaW5kQWxsTWV0aG9kcyA9IGZ1bmN0aW9uIF9iaW5kQWxsTWV0aG9kcygpIHtcbiAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgWydfYWRkTGlzdGVuZXJzJywgJ19yZW1vdmVMaXN0ZW5lcnMnLCAnX2dldFNjcm9sbFBvc2l0aW9uJywgJ19oYW5kbGVTY3JvbGwnLCAnX2hhbmRsZVVwZGF0ZUNhY2hlJywgJ191cGRhdGVBbGxFbGVtZW50cycsICdfdXBkYXRlRWxlbWVudFBvc2l0aW9uJywgJ19zZXRWaWV3U2l6ZScsICdfYWRkUmVzaXplT2JzZXJ2ZXInLCAnX2NoZWNrSWZWaWV3SGFzQ2hhbmdlZCcsICdfZ2V0Vmlld1BhcmFtcycsICdnZXRFbGVtZW50cycsICdjcmVhdGVFbGVtZW50JywgJ3JlbW92ZUVsZW1lbnRCeUlkJywgJ3Jlc2V0RWxlbWVudFN0eWxlcycsICd1cGRhdGVFbGVtZW50UHJvcHNCeUlkJywgJ3VwZGF0ZScsICd1cGRhdGVTY3JvbGxDb250YWluZXInLCAnZGVzdHJveSddLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgX3RoaXNbbWV0aG9kXSA9IF90aGlzW21ldGhvZF0uYmluZChfdGhpcyk7XG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLl9hZGRMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfYWRkTGlzdGVuZXJzKGVsKSB7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5faGFuZGxlU2Nyb2xsLCB0aGlzLl9zdXBwb3J0c1Bhc3NpdmUgPyB7XG4gICAgICBwYXNzaXZlOiB0cnVlXG4gICAgfSA6IGZhbHNlKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgdGhpcy5faGFuZGxlVXBkYXRlQ2FjaGUsIGZhbHNlKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMuX2hhbmRsZVVwZGF0ZUNhY2hlLCBmYWxzZSk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgdGhpcy5faGFuZGxlVXBkYXRlQ2FjaGUsIGZhbHNlKTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuX2hhbmRsZVVwZGF0ZUNhY2hlLCBmYWxzZSk7XG4gIH07XG5cbiAgX3Byb3RvLl9yZW1vdmVMaXN0ZW5lcnMgPSBmdW5jdGlvbiBfcmVtb3ZlTGlzdGVuZXJzKGVsKSB7XG4gICAgdmFyIF90aGlzJF9yZXNpemVPYnNlcnZlcjtcblxuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX2hhbmRsZVNjcm9sbCwgZmFsc2UpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCB0aGlzLl9oYW5kbGVVcGRhdGVDYWNoZSwgZmFsc2UpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5faGFuZGxlVXBkYXRlQ2FjaGUsIGZhbHNlKTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXMnLCB0aGlzLl9oYW5kbGVVcGRhdGVDYWNoZSwgZmFsc2UpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5faGFuZGxlVXBkYXRlQ2FjaGUsIGZhbHNlKTtcbiAgICAoX3RoaXMkX3Jlc2l6ZU9ic2VydmVyID0gdGhpcy5fcmVzaXplT2JzZXJ2ZXIpID09IG51bGwgPyB2b2lkIDAgOiBfdGhpcyRfcmVzaXplT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICB9O1xuXG4gIF9wcm90by5fYWRkUmVzaXplT2JzZXJ2ZXIgPSBmdW5jdGlvbiBfYWRkUmVzaXplT2JzZXJ2ZXIoKSB7XG4gICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIG9ic2VydmVkRWwgPSB0aGlzLl9oYXNTY3JvbGxDb250YWluZXIgPyB0aGlzLnZpZXdFbCA6IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgIHRoaXMuX3Jlc2l6ZU9ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzMi51cGRhdGUoKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9yZXNpemVPYnNlcnZlci5vYnNlcnZlKG9ic2VydmVkRWwpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUud2FybignRmFpbGVkIHRvIGNyZWF0ZSB0aGUgcmVzaXplIG9ic2VydmVyIGluIHRoZSBQYXJhbGxheENvbnRvbGxlcicpO1xuICAgIH1cbiAgfTtcblxuICBfcHJvdG8uX2dldFNjcm9sbFBvc2l0aW9uID0gZnVuY3Rpb24gX2dldFNjcm9sbFBvc2l0aW9uKCkge1xuICAgIC8vIFNhdmUgY3VycmVudCBzY3JvbGxcbiAgICAvLyBTdXBwb3J0cyBJRSA5IGFuZCB1cC5cbiAgICB2YXIgbnggPSB0aGlzLl9oYXNTY3JvbGxDb250YWluZXIgPyAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgdGhpcy52aWV3RWwuc2Nyb2xsTGVmdCA6IHdpbmRvdy5wYWdlWE9mZnNldDtcbiAgICB2YXIgbnkgPSB0aGlzLl9oYXNTY3JvbGxDb250YWluZXIgPyAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgdGhpcy52aWV3RWwuc2Nyb2xsVG9wIDogd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgIHJldHVybiBbbngsIG55XTtcbiAgfVxuICAvKipcclxuICAgKiBXaW5kb3cgc2Nyb2xsIGhhbmRsZXIgc2V0cyBzY3JvbGwgcG9zaXRpb25cclxuICAgKiBhbmQgdGhlbiBjYWxscyAnX3VwZGF0ZUFsbEVsZW1lbnRzKCknLlxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLl9oYW5kbGVTY3JvbGwgPSBmdW5jdGlvbiBfaGFuZGxlU2Nyb2xsKCkge1xuICAgIHZhciBfdGhpcyRlbGVtZW50cztcblxuICAgIHZhciBfdGhpcyRfZ2V0U2Nyb2xsUG9zaXQyID0gdGhpcy5fZ2V0U2Nyb2xsUG9zaXRpb24oKSxcbiAgICAgICAgbnggPSBfdGhpcyRfZ2V0U2Nyb2xsUG9zaXQyWzBdLFxuICAgICAgICBueSA9IF90aGlzJF9nZXRTY3JvbGxQb3NpdDJbMV07XG5cbiAgICB0aGlzLnNjcm9sbC5zZXRTY3JvbGwobngsIG55KTsgLy8gT25seSBjYWxsZWQgaWYgdGhlIGxhc3QgYW5pbWF0aW9uIHJlcXVlc3QgaGFzIGJlZW5cbiAgICAvLyBjb21wbGV0ZWQgYW5kIHRoZXJlIGFyZSBwYXJhbGxheCBlbGVtZW50cyB0byB1cGRhdGVcblxuICAgIGlmICghdGhpcy5fdGlja2luZyAmJiAoKF90aGlzJGVsZW1lbnRzID0gdGhpcy5lbGVtZW50cykgPT0gbnVsbCA/IHZvaWQgMCA6IF90aGlzJGVsZW1lbnRzLmxlbmd0aCkgPiAwKSB7XG4gICAgICB0aGlzLl90aWNraW5nID0gdHJ1ZTsgLy8gQHRzLWlnbm9yZVxuXG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHRoaXMuX3VwZGF0ZUFsbEVsZW1lbnRzKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogV2luZG93IHJlc2l6ZSBoYW5kbGVyLiBTZXRzIHRoZSBuZXcgd2luZG93IGlubmVyIGhlaWdodFxyXG4gICAqIHRoZW4gdXBkYXRlcyBwYXJhbGxheCBlbGVtZW50IGF0dHJpYnV0ZXMgYW5kIHBvc2l0aW9ucy5cclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5faGFuZGxlVXBkYXRlQ2FjaGUgPSBmdW5jdGlvbiBfaGFuZGxlVXBkYXRlQ2FjaGUoKSB7XG4gICAgdGhpcy5fc2V0Vmlld1NpemUoKTtcblxuICAgIHRoaXMuX3VwZGF0ZUFsbEVsZW1lbnRzKHtcbiAgICAgIHVwZGF0ZUNhY2hlOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogVXBkYXRlIGVsZW1lbnQgcG9zaXRpb25zLlxyXG4gICAqIERldGVybWluZXMgaWYgdGhlIGVsZW1lbnQgaXMgaW4gdmlldyBiYXNlZCBvbiB0aGUgY2FjaGVkXHJcbiAgICogYXR0cmlidXRlcywgaWYgc28gc2V0IHRoZSBlbGVtZW50cyBwYXJhbGxheCBzdHlsZXMuXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8uX3VwZGF0ZUFsbEVsZW1lbnRzID0gZnVuY3Rpb24gX3VwZGF0ZUFsbEVsZW1lbnRzKF90ZW1wKSB7XG4gICAgdmFyIF90aGlzMyA9IHRoaXM7XG5cbiAgICB2YXIgX3JlZjIgPSBfdGVtcCA9PT0gdm9pZCAwID8ge30gOiBfdGVtcCxcbiAgICAgICAgdXBkYXRlQ2FjaGUgPSBfcmVmMi51cGRhdGVDYWNoZTtcblxuICAgIGlmICh0aGlzLmVsZW1lbnRzKSB7XG4gICAgICB0aGlzLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHVwZGF0ZUNhY2hlKSB7XG4gICAgICAgICAgZWxlbWVudC5zZXRDYWNoZWRBdHRyaWJ1dGVzKF90aGlzMy52aWV3LCBfdGhpczMuc2Nyb2xsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzMy5fdXBkYXRlRWxlbWVudFBvc2l0aW9uKGVsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgfSAvLyByZXNldCB0aWNraW5nIHNvIG1vcmUgYW5pbWF0aW9ucyBjYW4gYmUgY2FsbGVkXG5cblxuICAgIHRoaXMuX3RpY2tpbmcgPSBmYWxzZTtcbiAgfVxuICAvKipcclxuICAgKiBVcGRhdGUgZWxlbWVudCBwb3NpdGlvbnMuXHJcbiAgICogRGV0ZXJtaW5lcyBpZiB0aGUgZWxlbWVudCBpcyBpbiB2aWV3IGJhc2VkIG9uIHRoZSBjYWNoZWRcclxuICAgKiBhdHRyaWJ1dGVzLCBpZiBzbyBzZXQgdGhlIGVsZW1lbnRzIHBhcmFsbGF4IHN0eWxlcy5cclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5fdXBkYXRlRWxlbWVudFBvc2l0aW9uID0gZnVuY3Rpb24gX3VwZGF0ZUVsZW1lbnRQb3NpdGlvbihlbGVtZW50KSB7XG4gICAgaWYgKGVsZW1lbnQucHJvcHMuZGlzYWJsZWQgfHwgdGhpcy5kaXNhYmxlZCkgcmV0dXJuO1xuICAgIGVsZW1lbnQudXBkYXRlUG9zaXRpb24odGhpcy5zY3JvbGwpO1xuICB9XG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIHBhcmFtcyB0byBzZXQgaW4gdGhlIFZpZXcgZnJvbSB0aGUgc2Nyb2xsIGNvbnRhaW5lciBvciB0aGUgd2luZG93XHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8uX2dldFZpZXdQYXJhbXMgPSBmdW5jdGlvbiBfZ2V0Vmlld1BhcmFtcygpIHtcbiAgICBpZiAodGhpcy5faGFzU2Nyb2xsQ29udGFpbmVyKSB7XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICB2YXIgX3dpZHRoID0gdGhpcy52aWV3RWwub2Zmc2V0V2lkdGg7IC8vIEB0cy1leHBlY3QtZXJyb3JcblxuICAgICAgdmFyIF9oZWlnaHQgPSB0aGlzLnZpZXdFbC5vZmZzZXRIZWlnaHQ7IC8vIEB0cy1leHBlY3QtZXJyb3JcblxuICAgICAgdmFyIF9zY3JvbGxIZWlnaHQgPSB0aGlzLnZpZXdFbC5zY3JvbGxIZWlnaHQ7IC8vIEB0cy1leHBlY3QtZXJyb3JcblxuICAgICAgdmFyIF9zY3JvbGxXaWR0aCA9IHRoaXMudmlld0VsLnNjcm9sbFdpZHRoO1xuICAgICAgcmV0dXJuIHRoaXMudmlldy5zZXRTaXplKHtcbiAgICAgICAgd2lkdGg6IF93aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBfaGVpZ2h0LFxuICAgICAgICBzY3JvbGxIZWlnaHQ6IF9zY3JvbGxIZWlnaHQsXG4gICAgICAgIHNjcm9sbFdpZHRoOiBfc2Nyb2xsV2lkdGhcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHZhciBodG1sID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICAgIHZhciB3aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoIHx8IGh0bWwuY2xpZW50V2lkdGg7XG4gICAgdmFyIGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCB8fCBodG1sLmNsaWVudEhlaWdodDtcbiAgICB2YXIgc2Nyb2xsSGVpZ2h0ID0gaHRtbC5zY3JvbGxIZWlnaHQ7XG4gICAgdmFyIHNjcm9sbFdpZHRoID0gaHRtbC5zY3JvbGxXaWR0aDtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICBzY3JvbGxIZWlnaHQ6IHNjcm9sbEhlaWdodCxcbiAgICAgIHNjcm9sbFdpZHRoOiBzY3JvbGxXaWR0aFxuICAgIH07XG4gIH1cbiAgLyoqXHJcbiAgICogQ2FjaGUgdGhlIHZpZXcgYXR0cmlidXRlc1xyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLl9zZXRWaWV3U2l6ZSA9IGZ1bmN0aW9uIF9zZXRWaWV3U2l6ZSgpIHtcbiAgICByZXR1cm4gdGhpcy52aWV3LnNldFNpemUodGhpcy5fZ2V0Vmlld1BhcmFtcygpKTtcbiAgfVxuICAvKipcclxuICAgKiBDaGVja3MgaWYgYW55IG9mIHRoZSBjYWNoZWQgYXR0cmlidXRlcyBvZiB0aGUgdmlldyBoYXZlIGNoYW5nZWQuXHJcbiAgICogQHJldHVybnMgYm9vbGVhblxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLl9jaGVja0lmVmlld0hhc0NoYW5nZWQgPSBmdW5jdGlvbiBfY2hlY2tJZlZpZXdIYXNDaGFuZ2VkKCkge1xuICAgIHJldHVybiB0aGlzLnZpZXcuaGFzQ2hhbmdlZCh0aGlzLl9nZXRWaWV3UGFyYW1zKCkpO1xuICB9XG4gIC8qKlxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKiBQdWJsaWMgbWV0aG9kc1xyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKi9cblxuICAvKipcclxuICAgKiBSZXR1cm5zIGFsbCB0aGUgcGFyYWxsYXggZWxlbWVudHMgaW4gdGhlIGNvbnRyb2xsZXJcclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5nZXRFbGVtZW50cyA9IGZ1bmN0aW9uIGdldEVsZW1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLmVsZW1lbnRzO1xuICB9XG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYW5kIHJldHVybnMgbmV3IHBhcmFsbGF4IGVsZW1lbnQgd2l0aCBwcm92aWRlZCBvcHRpb25zIHRvIGJlIG1hbmFnZWQgYnkgdGhlIGNvbnRyb2xsZXIuXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8uY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQob3B0aW9ucykge1xuICAgIHZhciBuZXdFbGVtZW50ID0gbmV3IEVsZW1lbnQoX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICAgIHNjcm9sbEF4aXM6IHRoaXMuc2Nyb2xsQXhpcyxcbiAgICAgIGRpc2FibGVkUGFyYWxsYXhDb250cm9sbGVyOiB0aGlzLmRpc2FibGVkXG4gICAgfSkpO1xuICAgIG5ld0VsZW1lbnQuc2V0Q2FjaGVkQXR0cmlidXRlcyh0aGlzLnZpZXcsIHRoaXMuc2Nyb2xsKTtcbiAgICB0aGlzLmVsZW1lbnRzID0gdGhpcy5lbGVtZW50cyA/IFtdLmNvbmNhdCh0aGlzLmVsZW1lbnRzLCBbbmV3RWxlbWVudF0pIDogW25ld0VsZW1lbnRdO1xuXG4gICAgdGhpcy5fdXBkYXRlRWxlbWVudFBvc2l0aW9uKG5ld0VsZW1lbnQpOyAvLyBOT1RFOiBUaGlzIGNoZWNrcyBpZiB0aGUgdmlldyBoYXMgY2hhbmdlZCB0aGVuIHVwZGF0ZSB0aGUgY29udHJvbGxlciBhbmQgYWxsIGVsZW1lbnRzIGlmIGl0IGhhc1xuICAgIC8vIFRoaXMgc2hvdWxkbid0IGFsd2F5cyBiZSBuZWNlc3Nhcnkgd2l0aCBhIHJlc2l6ZSBvYnNlcnZlciB3YXRjaGluZyB0aGUgdmlldyBlbGVtZW50XG4gICAgLy8gYnV0IHRoZXJlIHNlZW1zIHRvIGJlIGNhc2VzIHdoZXJlIHRoZSByZXNpemUgb2JzZXJ2ZXIgZG9lcyBub3QgY2F0Y2ggYW5kIHVwZGF0ZS5cblxuXG4gICAgaWYgKHRoaXMuX2NoZWNrSWZWaWV3SGFzQ2hhbmdlZCgpKSB7XG4gICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdFbGVtZW50O1xuICB9XG4gIC8qKlxyXG4gICAqIFJlbW92ZSBhbiBlbGVtZW50IGJ5IGlkXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVtb3ZlRWxlbWVudEJ5SWQgPSBmdW5jdGlvbiByZW1vdmVFbGVtZW50QnlJZChpZCkge1xuICAgIGlmICghdGhpcy5lbGVtZW50cykgcmV0dXJuO1xuICAgIHRoaXMuZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzLmZpbHRlcihmdW5jdGlvbiAoZWwpIHtcbiAgICAgIHJldHVybiBlbC5pZCAhPT0gaWQ7XG4gICAgfSk7XG4gIH1cbiAgLyoqXHJcbiAgICogVXBkYXRlcyBhbiBleGlzdGluZyBwYXJhbGxheCBlbGVtZW50IG9iamVjdCB3aXRoIG5ldyBvcHRpb25zLlxyXG4gICAqL1xuICA7XG5cbiAgX3Byb3RvLnVwZGF0ZUVsZW1lbnRQcm9wc0J5SWQgPSBmdW5jdGlvbiB1cGRhdGVFbGVtZW50UHJvcHNCeUlkKGlkLCBwcm9wcykge1xuICAgIGlmICh0aGlzLmVsZW1lbnRzKSB7XG4gICAgICB0aGlzLmVsZW1lbnRzID0gdGhpcy5lbGVtZW50cy5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIGlmIChlbC5pZCA9PT0gaWQpIHtcbiAgICAgICAgICByZXR1cm4gZWwudXBkYXRlUHJvcHMocHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICAvKipcclxuICAgKiBSZW1vdmUgYSB0YXJnZXQgZWxlbWVudHMgcGFyYWxsYXggc3R5bGVzXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8ucmVzZXRFbGVtZW50U3R5bGVzID0gZnVuY3Rpb24gcmVzZXRFbGVtZW50U3R5bGVzKGVsZW1lbnQpIHtcbiAgICByZXNldFN0eWxlcyhlbGVtZW50KTtcbiAgfVxuICAvKipcclxuICAgKiBVcGRhdGVzIGFsbCBjYWNoZWQgYXR0cmlidXRlcyBvbiBwYXJhbGxheCBlbGVtZW50cy5cclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by51cGRhdGUgPSBmdW5jdGlvbiB1cGRhdGUoKSB7XG4gICAgLy8gU2F2ZSB0aGUgbGF0ZXN0IHNjcm9sbCBwb3NpdGlvbiBiZWNhdXNlIHdpbmRvdy5zY3JvbGxcbiAgICAvLyBtYXkgYmUgY2FsbGVkIGFuZCB0aGUgaGFuZGxlIHNjcm9sbCBldmVudCBtYXkgbm90IGJlIGNhbGxlZC5cbiAgICB2YXIgX3RoaXMkX2dldFNjcm9sbFBvc2l0MyA9IHRoaXMuX2dldFNjcm9sbFBvc2l0aW9uKCksXG4gICAgICAgIG54ID0gX3RoaXMkX2dldFNjcm9sbFBvc2l0M1swXSxcbiAgICAgICAgbnkgPSBfdGhpcyRfZ2V0U2Nyb2xsUG9zaXQzWzFdO1xuXG4gICAgdGhpcy5zY3JvbGwuc2V0U2Nyb2xsKG54LCBueSk7XG5cbiAgICB0aGlzLl9zZXRWaWV3U2l6ZSgpO1xuXG4gICAgdGhpcy5fdXBkYXRlQWxsRWxlbWVudHMoe1xuICAgICAgdXBkYXRlQ2FjaGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBVcGRhdGVzIHRoZSBzY3JvbGwgY29udGFpbmVyIG9mIHRoZSBwYXJhbGxheCBjb250cm9sbGVyXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8udXBkYXRlU2Nyb2xsQ29udGFpbmVyID0gZnVuY3Rpb24gdXBkYXRlU2Nyb2xsQ29udGFpbmVyKGVsKSB7XG4gICAgLy8gcmVtb3ZlIGV4aXN0aW5nIGxpc3RlbmVycyB3aXRoIGN1cnJlbnQgZWwgZmlyc3RcbiAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnModGhpcy52aWV3RWwpO1xuXG4gICAgdGhpcy52aWV3RWwgPSBlbDtcbiAgICB0aGlzLl9oYXNTY3JvbGxDb250YWluZXIgPSAhIWVsO1xuICAgIHRoaXMudmlldyA9IG5ldyBWaWV3KHtcbiAgICAgIHdpZHRoOiAwLFxuICAgICAgaGVpZ2h0OiAwLFxuICAgICAgc2Nyb2xsV2lkdGg6IDAsXG4gICAgICBzY3JvbGxIZWlnaHQ6IDAsXG4gICAgICBzY3JvbGxDb250YWluZXI6IGVsXG4gICAgfSk7XG5cbiAgICB0aGlzLl9zZXRWaWV3U2l6ZSgpO1xuXG4gICAgdGhpcy5fYWRkTGlzdGVuZXJzKHRoaXMudmlld0VsKTtcblxuICAgIHRoaXMuX3VwZGF0ZUFsbEVsZW1lbnRzKHtcbiAgICAgIHVwZGF0ZUNhY2hlOiB0cnVlXG4gICAgfSk7XG4gIH07XG5cbiAgX3Byb3RvLmRpc2FibGVQYXJhbGxheENvbnRyb2xsZXIgPSBmdW5jdGlvbiBkaXNhYmxlUGFyYWxsYXhDb250cm9sbGVyKCkge1xuICAgIHRoaXMuZGlzYWJsZWQgPSB0cnVlOyAvLyByZW1vdmUgbGlzdGVuZXJzXG5cbiAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnModGhpcy52aWV3RWwpOyAvLyByZXNldCBhbGwgc3R5bGVzXG5cblxuICAgIGlmICh0aGlzLmVsZW1lbnRzKSB7XG4gICAgICB0aGlzLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHJlc2V0U3R5bGVzKGVsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIF9wcm90by5lbmFibGVQYXJhbGxheENvbnRyb2xsZXIgPSBmdW5jdGlvbiBlbmFibGVQYXJhbGxheENvbnRyb2xsZXIoKSB7XG4gICAgdmFyIF90aGlzNCA9IHRoaXM7XG5cbiAgICB0aGlzLmRpc2FibGVkID0gZmFsc2U7XG5cbiAgICBpZiAodGhpcy5lbGVtZW50cykge1xuICAgICAgdGhpcy5lbGVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50LnVwZGF0ZUVsZW1lbnRPcHRpb25zKHtcbiAgICAgICAgICBkaXNhYmxlZFBhcmFsbGF4Q29udHJvbGxlcjogZmFsc2UsXG4gICAgICAgICAgc2Nyb2xsQXhpczogX3RoaXM0LnNjcm9sbEF4aXNcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IC8vIGFkZCBiYWNrIGxpc3RlbmVyc1xuXG5cbiAgICB0aGlzLl9hZGRMaXN0ZW5lcnModGhpcy52aWV3RWwpO1xuXG4gICAgdGhpcy5fYWRkUmVzaXplT2JzZXJ2ZXIoKTtcblxuICAgIHRoaXMuX3NldFZpZXdTaXplKCk7XG4gIH1cbiAgLyoqXHJcbiAgICogRGlzYWJsZSBhbGwgcGFyYWxsYXggZWxlbWVudHNcclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5kaXNhYmxlQWxsRWxlbWVudHMgPSBmdW5jdGlvbiBkaXNhYmxlQWxsRWxlbWVudHMoKSB7XG4gICAgY29uc29sZS53YXJuKCdkZXByZWNhdGVkOiB1c2UgZGlzYWJsZVBhcmFsbGF4Q29udHJvbGxlcigpIGluc3RlYWQnKTtcblxuICAgIGlmICh0aGlzLmVsZW1lbnRzKSB7XG4gICAgICB0aGlzLmVsZW1lbnRzID0gdGhpcy5lbGVtZW50cy5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiBlbC51cGRhdGVQcm9wcyh7XG4gICAgICAgICAgZGlzYWJsZWQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZSgpO1xuICB9XG4gIC8qKlxyXG4gICAqIEVuYWJsZSBhbGwgcGFyYWxsYXggZWxlbWVudHNcclxuICAgKi9cbiAgO1xuXG4gIF9wcm90by5lbmFibGVBbGxFbGVtZW50cyA9IGZ1bmN0aW9uIGVuYWJsZUFsbEVsZW1lbnRzKCkge1xuICAgIGNvbnNvbGUud2FybignZGVwcmVjYXRlZDogdXNlIGVuYWJsZVBhcmFsbGF4Q29udHJvbGxlcigpIGluc3RlYWQnKTtcblxuICAgIGlmICh0aGlzLmVsZW1lbnRzKSB7XG4gICAgICB0aGlzLmVsZW1lbnRzID0gdGhpcy5lbGVtZW50cy5tYXAoZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgIHJldHVybiBlbC51cGRhdGVQcm9wcyh7XG4gICAgICAgICAgZGlzYWJsZWQ6IGZhbHNlXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy51cGRhdGUoKTtcbiAgfVxuICAvKipcclxuICAgKiBSZW1vdmVzIGFsbCBsaXN0ZW5lcnMgYW5kIHJlc2V0cyBhbGwgc3R5bGVzIG9uIG1hbmFnZWQgZWxlbWVudHMuXHJcbiAgICovXG4gIDtcblxuICBfcHJvdG8uZGVzdHJveSA9IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzKHRoaXMudmlld0VsKTtcblxuICAgIGlmICh0aGlzLmVsZW1lbnRzKSB7XG4gICAgICB0aGlzLmVsZW1lbnRzLmZvckVhY2goZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHJlc2V0U3R5bGVzKGVsZW1lbnQpO1xuICAgICAgfSk7XG4gICAgfSAvLyBAdHMtZXhwZWN0LWVycm9yXG5cblxuICAgIHRoaXMuZWxlbWVudHMgPSB1bmRlZmluZWQ7XG4gIH07XG5cbiAgcmV0dXJuIFBhcmFsbGF4Q29udHJvbGxlcjtcbn0oKTtcblxuZXhwb3J0IHsgRWFzaW5nUHJlc2V0LCBFbGVtZW50LCBMaW1pdHMsIFBhcmFsbGF4Q29udHJvbGxlciwgUmVjdCwgUm90YXRpb25Vbml0cywgU2NhbGVVbml0cywgU2Nyb2xsLCBTY3JvbGxBeGlzLCBVbml0cywgVmFsaWRDU1NFZmZlY3RzLCBWaWV3LCBjcmVhdGVJZCwgZ2V0UHJvZ3Jlc3NBbW91bnQsIGlzRWxlbWVudEluVmlldywgcGFyc2VFbGVtZW50VHJhbnNpdGlvbkVmZmVjdHMsIHBhcnNlVmFsdWVBbmRVbml0LCByZXNldFN0eWxlcywgc2NhbGVCZXR3ZWVuLCBzY2FsZUVmZmVjdEJ5UHJvZ3Jlc3MsIHNldEVsZW1lbnRTdHlsZXMsIHRlc3RGb3JQYXNzaXZlU2Nyb2xsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYXJhbGxheC1jb250cm9sbGVyLmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/parallax-controller/dist/parallax-controller.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-scroll-parallax/dist/react-scroll-parallax.esm.js":
/*!******************************************************************************!*\
  !*** ./node_modules/react-scroll-parallax/dist/react-scroll-parallax.esm.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EasingPreset: () => (/* reexport safe */ parallax_controller__WEBPACK_IMPORTED_MODULE_0__.EasingPreset),\n/* harmony export */   Parallax: () => (/* binding */ Parallax),\n/* harmony export */   ParallaxBanner: () => (/* binding */ ParallaxBanner),\n/* harmony export */   ParallaxBannerLayer: () => (/* binding */ ParallaxBannerLayer),\n/* harmony export */   ParallaxContext: () => (/* binding */ ParallaxContext),\n/* harmony export */   ParallaxProvider: () => (/* binding */ ParallaxProvider),\n/* harmony export */   useParallax: () => (/* binding */ useParallax),\n/* harmony export */   useParallaxController: () => (/* binding */ useParallaxController)\n/* harmony export */ });\n/* harmony import */ var parallax_controller__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! parallax-controller */ \"(app-pages-browser)/./node_modules/parallax-controller/dist/parallax-controller.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\n\nfunction _extends() {\n  _extends = Object.assign || function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n\n    return target;\n  };\n\n  return _extends.apply(this, arguments);\n}\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction removeUndefinedObjectKeys(obj) {\n  Object.keys(obj).forEach(function (key) {\n    return obj[key] === undefined && delete obj[key];\n  });\n  return obj;\n}\n\nvar _excluded = [\"disabled\", \"easing\", \"endScroll\", \"onChange\", \"onEnter\", \"onExit\", \"onProgressChange\", \"opacity\", \"rootMargin\", \"rotate\", \"rotateX\", \"rotateY\", \"rotateZ\", \"scale\", \"scaleX\", \"scaleY\", \"scaleZ\", \"shouldAlwaysCompleteAnimation\", \"shouldDisableScalingTranslations\", \"speed\", \"startScroll\", \"targetElement\", \"translateX\", \"translateY\"];\nfunction getIsolatedParallaxProps(props) {\n  var disabled = props.disabled,\n      easing = props.easing,\n      endScroll = props.endScroll,\n      onChange = props.onChange,\n      onEnter = props.onEnter,\n      onExit = props.onExit,\n      onProgressChange = props.onProgressChange,\n      opacity = props.opacity,\n      rootMargin = props.rootMargin,\n      rotate = props.rotate,\n      rotateX = props.rotateX,\n      rotateY = props.rotateY,\n      rotateZ = props.rotateZ,\n      scale = props.scale,\n      scaleX = props.scaleX,\n      scaleY = props.scaleY,\n      scaleZ = props.scaleZ,\n      shouldAlwaysCompleteAnimation = props.shouldAlwaysCompleteAnimation,\n      shouldDisableScalingTranslations = props.shouldDisableScalingTranslations,\n      speed = props.speed,\n      startScroll = props.startScroll,\n      targetElement = props.targetElement,\n      translateX = props.translateX,\n      translateY = props.translateY,\n      rest = _objectWithoutPropertiesLoose(props, _excluded);\n\n  var parallaxProps = removeUndefinedObjectKeys({\n    disabled: disabled,\n    easing: easing,\n    endScroll: endScroll,\n    onChange: onChange,\n    onEnter: onEnter,\n    onExit: onExit,\n    onProgressChange: onProgressChange,\n    opacity: opacity,\n    rootMargin: rootMargin,\n    rotate: rotate,\n    rotateX: rotateX,\n    rotateY: rotateY,\n    rotateZ: rotateZ,\n    scale: scale,\n    scaleX: scaleX,\n    scaleY: scaleY,\n    scaleZ: scaleZ,\n    shouldAlwaysCompleteAnimation: shouldAlwaysCompleteAnimation,\n    shouldDisableScalingTranslations: shouldDisableScalingTranslations,\n    speed: speed,\n    startScroll: startScroll,\n    targetElement: targetElement,\n    translateX: translateX,\n    translateY: translateY\n  });\n  return {\n    parallaxProps: parallaxProps,\n    rest: rest\n  };\n}\n\nfunction useVerifyController(controller) {\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n    var isServer = typeof window === 'undefined'; // Make sure the provided controller is an instance of the Parallax Controller\n\n    var isInstance = controller instanceof parallax_controller__WEBPACK_IMPORTED_MODULE_0__.ParallaxController; // Throw if neither context or global is available\n\n    if (!isServer && !controller && !isInstance) {\n      throw new Error(\"Must wrap your application's <Parallax /> components in a <ParallaxProvider />.\");\n    }\n  }, [controller]);\n}\n\nvar ParallaxContext = /*#__PURE__*/react__WEBPACK_IMPORTED_MODULE_1___default().createContext(null);\n\nfunction useParallaxController() {\n  var parallaxController = (0,react__WEBPACK_IMPORTED_MODULE_1__.useContext)(ParallaxContext);\n  var isServer = typeof window === 'undefined';\n\n  if (isServer) {\n    return null;\n  }\n\n  if (!parallaxController) {\n    throw new Error('Could not find `react-scroll-parallax` context value. Please ensure the component is wrapped in a <ParallaxProvider>');\n  }\n\n  return parallaxController;\n}\n\nfunction useParallax(props) {\n  var controller = useParallaxController();\n  var ref = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n\n  var _getIsolatedParallaxP = getIsolatedParallaxProps(props),\n      parallaxProps = _getIsolatedParallaxP.parallaxProps;\n\n  useVerifyController(controller);\n\n  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(),\n      element = _useState[0],\n      setElement = _useState[1]; // create element\n\n\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n    var newElement;\n\n    if (ref.current instanceof HTMLElement) {\n      var options = {\n        el: ref.current,\n        props: parallaxProps\n      };\n      newElement = controller == null ? void 0 : controller.createElement(options);\n      setElement(newElement);\n    } else {\n      throw new Error('You must assign the ref returned by the useParallax() hook to an HTML Element.');\n    }\n\n    return function () {\n      if (newElement) {\n        controller == null ? void 0 : controller.removeElementById(newElement.id);\n      }\n    };\n  }, []); // update element\n\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n    if (element) {\n      if (props.disabled) {\n        controller == null ? void 0 : controller.resetElementStyles(element);\n        controller == null ? void 0 : controller.updateElementPropsById(element.id, parallaxProps);\n      } else {\n        controller == null ? void 0 : controller.updateElementPropsById(element.id, parallaxProps);\n      }\n    }\n  }, [props.disabled, props.easing, props.endScroll, props.onChange, props.onEnter, props.onExit, props.onProgressChange, props.opacity, props.rootMargin, props.rotate, props.rotateX, props.rotateY, props.rotateZ, props.scale, props.scaleX, props.scaleY, props.scaleZ, props.shouldAlwaysCompleteAnimation, props.shouldDisableScalingTranslations, props.speed, props.startScroll, props.targetElement, props.translateX, props.translateY]);\n  return {\n    ref: ref,\n    controller: controller,\n    element: element\n  };\n}\n\nfunction Parallax(props) {\n  var _getIsolatedParallaxP = getIsolatedParallaxProps(props),\n      parallaxProps = _getIsolatedParallaxP.parallaxProps,\n      rest = _getIsolatedParallaxP.rest;\n\n  var _useParallax = useParallax(parallaxProps),\n      ref = _useParallax.ref;\n\n  return react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", Object.assign({\n    ref: ref\n  }, rest), props.children);\n}\n\nvar FALLBACK_RECT = {\n  height: 0\n};\nfunction getExpandedStyle(layer) {\n  if (Array.isArray(layer.translateY)) {\n    var translateYStart = (0,parallax_controller__WEBPACK_IMPORTED_MODULE_0__.parseValueAndUnit)(layer.translateY[0]);\n    var translateYEnd = (0,parallax_controller__WEBPACK_IMPORTED_MODULE_0__.parseValueAndUnit)(layer.translateY[1]);\n\n    if (translateYStart.unit === 'px' && translateYEnd.unit === 'px') {\n      return {\n        top: Math.abs(translateYEnd.value) * -1 + \"px\",\n        bottom: Math.abs(translateYStart.value) * -1 + \"px\"\n      };\n    }\n\n    if (translateYStart.unit === '%' && translateYEnd.unit === '%') {\n      var _layer$targetElement$, _layer$targetElement;\n\n      var clientRect = (_layer$targetElement$ = (_layer$targetElement = layer.targetElement) == null ? void 0 : _layer$targetElement.getBoundingClientRect()) != null ? _layer$targetElement$ : FALLBACK_RECT;\n      var top = Math.abs(clientRect.height * 0.01 * translateYEnd.value) * -1;\n      var bottom = Math.abs(clientRect.height * 0.01 * translateYStart.value) * -1;\n      return {\n        top: top + \"px\",\n        bottom: bottom + \"px\"\n      };\n    }\n  }\n\n  if (layer.speed) {\n    var speed = layer.speed || 0;\n    var absSpeed = Math.abs(speed) * 10 * -1;\n    return {\n      top: absSpeed + \"px\",\n      bottom: absSpeed + \"px\"\n    };\n  }\n\n  return {};\n}\n\nfunction getImageStyle(layer) {\n  return layer.image ? {\n    backgroundImage: \"url(\" + layer.image + \")\",\n    backgroundPosition: 'center',\n    backgroundSize: 'cover'\n  } : {};\n}\n\nvar _excluded$1 = [\"children\", \"disabled\", \"style\", \"expanded\", \"image\", \"testId\"];\nvar absoluteStyle = {\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  right: 0,\n  bottom: 0\n};\nvar ParallaxBannerLayer = function ParallaxBannerLayer(props) {\n  var _getIsolatedParallaxP = getIsolatedParallaxProps(props),\n      parallaxProps = _getIsolatedParallaxP.parallaxProps,\n      rest = _getIsolatedParallaxP.rest;\n\n  var style = rest.style,\n      _rest$expanded = rest.expanded,\n      expanded = _rest$expanded === void 0 ? true : _rest$expanded,\n      testId = rest.testId,\n      divProps = _objectWithoutPropertiesLoose(rest, _excluded$1);\n\n  var imageStyle = getImageStyle(props);\n  var expandedStyle = expanded ? getExpandedStyle(props) : {};\n  var parallax = useParallax(_extends({\n    targetElement: props.targetElement,\n    shouldDisableScalingTranslations: true\n  }, parallaxProps));\n  return react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", Object.assign({\n    \"data-testid\": testId,\n    ref: parallax.ref,\n    style: _extends({}, imageStyle, absoluteStyle, expandedStyle, style)\n  }, divProps), rest.children);\n};\n\nvar _excluded$2 = [\"disabled\", \"style\", \"layers\"];\nvar containerStyle = {\n  position: 'relative',\n  overflow: 'hidden',\n  width: '100%'\n};\nvar ParallaxBanner = function ParallaxBanner(props) {\n  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null),\n      targetElement = _useState[0],\n      setTargetElement = _useState[1];\n\n  var containerRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n    setTargetElement(containerRef.current);\n  }, []);\n\n  var rootStyle = props.style,\n      _props$layers = props.layers,\n      layers = _props$layers === void 0 ? [] : _props$layers,\n      rootRest = _objectWithoutPropertiesLoose(props, _excluded$2);\n\n  function renderLayers() {\n    if (targetElement) {\n      var shouldUseLayers = layers && layers.length > 0;\n\n      if (shouldUseLayers) {\n        return layers.map(function (layer, i) {\n          return react__WEBPACK_IMPORTED_MODULE_1___default().createElement(ParallaxBannerLayer, Object.assign({}, layer, {\n            targetElement: targetElement,\n            key: \"layer-\" + i,\n            testId: \"layer-\" + i\n          }));\n        });\n      }\n    }\n\n    return null;\n  }\n\n  function renderChildren() {\n    if (targetElement) {\n      return react__WEBPACK_IMPORTED_MODULE_1___default().Children.map(props.children, function (child) {\n        var item = child; // adds the targetElement prop to any ParallaxBannerLayer components\n\n        if ((item == null ? void 0 : item.type) === ParallaxBannerLayer) {\n          var clone = react__WEBPACK_IMPORTED_MODULE_1___default().cloneElement(item, {\n            targetElement: targetElement\n          });\n          return clone;\n        }\n\n        return child;\n      });\n    }\n\n    return null;\n  }\n\n  return react__WEBPACK_IMPORTED_MODULE_1___default().createElement(\"div\", Object.assign({\n    ref: containerRef,\n    style: _extends({}, containerStyle, rootStyle)\n  }, rootRest), renderLayers(), renderChildren());\n};\n\nvar createController = function createController(options) {\n  // Don't initialize on the server\n  var isServer = typeof window === 'undefined';\n\n  if (!isServer) {\n    // Must not be the server so kick it off...\n    return parallax_controller__WEBPACK_IMPORTED_MODULE_0__.ParallaxController.init(options);\n  }\n\n  return null;\n};\n\nfunction ParallaxProvider(props) {\n  var controller = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n\n  if (!controller.current) {\n    controller.current = createController({\n      scrollAxis: props.scrollAxis || parallax_controller__WEBPACK_IMPORTED_MODULE_0__.ScrollAxis.vertical,\n      scrollContainer: props.scrollContainer,\n      disabled: props.isDisabled\n    });\n  } // update scroll container\n\n\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n    if (props.scrollContainer && controller.current) {\n      controller.current.updateScrollContainer(props.scrollContainer);\n    }\n  }, [props.scrollContainer, controller.current]); // disable/enable parallax\n\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n    if (props.isDisabled && controller.current) {\n      controller.current.disableParallaxController();\n    }\n\n    if (!props.isDisabled && controller.current) {\n      controller.current.enableParallaxController();\n    }\n  }, [props.isDisabled, controller.current]); // remove the controller when unmounting\n\n  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(function () {\n    return function () {\n      (controller == null ? void 0 : controller.current) && (controller == null ? void 0 : controller.current.destroy());\n    };\n  }, []);\n  return react__WEBPACK_IMPORTED_MODULE_1___default().createElement(ParallaxContext.Provider, {\n    value: controller.current\n  }, props.children);\n}\n\n\n//# sourceMappingURL=react-scroll-parallax.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1zY3JvbGwtcGFyYWxsYXgvZGlzdC9yZWFjdC1zY3JvbGwtcGFyYWxsYXguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXdGO0FBQ3JDO0FBQ29COztBQUV2RTtBQUNBO0FBQ0Esb0JBQW9CLHNCQUFzQjtBQUMxQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUUsZ0RBQVM7QUFDWCxrREFBa0Q7O0FBRWxELDJDQUEyQyxtRUFBa0IsRUFBRTs7QUFFL0Q7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLG1DQUFtQywwREFBbUI7O0FBRXREO0FBQ0EsMkJBQTJCLGlEQUFVO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSw2Q0FBTTs7QUFFbEI7QUFDQTs7QUFFQTs7QUFFQSxrQkFBa0IsK0NBQVE7QUFDMUI7QUFDQSxpQ0FBaUM7OztBQUdqQyxFQUFFLGdEQUFTO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxPQUFPOztBQUVWLEVBQUUsZ0RBQVM7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsU0FBUywwREFBbUI7QUFDNUI7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixzRUFBaUI7QUFDM0Msd0JBQXdCLHNFQUFpQjs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsU0FBUywwREFBbUI7QUFDNUI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsK0NBQVE7QUFDMUI7QUFDQTs7QUFFQSxxQkFBcUIsNkNBQU07QUFDM0IsRUFBRSxnREFBUztBQUNYO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQiwwREFBbUIsc0NBQXNDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHFEQUFjO0FBQzNCLDBCQUEwQjs7QUFFMUI7QUFDQSxzQkFBc0IseURBQWtCO0FBQ3hDO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQSxTQUFTLDBEQUFtQjtBQUM1QjtBQUNBLHNCQUFzQjtBQUN0QixHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLG1FQUFrQjtBQUM3Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLDZDQUFNOztBQUV6QjtBQUNBO0FBQ0Esc0NBQXNDLDJEQUFVO0FBQ2hEO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTs7O0FBR0osRUFBRSxnREFBUztBQUNYO0FBQ0E7QUFDQTtBQUNBLEdBQUcsZ0RBQWdEOztBQUVuRCxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsMkNBQTJDOztBQUU5QyxFQUFFLGdEQUFTO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFNBQVMsMERBQW1CO0FBQzVCO0FBQ0EsR0FBRztBQUNIOztBQUVnSTtBQUNoSSIsInNvdXJjZXMiOlsiL1VzZXJzL212ZW50dXJhL0RvY3VtZW50cy9HaXRIdWIvbW9ycGhlL25vZGVfbW9kdWxlcy9yZWFjdC1zY3JvbGwtcGFyYWxsYXgvZGlzdC9yZWFjdC1zY3JvbGwtcGFyYWxsYXguZXNtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBhcmFsbGF4Q29udHJvbGxlciwgcGFyc2VWYWx1ZUFuZFVuaXQsIFNjcm9sbEF4aXMgfSBmcm9tICdwYXJhbGxheC1jb250cm9sbGVyJztcbmV4cG9ydCB7IEVhc2luZ1ByZXNldCB9IGZyb20gJ3BhcmFsbGF4LWNvbnRyb2xsZXInO1xuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlQ29udGV4dCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcblxuZnVuY3Rpb24gX2V4dGVuZHMoKSB7XG4gIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfTtcblxuICByZXR1cm4gX2V4dGVuZHMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVVuZGVmaW5lZE9iamVjdEtleXMob2JqKSB7XG4gIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIG9ialtrZXldID09PSB1bmRlZmluZWQgJiYgZGVsZXRlIG9ialtrZXldO1xuICB9KTtcbiAgcmV0dXJuIG9iajtcbn1cblxudmFyIF9leGNsdWRlZCA9IFtcImRpc2FibGVkXCIsIFwiZWFzaW5nXCIsIFwiZW5kU2Nyb2xsXCIsIFwib25DaGFuZ2VcIiwgXCJvbkVudGVyXCIsIFwib25FeGl0XCIsIFwib25Qcm9ncmVzc0NoYW5nZVwiLCBcIm9wYWNpdHlcIiwgXCJyb290TWFyZ2luXCIsIFwicm90YXRlXCIsIFwicm90YXRlWFwiLCBcInJvdGF0ZVlcIiwgXCJyb3RhdGVaXCIsIFwic2NhbGVcIiwgXCJzY2FsZVhcIiwgXCJzY2FsZVlcIiwgXCJzY2FsZVpcIiwgXCJzaG91bGRBbHdheXNDb21wbGV0ZUFuaW1hdGlvblwiLCBcInNob3VsZERpc2FibGVTY2FsaW5nVHJhbnNsYXRpb25zXCIsIFwic3BlZWRcIiwgXCJzdGFydFNjcm9sbFwiLCBcInRhcmdldEVsZW1lbnRcIiwgXCJ0cmFuc2xhdGVYXCIsIFwidHJhbnNsYXRlWVwiXTtcbmZ1bmN0aW9uIGdldElzb2xhdGVkUGFyYWxsYXhQcm9wcyhwcm9wcykge1xuICB2YXIgZGlzYWJsZWQgPSBwcm9wcy5kaXNhYmxlZCxcbiAgICAgIGVhc2luZyA9IHByb3BzLmVhc2luZyxcbiAgICAgIGVuZFNjcm9sbCA9IHByb3BzLmVuZFNjcm9sbCxcbiAgICAgIG9uQ2hhbmdlID0gcHJvcHMub25DaGFuZ2UsXG4gICAgICBvbkVudGVyID0gcHJvcHMub25FbnRlcixcbiAgICAgIG9uRXhpdCA9IHByb3BzLm9uRXhpdCxcbiAgICAgIG9uUHJvZ3Jlc3NDaGFuZ2UgPSBwcm9wcy5vblByb2dyZXNzQ2hhbmdlLFxuICAgICAgb3BhY2l0eSA9IHByb3BzLm9wYWNpdHksXG4gICAgICByb290TWFyZ2luID0gcHJvcHMucm9vdE1hcmdpbixcbiAgICAgIHJvdGF0ZSA9IHByb3BzLnJvdGF0ZSxcbiAgICAgIHJvdGF0ZVggPSBwcm9wcy5yb3RhdGVYLFxuICAgICAgcm90YXRlWSA9IHByb3BzLnJvdGF0ZVksXG4gICAgICByb3RhdGVaID0gcHJvcHMucm90YXRlWixcbiAgICAgIHNjYWxlID0gcHJvcHMuc2NhbGUsXG4gICAgICBzY2FsZVggPSBwcm9wcy5zY2FsZVgsXG4gICAgICBzY2FsZVkgPSBwcm9wcy5zY2FsZVksXG4gICAgICBzY2FsZVogPSBwcm9wcy5zY2FsZVosXG4gICAgICBzaG91bGRBbHdheXNDb21wbGV0ZUFuaW1hdGlvbiA9IHByb3BzLnNob3VsZEFsd2F5c0NvbXBsZXRlQW5pbWF0aW9uLFxuICAgICAgc2hvdWxkRGlzYWJsZVNjYWxpbmdUcmFuc2xhdGlvbnMgPSBwcm9wcy5zaG91bGREaXNhYmxlU2NhbGluZ1RyYW5zbGF0aW9ucyxcbiAgICAgIHNwZWVkID0gcHJvcHMuc3BlZWQsXG4gICAgICBzdGFydFNjcm9sbCA9IHByb3BzLnN0YXJ0U2Nyb2xsLFxuICAgICAgdGFyZ2V0RWxlbWVudCA9IHByb3BzLnRhcmdldEVsZW1lbnQsXG4gICAgICB0cmFuc2xhdGVYID0gcHJvcHMudHJhbnNsYXRlWCxcbiAgICAgIHRyYW5zbGF0ZVkgPSBwcm9wcy50cmFuc2xhdGVZLFxuICAgICAgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQpO1xuXG4gIHZhciBwYXJhbGxheFByb3BzID0gcmVtb3ZlVW5kZWZpbmVkT2JqZWN0S2V5cyh7XG4gICAgZGlzYWJsZWQ6IGRpc2FibGVkLFxuICAgIGVhc2luZzogZWFzaW5nLFxuICAgIGVuZFNjcm9sbDogZW5kU2Nyb2xsLFxuICAgIG9uQ2hhbmdlOiBvbkNoYW5nZSxcbiAgICBvbkVudGVyOiBvbkVudGVyLFxuICAgIG9uRXhpdDogb25FeGl0LFxuICAgIG9uUHJvZ3Jlc3NDaGFuZ2U6IG9uUHJvZ3Jlc3NDaGFuZ2UsXG4gICAgb3BhY2l0eTogb3BhY2l0eSxcbiAgICByb290TWFyZ2luOiByb290TWFyZ2luLFxuICAgIHJvdGF0ZTogcm90YXRlLFxuICAgIHJvdGF0ZVg6IHJvdGF0ZVgsXG4gICAgcm90YXRlWTogcm90YXRlWSxcbiAgICByb3RhdGVaOiByb3RhdGVaLFxuICAgIHNjYWxlOiBzY2FsZSxcbiAgICBzY2FsZVg6IHNjYWxlWCxcbiAgICBzY2FsZVk6IHNjYWxlWSxcbiAgICBzY2FsZVo6IHNjYWxlWixcbiAgICBzaG91bGRBbHdheXNDb21wbGV0ZUFuaW1hdGlvbjogc2hvdWxkQWx3YXlzQ29tcGxldGVBbmltYXRpb24sXG4gICAgc2hvdWxkRGlzYWJsZVNjYWxpbmdUcmFuc2xhdGlvbnM6IHNob3VsZERpc2FibGVTY2FsaW5nVHJhbnNsYXRpb25zLFxuICAgIHNwZWVkOiBzcGVlZCxcbiAgICBzdGFydFNjcm9sbDogc3RhcnRTY3JvbGwsXG4gICAgdGFyZ2V0RWxlbWVudDogdGFyZ2V0RWxlbWVudCxcbiAgICB0cmFuc2xhdGVYOiB0cmFuc2xhdGVYLFxuICAgIHRyYW5zbGF0ZVk6IHRyYW5zbGF0ZVlcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcGFyYWxsYXhQcm9wczogcGFyYWxsYXhQcm9wcyxcbiAgICByZXN0OiByZXN0XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVzZVZlcmlmeUNvbnRyb2xsZXIoY29udHJvbGxlcikge1xuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIHZhciBpc1NlcnZlciA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnOyAvLyBNYWtlIHN1cmUgdGhlIHByb3ZpZGVkIGNvbnRyb2xsZXIgaXMgYW4gaW5zdGFuY2Ugb2YgdGhlIFBhcmFsbGF4IENvbnRyb2xsZXJcblxuICAgIHZhciBpc0luc3RhbmNlID0gY29udHJvbGxlciBpbnN0YW5jZW9mIFBhcmFsbGF4Q29udHJvbGxlcjsgLy8gVGhyb3cgaWYgbmVpdGhlciBjb250ZXh0IG9yIGdsb2JhbCBpcyBhdmFpbGFibGVcblxuICAgIGlmICghaXNTZXJ2ZXIgJiYgIWNvbnRyb2xsZXIgJiYgIWlzSW5zdGFuY2UpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk11c3Qgd3JhcCB5b3VyIGFwcGxpY2F0aW9uJ3MgPFBhcmFsbGF4IC8+IGNvbXBvbmVudHMgaW4gYSA8UGFyYWxsYXhQcm92aWRlciAvPi5cIik7XG4gICAgfVxuICB9LCBbY29udHJvbGxlcl0pO1xufVxuXG52YXIgUGFyYWxsYXhDb250ZXh0ID0gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5cbmZ1bmN0aW9uIHVzZVBhcmFsbGF4Q29udHJvbGxlcigpIHtcbiAgdmFyIHBhcmFsbGF4Q29udHJvbGxlciA9IHVzZUNvbnRleHQoUGFyYWxsYXhDb250ZXh0KTtcbiAgdmFyIGlzU2VydmVyID0gdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCc7XG5cbiAgaWYgKGlzU2VydmVyKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoIXBhcmFsbGF4Q29udHJvbGxlcikge1xuICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgYHJlYWN0LXNjcm9sbC1wYXJhbGxheGAgY29udGV4dCB2YWx1ZS4gUGxlYXNlIGVuc3VyZSB0aGUgY29tcG9uZW50IGlzIHdyYXBwZWQgaW4gYSA8UGFyYWxsYXhQcm92aWRlcj4nKTtcbiAgfVxuXG4gIHJldHVybiBwYXJhbGxheENvbnRyb2xsZXI7XG59XG5cbmZ1bmN0aW9uIHVzZVBhcmFsbGF4KHByb3BzKSB7XG4gIHZhciBjb250cm9sbGVyID0gdXNlUGFyYWxsYXhDb250cm9sbGVyKCk7XG4gIHZhciByZWYgPSB1c2VSZWYobnVsbCk7XG5cbiAgdmFyIF9nZXRJc29sYXRlZFBhcmFsbGF4UCA9IGdldElzb2xhdGVkUGFyYWxsYXhQcm9wcyhwcm9wcyksXG4gICAgICBwYXJhbGxheFByb3BzID0gX2dldElzb2xhdGVkUGFyYWxsYXhQLnBhcmFsbGF4UHJvcHM7XG5cbiAgdXNlVmVyaWZ5Q29udHJvbGxlcihjb250cm9sbGVyKTtcblxuICB2YXIgX3VzZVN0YXRlID0gdXNlU3RhdGUoKSxcbiAgICAgIGVsZW1lbnQgPSBfdXNlU3RhdGVbMF0sXG4gICAgICBzZXRFbGVtZW50ID0gX3VzZVN0YXRlWzFdOyAvLyBjcmVhdGUgZWxlbWVudFxuXG5cbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbmV3RWxlbWVudDtcblxuICAgIGlmIChyZWYuY3VycmVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHtcbiAgICAgICAgZWw6IHJlZi5jdXJyZW50LFxuICAgICAgICBwcm9wczogcGFyYWxsYXhQcm9wc1xuICAgICAgfTtcbiAgICAgIG5ld0VsZW1lbnQgPSBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmNyZWF0ZUVsZW1lbnQob3B0aW9ucyk7XG4gICAgICBzZXRFbGVtZW50KG5ld0VsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBtdXN0IGFzc2lnbiB0aGUgcmVmIHJldHVybmVkIGJ5IHRoZSB1c2VQYXJhbGxheCgpIGhvb2sgdG8gYW4gSFRNTCBFbGVtZW50LicpO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAobmV3RWxlbWVudCkge1xuICAgICAgICBjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLnJlbW92ZUVsZW1lbnRCeUlkKG5ld0VsZW1lbnQuaWQpO1xuICAgICAgfVxuICAgIH07XG4gIH0sIFtdKTsgLy8gdXBkYXRlIGVsZW1lbnRcblxuICB1c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICBpZiAocHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5yZXNldEVsZW1lbnRTdHlsZXMoZWxlbWVudCk7XG4gICAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIudXBkYXRlRWxlbWVudFByb3BzQnlJZChlbGVtZW50LmlkLCBwYXJhbGxheFByb3BzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIudXBkYXRlRWxlbWVudFByb3BzQnlJZChlbGVtZW50LmlkLCBwYXJhbGxheFByb3BzKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sIFtwcm9wcy5kaXNhYmxlZCwgcHJvcHMuZWFzaW5nLCBwcm9wcy5lbmRTY3JvbGwsIHByb3BzLm9uQ2hhbmdlLCBwcm9wcy5vbkVudGVyLCBwcm9wcy5vbkV4aXQsIHByb3BzLm9uUHJvZ3Jlc3NDaGFuZ2UsIHByb3BzLm9wYWNpdHksIHByb3BzLnJvb3RNYXJnaW4sIHByb3BzLnJvdGF0ZSwgcHJvcHMucm90YXRlWCwgcHJvcHMucm90YXRlWSwgcHJvcHMucm90YXRlWiwgcHJvcHMuc2NhbGUsIHByb3BzLnNjYWxlWCwgcHJvcHMuc2NhbGVZLCBwcm9wcy5zY2FsZVosIHByb3BzLnNob3VsZEFsd2F5c0NvbXBsZXRlQW5pbWF0aW9uLCBwcm9wcy5zaG91bGREaXNhYmxlU2NhbGluZ1RyYW5zbGF0aW9ucywgcHJvcHMuc3BlZWQsIHByb3BzLnN0YXJ0U2Nyb2xsLCBwcm9wcy50YXJnZXRFbGVtZW50LCBwcm9wcy50cmFuc2xhdGVYLCBwcm9wcy50cmFuc2xhdGVZXSk7XG4gIHJldHVybiB7XG4gICAgcmVmOiByZWYsXG4gICAgY29udHJvbGxlcjogY29udHJvbGxlcixcbiAgICBlbGVtZW50OiBlbGVtZW50XG4gIH07XG59XG5cbmZ1bmN0aW9uIFBhcmFsbGF4KHByb3BzKSB7XG4gIHZhciBfZ2V0SXNvbGF0ZWRQYXJhbGxheFAgPSBnZXRJc29sYXRlZFBhcmFsbGF4UHJvcHMocHJvcHMpLFxuICAgICAgcGFyYWxsYXhQcm9wcyA9IF9nZXRJc29sYXRlZFBhcmFsbGF4UC5wYXJhbGxheFByb3BzLFxuICAgICAgcmVzdCA9IF9nZXRJc29sYXRlZFBhcmFsbGF4UC5yZXN0O1xuXG4gIHZhciBfdXNlUGFyYWxsYXggPSB1c2VQYXJhbGxheChwYXJhbGxheFByb3BzKSxcbiAgICAgIHJlZiA9IF91c2VQYXJhbGxheC5yZWY7XG5cbiAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgT2JqZWN0LmFzc2lnbih7XG4gICAgcmVmOiByZWZcbiAgfSwgcmVzdCksIHByb3BzLmNoaWxkcmVuKTtcbn1cblxudmFyIEZBTExCQUNLX1JFQ1QgPSB7XG4gIGhlaWdodDogMFxufTtcbmZ1bmN0aW9uIGdldEV4cGFuZGVkU3R5bGUobGF5ZXIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkobGF5ZXIudHJhbnNsYXRlWSkpIHtcbiAgICB2YXIgdHJhbnNsYXRlWVN0YXJ0ID0gcGFyc2VWYWx1ZUFuZFVuaXQobGF5ZXIudHJhbnNsYXRlWVswXSk7XG4gICAgdmFyIHRyYW5zbGF0ZVlFbmQgPSBwYXJzZVZhbHVlQW5kVW5pdChsYXllci50cmFuc2xhdGVZWzFdKTtcblxuICAgIGlmICh0cmFuc2xhdGVZU3RhcnQudW5pdCA9PT0gJ3B4JyAmJiB0cmFuc2xhdGVZRW5kLnVuaXQgPT09ICdweCcpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvcDogTWF0aC5hYnModHJhbnNsYXRlWUVuZC52YWx1ZSkgKiAtMSArIFwicHhcIixcbiAgICAgICAgYm90dG9tOiBNYXRoLmFicyh0cmFuc2xhdGVZU3RhcnQudmFsdWUpICogLTEgKyBcInB4XCJcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKHRyYW5zbGF0ZVlTdGFydC51bml0ID09PSAnJScgJiYgdHJhbnNsYXRlWUVuZC51bml0ID09PSAnJScpIHtcbiAgICAgIHZhciBfbGF5ZXIkdGFyZ2V0RWxlbWVudCQsIF9sYXllciR0YXJnZXRFbGVtZW50O1xuXG4gICAgICB2YXIgY2xpZW50UmVjdCA9IChfbGF5ZXIkdGFyZ2V0RWxlbWVudCQgPSAoX2xheWVyJHRhcmdldEVsZW1lbnQgPSBsYXllci50YXJnZXRFbGVtZW50KSA9PSBudWxsID8gdm9pZCAwIDogX2xheWVyJHRhcmdldEVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkpICE9IG51bGwgPyBfbGF5ZXIkdGFyZ2V0RWxlbWVudCQgOiBGQUxMQkFDS19SRUNUO1xuICAgICAgdmFyIHRvcCA9IE1hdGguYWJzKGNsaWVudFJlY3QuaGVpZ2h0ICogMC4wMSAqIHRyYW5zbGF0ZVlFbmQudmFsdWUpICogLTE7XG4gICAgICB2YXIgYm90dG9tID0gTWF0aC5hYnMoY2xpZW50UmVjdC5oZWlnaHQgKiAwLjAxICogdHJhbnNsYXRlWVN0YXJ0LnZhbHVlKSAqIC0xO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiB0b3AgKyBcInB4XCIsXG4gICAgICAgIGJvdHRvbTogYm90dG9tICsgXCJweFwiXG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGlmIChsYXllci5zcGVlZCkge1xuICAgIHZhciBzcGVlZCA9IGxheWVyLnNwZWVkIHx8IDA7XG4gICAgdmFyIGFic1NwZWVkID0gTWF0aC5hYnMoc3BlZWQpICogMTAgKiAtMTtcbiAgICByZXR1cm4ge1xuICAgICAgdG9wOiBhYnNTcGVlZCArIFwicHhcIixcbiAgICAgIGJvdHRvbTogYWJzU3BlZWQgKyBcInB4XCJcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBnZXRJbWFnZVN0eWxlKGxheWVyKSB7XG4gIHJldHVybiBsYXllci5pbWFnZSA/IHtcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IFwidXJsKFwiICsgbGF5ZXIuaW1hZ2UgKyBcIilcIixcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb246ICdjZW50ZXInLFxuICAgIGJhY2tncm91bmRTaXplOiAnY292ZXInXG4gIH0gOiB7fTtcbn1cblxudmFyIF9leGNsdWRlZCQxID0gW1wiY2hpbGRyZW5cIiwgXCJkaXNhYmxlZFwiLCBcInN0eWxlXCIsIFwiZXhwYW5kZWRcIiwgXCJpbWFnZVwiLCBcInRlc3RJZFwiXTtcbnZhciBhYnNvbHV0ZVN0eWxlID0ge1xuICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcbiAgdG9wOiAwLFxuICBsZWZ0OiAwLFxuICByaWdodDogMCxcbiAgYm90dG9tOiAwXG59O1xudmFyIFBhcmFsbGF4QmFubmVyTGF5ZXIgPSBmdW5jdGlvbiBQYXJhbGxheEJhbm5lckxheWVyKHByb3BzKSB7XG4gIHZhciBfZ2V0SXNvbGF0ZWRQYXJhbGxheFAgPSBnZXRJc29sYXRlZFBhcmFsbGF4UHJvcHMocHJvcHMpLFxuICAgICAgcGFyYWxsYXhQcm9wcyA9IF9nZXRJc29sYXRlZFBhcmFsbGF4UC5wYXJhbGxheFByb3BzLFxuICAgICAgcmVzdCA9IF9nZXRJc29sYXRlZFBhcmFsbGF4UC5yZXN0O1xuXG4gIHZhciBzdHlsZSA9IHJlc3Quc3R5bGUsXG4gICAgICBfcmVzdCRleHBhbmRlZCA9IHJlc3QuZXhwYW5kZWQsXG4gICAgICBleHBhbmRlZCA9IF9yZXN0JGV4cGFuZGVkID09PSB2b2lkIDAgPyB0cnVlIDogX3Jlc3QkZXhwYW5kZWQsXG4gICAgICB0ZXN0SWQgPSByZXN0LnRlc3RJZCxcbiAgICAgIGRpdlByb3BzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2UocmVzdCwgX2V4Y2x1ZGVkJDEpO1xuXG4gIHZhciBpbWFnZVN0eWxlID0gZ2V0SW1hZ2VTdHlsZShwcm9wcyk7XG4gIHZhciBleHBhbmRlZFN0eWxlID0gZXhwYW5kZWQgPyBnZXRFeHBhbmRlZFN0eWxlKHByb3BzKSA6IHt9O1xuICB2YXIgcGFyYWxsYXggPSB1c2VQYXJhbGxheChfZXh0ZW5kcyh7XG4gICAgdGFyZ2V0RWxlbWVudDogcHJvcHMudGFyZ2V0RWxlbWVudCxcbiAgICBzaG91bGREaXNhYmxlU2NhbGluZ1RyYW5zbGF0aW9uczogdHJ1ZVxuICB9LCBwYXJhbGxheFByb3BzKSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIE9iamVjdC5hc3NpZ24oe1xuICAgIFwiZGF0YS10ZXN0aWRcIjogdGVzdElkLFxuICAgIHJlZjogcGFyYWxsYXgucmVmLFxuICAgIHN0eWxlOiBfZXh0ZW5kcyh7fSwgaW1hZ2VTdHlsZSwgYWJzb2x1dGVTdHlsZSwgZXhwYW5kZWRTdHlsZSwgc3R5bGUpXG4gIH0sIGRpdlByb3BzKSwgcmVzdC5jaGlsZHJlbik7XG59O1xuXG52YXIgX2V4Y2x1ZGVkJDIgPSBbXCJkaXNhYmxlZFwiLCBcInN0eWxlXCIsIFwibGF5ZXJzXCJdO1xudmFyIGNvbnRhaW5lclN0eWxlID0ge1xuICBwb3NpdGlvbjogJ3JlbGF0aXZlJyxcbiAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICB3aWR0aDogJzEwMCUnXG59O1xudmFyIFBhcmFsbGF4QmFubmVyID0gZnVuY3Rpb24gUGFyYWxsYXhCYW5uZXIocHJvcHMpIHtcbiAgdmFyIF91c2VTdGF0ZSA9IHVzZVN0YXRlKG51bGwpLFxuICAgICAgdGFyZ2V0RWxlbWVudCA9IF91c2VTdGF0ZVswXSxcbiAgICAgIHNldFRhcmdldEVsZW1lbnQgPSBfdXNlU3RhdGVbMV07XG5cbiAgdmFyIGNvbnRhaW5lclJlZiA9IHVzZVJlZihudWxsKTtcbiAgdXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcbiAgICBzZXRUYXJnZXRFbGVtZW50KGNvbnRhaW5lclJlZi5jdXJyZW50KTtcbiAgfSwgW10pO1xuXG4gIHZhciByb290U3R5bGUgPSBwcm9wcy5zdHlsZSxcbiAgICAgIF9wcm9wcyRsYXllcnMgPSBwcm9wcy5sYXllcnMsXG4gICAgICBsYXllcnMgPSBfcHJvcHMkbGF5ZXJzID09PSB2b2lkIDAgPyBbXSA6IF9wcm9wcyRsYXllcnMsXG4gICAgICByb290UmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHByb3BzLCBfZXhjbHVkZWQkMik7XG5cbiAgZnVuY3Rpb24gcmVuZGVyTGF5ZXJzKCkge1xuICAgIGlmICh0YXJnZXRFbGVtZW50KSB7XG4gICAgICB2YXIgc2hvdWxkVXNlTGF5ZXJzID0gbGF5ZXJzICYmIGxheWVycy5sZW5ndGggPiAwO1xuXG4gICAgICBpZiAoc2hvdWxkVXNlTGF5ZXJzKSB7XG4gICAgICAgIHJldHVybiBsYXllcnMubWFwKGZ1bmN0aW9uIChsYXllciwgaSkge1xuICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFBhcmFsbGF4QmFubmVyTGF5ZXIsIE9iamVjdC5hc3NpZ24oe30sIGxheWVyLCB7XG4gICAgICAgICAgICB0YXJnZXRFbGVtZW50OiB0YXJnZXRFbGVtZW50LFxuICAgICAgICAgICAga2V5OiBcImxheWVyLVwiICsgaSxcbiAgICAgICAgICAgIHRlc3RJZDogXCJsYXllci1cIiArIGlcbiAgICAgICAgICB9KSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyQ2hpbGRyZW4oKSB7XG4gICAgaWYgKHRhcmdldEVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBSZWFjdC5DaGlsZHJlbi5tYXAocHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICB2YXIgaXRlbSA9IGNoaWxkOyAvLyBhZGRzIHRoZSB0YXJnZXRFbGVtZW50IHByb3AgdG8gYW55IFBhcmFsbGF4QmFubmVyTGF5ZXIgY29tcG9uZW50c1xuXG4gICAgICAgIGlmICgoaXRlbSA9PSBudWxsID8gdm9pZCAwIDogaXRlbS50eXBlKSA9PT0gUGFyYWxsYXhCYW5uZXJMYXllcikge1xuICAgICAgICAgIHZhciBjbG9uZSA9IFJlYWN0LmNsb25lRWxlbWVudChpdGVtLCB7XG4gICAgICAgICAgICB0YXJnZXRFbGVtZW50OiB0YXJnZXRFbGVtZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIGNsb25lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNoaWxkO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBPYmplY3QuYXNzaWduKHtcbiAgICByZWY6IGNvbnRhaW5lclJlZixcbiAgICBzdHlsZTogX2V4dGVuZHMoe30sIGNvbnRhaW5lclN0eWxlLCByb290U3R5bGUpXG4gIH0sIHJvb3RSZXN0KSwgcmVuZGVyTGF5ZXJzKCksIHJlbmRlckNoaWxkcmVuKCkpO1xufTtcblxudmFyIGNyZWF0ZUNvbnRyb2xsZXIgPSBmdW5jdGlvbiBjcmVhdGVDb250cm9sbGVyKG9wdGlvbnMpIHtcbiAgLy8gRG9uJ3QgaW5pdGlhbGl6ZSBvbiB0aGUgc2VydmVyXG4gIHZhciBpc1NlcnZlciA9IHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnO1xuXG4gIGlmICghaXNTZXJ2ZXIpIHtcbiAgICAvLyBNdXN0IG5vdCBiZSB0aGUgc2VydmVyIHNvIGtpY2sgaXQgb2ZmLi4uXG4gICAgcmV0dXJuIFBhcmFsbGF4Q29udHJvbGxlci5pbml0KG9wdGlvbnMpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5mdW5jdGlvbiBQYXJhbGxheFByb3ZpZGVyKHByb3BzKSB7XG4gIHZhciBjb250cm9sbGVyID0gdXNlUmVmKG51bGwpO1xuXG4gIGlmICghY29udHJvbGxlci5jdXJyZW50KSB7XG4gICAgY29udHJvbGxlci5jdXJyZW50ID0gY3JlYXRlQ29udHJvbGxlcih7XG4gICAgICBzY3JvbGxBeGlzOiBwcm9wcy5zY3JvbGxBeGlzIHx8IFNjcm9sbEF4aXMudmVydGljYWwsXG4gICAgICBzY3JvbGxDb250YWluZXI6IHByb3BzLnNjcm9sbENvbnRhaW5lcixcbiAgICAgIGRpc2FibGVkOiBwcm9wcy5pc0Rpc2FibGVkXG4gICAgfSk7XG4gIH0gLy8gdXBkYXRlIHNjcm9sbCBjb250YWluZXJcblxuXG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByb3BzLnNjcm9sbENvbnRhaW5lciAmJiBjb250cm9sbGVyLmN1cnJlbnQpIHtcbiAgICAgIGNvbnRyb2xsZXIuY3VycmVudC51cGRhdGVTY3JvbGxDb250YWluZXIocHJvcHMuc2Nyb2xsQ29udGFpbmVyKTtcbiAgICB9XG4gIH0sIFtwcm9wcy5zY3JvbGxDb250YWluZXIsIGNvbnRyb2xsZXIuY3VycmVudF0pOyAvLyBkaXNhYmxlL2VuYWJsZSBwYXJhbGxheFxuXG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHByb3BzLmlzRGlzYWJsZWQgJiYgY29udHJvbGxlci5jdXJyZW50KSB7XG4gICAgICBjb250cm9sbGVyLmN1cnJlbnQuZGlzYWJsZVBhcmFsbGF4Q29udHJvbGxlcigpO1xuICAgIH1cblxuICAgIGlmICghcHJvcHMuaXNEaXNhYmxlZCAmJiBjb250cm9sbGVyLmN1cnJlbnQpIHtcbiAgICAgIGNvbnRyb2xsZXIuY3VycmVudC5lbmFibGVQYXJhbGxheENvbnRyb2xsZXIoKTtcbiAgICB9XG4gIH0sIFtwcm9wcy5pc0Rpc2FibGVkLCBjb250cm9sbGVyLmN1cnJlbnRdKTsgLy8gcmVtb3ZlIHRoZSBjb250cm9sbGVyIHdoZW4gdW5tb3VudGluZ1xuXG4gIHVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIChjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmN1cnJlbnQpICYmIChjb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBjb250cm9sbGVyLmN1cnJlbnQuZGVzdHJveSgpKTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KFBhcmFsbGF4Q29udGV4dC5Qcm92aWRlciwge1xuICAgIHZhbHVlOiBjb250cm9sbGVyLmN1cnJlbnRcbiAgfSwgcHJvcHMuY2hpbGRyZW4pO1xufVxuXG5leHBvcnQgeyBQYXJhbGxheCwgUGFyYWxsYXhCYW5uZXIsIFBhcmFsbGF4QmFubmVyTGF5ZXIsIFBhcmFsbGF4Q29udGV4dCwgUGFyYWxsYXhQcm92aWRlciwgdXNlUGFyYWxsYXgsIHVzZVBhcmFsbGF4Q29udHJvbGxlciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVhY3Qtc2Nyb2xsLXBhcmFsbGF4LmVzbS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-scroll-parallax/dist/react-scroll-parallax.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/rc-slider/assets/index.css":
/*!*************************************************!*\
  !*** ./node_modules/rc-slider/assets/index.css ***!
  \*************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"ed6e4ddba869\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yYy1zbGlkZXIvYXNzZXRzL2luZGV4LmNzcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUVBQWUsY0FBYztBQUM3QixJQUFJLElBQVUsSUFBSSxpQkFBaUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tdmVudHVyYS9Eb2N1bWVudHMvR2l0SHViL21vcnBoZS9ub2RlX21vZHVsZXMvcmMtc2xpZGVyL2Fzc2V0cy9pbmRleC5jc3MiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCJlZDZlNGRkYmE4NjlcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/rc-slider/assets/index.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./public/assets/css/vendor.css":
/*!**************************************!*\
  !*** ./public/assets/css/vendor.css ***!
  \**************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"2107a14da30b\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3B1YmxpYy9hc3NldHMvY3NzL3ZlbmRvci5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxJQUFVLElBQUksaUJBQWlCIiwic291cmNlcyI6WyIvVXNlcnMvbXZlbnR1cmEvRG9jdW1lbnRzL0dpdEh1Yi9tb3JwaGUvcHVibGljL2Fzc2V0cy9jc3MvdmVuZG9yLmNzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBcIjIxMDdhMTRkYTMwYlwiXG5pZiAobW9kdWxlLmhvdCkgeyBtb2R1bGUuaG90LmFjY2VwdCgpIH1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./public/assets/css/vendor.css\n"));

/***/ }),

/***/ "(app-pages-browser)/./public/assets/sass/style.scss":
/*!***************************************!*\
  !*** ./public/assets/sass/style.scss ***!
  \***************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"e495919bea12\");\nif (true) { module.hot.accept() }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3B1YmxpYy9hc3NldHMvc2Fzcy9zdHlsZS5zY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksSUFBVSxJQUFJLGlCQUFpQiIsInNvdXJjZXMiOlsiL1VzZXJzL212ZW50dXJhL0RvY3VtZW50cy9HaXRIdWIvbW9ycGhlL3B1YmxpYy9hc3NldHMvc2Fzcy9zdHlsZS5zY3NzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiZTQ5NTkxOWJlYTEyXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./public/assets/sass/style.scss\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/layout.jsx":
/*!************************!*\
  !*** ./app/layout.jsx ***!
  \************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ RootLayout)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _public_assets_css_vendor_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../public/assets/css/vendor.css */ \"(app-pages-browser)/./public/assets/css/vendor.css\");\n/* harmony import */ var _public_assets_sass_style_scss__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../public/assets/sass/style.scss */ \"(app-pages-browser)/./public/assets/sass/style.scss\");\n/* harmony import */ var react_scroll_parallax__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! react-scroll-parallax */ \"(app-pages-browser)/./node_modules/react-scroll-parallax/dist/react-scroll-parallax.esm.js\");\n/* harmony import */ var _components_common_ScrollTop__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @/components/common/ScrollTop */ \"(app-pages-browser)/./components/common/ScrollTop.jsx\");\n/* harmony import */ var rc_slider_assets_index_css__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! rc-slider/assets/index.css */ \"(app-pages-browser)/./node_modules/rc-slider/assets/index.css\");\n/* harmony import */ var next_font_google_target_css_path_app_layout_jsx_import_Unbounded_arguments_subsets_latin_weight_400_500_600_700_variable_title_font_variableName_unbounded___WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! next/font/google/target.css?{\"path\":\"app/layout.jsx\",\"import\":\"Unbounded\",\"arguments\":[{\"subsets\":[\"latin\"],\"weight\":[\"400\",\"500\",\"600\",\"700\"],\"variable\":\"--title-font\"}],\"variableName\":\"unbounded\"} */ \"(app-pages-browser)/./node_modules/next/font/google/target.css?{\\\"path\\\":\\\"app/layout.jsx\\\",\\\"import\\\":\\\"Unbounded\\\",\\\"arguments\\\":[{\\\"subsets\\\":[\\\"latin\\\"],\\\"weight\\\":[\\\"400\\\",\\\"500\\\",\\\"600\\\",\\\"700\\\"],\\\"variable\\\":\\\"--title-font\\\"}],\\\"variableName\\\":\\\"unbounded\\\"}\");\n/* harmony import */ var next_font_google_target_css_path_app_layout_jsx_import_Unbounded_arguments_subsets_latin_weight_400_500_600_700_variable_title_font_variableName_unbounded___WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(next_font_google_target_css_path_app_layout_jsx_import_Unbounded_arguments_subsets_latin_weight_400_500_600_700_variable_title_font_variableName_unbounded___WEBPACK_IMPORTED_MODULE_11__);\n/* harmony import */ var next_font_google_target_css_path_app_layout_jsx_import_Poppins_arguments_subsets_latin_weight_300_400_500_600_700_800_variable_body_font_variableName_poppins___WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! next/font/google/target.css?{\"path\":\"app/layout.jsx\",\"import\":\"Poppins\",\"arguments\":[{\"subsets\":[\"latin\"],\"weight\":[\"300\",\"400\",\"500\",\"600\",\"700\",\"800\"],\"variable\":\"--body-font\"}],\"variableName\":\"poppins\"} */ \"(app-pages-browser)/./node_modules/next/font/google/target.css?{\\\"path\\\":\\\"app/layout.jsx\\\",\\\"import\\\":\\\"Poppins\\\",\\\"arguments\\\":[{\\\"subsets\\\":[\\\"latin\\\"],\\\"weight\\\":[\\\"300\\\",\\\"400\\\",\\\"500\\\",\\\"600\\\",\\\"700\\\",\\\"800\\\"],\\\"variable\\\":\\\"--body-font\\\"}],\\\"variableName\\\":\\\"poppins\\\"}\");\n/* harmony import */ var next_font_google_target_css_path_app_layout_jsx_import_Poppins_arguments_subsets_latin_weight_300_400_500_600_700_800_variable_body_font_variableName_poppins___WEBPACK_IMPORTED_MODULE_10___default = /*#__PURE__*/__webpack_require__.n(next_font_google_target_css_path_app_layout_jsx_import_Poppins_arguments_subsets_latin_weight_300_400_500_600_700_800_variable_body_font_variableName_poppins___WEBPACK_IMPORTED_MODULE_10__);\n/* harmony import */ var _components_common_ScrollTopBehavier__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @/components/common/ScrollTopBehavier */ \"(app-pages-browser)/./components/common/ScrollTopBehavier.jsx\");\n/* harmony import */ var _context_Context__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @/context/Context */ \"(app-pages-browser)/./context/Context.jsx\");\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\n\n\n\n\n\n\n\nif (true) {\n    __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_bootstrap_dist_js_bootstrap_esm_js\").then(__webpack_require__.bind(__webpack_require__, /*! bootstrap/dist/js/bootstrap.esm */ \"(app-pages-browser)/./node_modules/bootstrap/dist/js/bootstrap.esm.js\")).then((module)=>{\n    // Module is imported, you can access any exported functionality if\n    });\n}\nfunction RootLayout(param) {\n    let { children } = param;\n    _s();\n    const path = (0,next_navigation__WEBPACK_IMPORTED_MODULE_1__.usePathname)();\n    let wow = null;\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"RootLayout.useEffect\": ()=>{\n            const WOW = __webpack_require__(/*! @/utils/wow */ \"(app-pages-browser)/./utils/wow.js\");\n            wow = new WOW.default({\n                live: false,\n                mobile: false\n            });\n            wow.init();\n        }\n    }[\"RootLayout.useEffect\"], [\n        path\n    ]);\n    //useEffect(() => {\n    //wow?.sync();\n    //}, [path]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"html\", {\n        lang: \"en\",\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"body\", {\n            className: \"body  \".concat((next_font_google_target_css_path_app_layout_jsx_import_Poppins_arguments_subsets_latin_weight_300_400_500_600_700_800_variable_body_font_variableName_poppins___WEBPACK_IMPORTED_MODULE_10___default().variable), \" \").concat((next_font_google_target_css_path_app_layout_jsx_import_Unbounded_arguments_subsets_latin_weight_400_500_600_700_variable_title_font_variableName_unbounded___WEBPACK_IMPORTED_MODULE_11___default().variable)),\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_context_Context__WEBPACK_IMPORTED_MODULE_9__[\"default\"], {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_scroll_parallax__WEBPACK_IMPORTED_MODULE_5__.ParallaxProvider, {\n                        children: children\n                    }, void 0, false, {\n                        fileName: \"/Users/mventura/Documents/GitHub/morphe/app/layout.jsx\",\n                        lineNumber: 52,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_common_ScrollTop__WEBPACK_IMPORTED_MODULE_6__[\"default\"], {}, void 0, false, {\n                        fileName: \"/Users/mventura/Documents/GitHub/morphe/app/layout.jsx\",\n                        lineNumber: 53,\n                        columnNumber: 11\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_common_ScrollTopBehavier__WEBPACK_IMPORTED_MODULE_8__[\"default\"], {}, void 0, false, {\n                        fileName: \"/Users/mventura/Documents/GitHub/morphe/app/layout.jsx\",\n                        lineNumber: 54,\n                        columnNumber: 11\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/mventura/Documents/GitHub/morphe/app/layout.jsx\",\n                lineNumber: 51,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"/Users/mventura/Documents/GitHub/morphe/app/layout.jsx\",\n            lineNumber: 50,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/mventura/Documents/GitHub/morphe/app/layout.jsx\",\n        lineNumber: 49,\n        columnNumber: 5\n    }, this);\n}\n_s(RootLayout, \"YP2tSP50FaYgZttcIqISyWoCyXU=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_1__.usePathname\n    ];\n});\n_c = RootLayout;\nvar _c;\n$RefreshReg$(_c, \"RootLayout\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9sYXlvdXQuanN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUU4QztBQUNaO0FBQ087QUFDQztBQUNlO0FBQ0g7QUFDbEI7QUFXOUJJO0FBT0FDO0FBaEJpRTtBQUMvQjtBQUN4QyxJQUFJLElBQTZCLEVBQUU7SUFDakMsK1FBQXlDLENBQUNHLElBQUksQ0FBQyxDQUFDQztJQUM5QyxtRUFBbUU7SUFDckU7QUFDRjtBQWdCZSxTQUFTQyxXQUFXLEtBQVk7UUFBWixFQUFFQyxRQUFRLEVBQUUsR0FBWjs7SUFDakMsTUFBTUMsT0FBT1osNERBQVdBO0lBQ3hCLElBQUlhLE1BQU07SUFDVlosZ0RBQVNBO2dDQUFDO1lBQ1IsTUFBTWEsTUFBTUMsbUJBQU9BLENBQUMsdURBQWE7WUFDakNGLE1BQU0sSUFBSUMsSUFBSUUsT0FBTyxDQUFDO2dCQUNwQkMsTUFBTTtnQkFDTkMsUUFBUTtZQUNWO1lBQ0FMLElBQUlNLElBQUk7UUFDVjsrQkFBRztRQUFDUDtLQUFLO0lBQ1QsbUJBQW1CO0lBRW5CLGNBQWM7SUFDZCxhQUFhO0lBQ2IscUJBQ0UsOERBQUNRO1FBQUtDLE1BQUs7a0JBQ1QsNEVBQUNDO1lBQUtDLFdBQVcsU0FBNkJuQixPQUFwQkMsaU5BQWdCLEVBQUMsS0FBc0IsT0FBbkJELDhNQUFrQjtzQkFDOUQsNEVBQUNHLHdEQUFPQTs7a0NBQ04sOERBQUNMLG1FQUFnQkE7a0NBQUVTOzs7Ozs7a0NBQ25CLDhEQUFDUixvRUFBU0E7Ozs7O2tDQUNWLDhEQUFDRyw0RUFBa0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFLN0I7R0ExQndCSTs7UUFDVFYsd0RBQVdBOzs7S0FERlUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tdmVudHVyYS9Eb2N1bWVudHMvR2l0SHViL21vcnBoZS9hcHAvbGF5b3V0LmpzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IHsgdXNlUGF0aG5hbWUgfSBmcm9tIFwibmV4dC9uYXZpZ2F0aW9uXCI7XG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcbmltcG9ydCBcIi4uL3B1YmxpYy9hc3NldHMvY3NzL3ZlbmRvci5jc3NcIjtcbmltcG9ydCBcIi4uL3B1YmxpYy9hc3NldHMvc2Fzcy9zdHlsZS5zY3NzXCI7XG5pbXBvcnQgeyBQYXJhbGxheFByb3ZpZGVyIH0gZnJvbSBcInJlYWN0LXNjcm9sbC1wYXJhbGxheFwiO1xuaW1wb3J0IFNjcm9sbFRvcCBmcm9tIFwiQC9jb21wb25lbnRzL2NvbW1vbi9TY3JvbGxUb3BcIjtcbmltcG9ydCBcInJjLXNsaWRlci9hc3NldHMvaW5kZXguY3NzXCI7XG5pbXBvcnQgeyBVbmJvdW5kZWQsIFBvcHBpbnMgfSBmcm9tIFwibmV4dC9mb250L2dvb2dsZVwiO1xuaW1wb3J0IFNjcm9sbFRvcEJlaGF2aW91ciBmcm9tIFwiQC9jb21wb25lbnRzL2NvbW1vbi9TY3JvbGxUb3BCZWhhdmllclwiO1xuaW1wb3J0IENvbnRleHQgZnJvbSBcIkAvY29udGV4dC9Db250ZXh0XCI7XG5pZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICBpbXBvcnQoXCJib290c3RyYXAvZGlzdC9qcy9ib290c3RyYXAuZXNtXCIpLnRoZW4oKG1vZHVsZSkgPT4ge1xuICAgIC8vIE1vZHVsZSBpcyBpbXBvcnRlZCwgeW91IGNhbiBhY2Nlc3MgYW55IGV4cG9ydGVkIGZ1bmN0aW9uYWxpdHkgaWZcbiAgfSk7XG59XG4vLyB3b3cganNcblxuY29uc3QgdW5ib3VuZGVkID0gVW5ib3VuZGVkKHtcbiAgc3Vic2V0czogW1wibGF0aW5cIl0sXG4gIHdlaWdodDogW1wiNDAwXCIsIFwiNTAwXCIsIFwiNjAwXCIsIFwiNzAwXCJdLFxuICB2YXJpYWJsZTogXCItLXRpdGxlLWZvbnRcIixcbn0pO1xuXG4vLyBQb3BwaW5zIGZvbnRcbmNvbnN0IHBvcHBpbnMgPSBQb3BwaW5zKHtcbiAgc3Vic2V0czogW1wibGF0aW5cIl0sXG4gIHdlaWdodDogW1wiMzAwXCIsIFwiNDAwXCIsIFwiNTAwXCIsIFwiNjAwXCIsIFwiNzAwXCIsIFwiODAwXCJdLFxuICB2YXJpYWJsZTogXCItLWJvZHktZm9udFwiLFxufSk7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIFJvb3RMYXlvdXQoeyBjaGlsZHJlbiB9KSB7XG4gIGNvbnN0IHBhdGggPSB1c2VQYXRobmFtZSgpO1xuICBsZXQgd293ID0gbnVsbDtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBXT1cgPSByZXF1aXJlKFwiQC91dGlscy93b3dcIik7XG4gICAgd293ID0gbmV3IFdPVy5kZWZhdWx0KHtcbiAgICAgIGxpdmU6IGZhbHNlLFxuICAgICAgbW9iaWxlOiBmYWxzZSxcbiAgICB9KTtcbiAgICB3b3cuaW5pdCgpO1xuICB9LCBbcGF0aF0pO1xuICAvL3VzZUVmZmVjdCgoKSA9PiB7XG5cbiAgLy93b3c/LnN5bmMoKTtcbiAgLy99LCBbcGF0aF0pO1xuICByZXR1cm4gKFxuICAgIDxodG1sIGxhbmc9XCJlblwiPlxuICAgICAgPGJvZHkgY2xhc3NOYW1lPXtgYm9keSAgJHtwb3BwaW5zLnZhcmlhYmxlfSAke3VuYm91bmRlZC52YXJpYWJsZX1gfT5cbiAgICAgICAgPENvbnRleHQ+XG4gICAgICAgICAgPFBhcmFsbGF4UHJvdmlkZXI+e2NoaWxkcmVufTwvUGFyYWxsYXhQcm92aWRlcj5cbiAgICAgICAgICA8U2Nyb2xsVG9wIC8+XG4gICAgICAgICAgPFNjcm9sbFRvcEJlaGF2aW91ciAvPlxuICAgICAgICA8L0NvbnRleHQ+XG4gICAgICA8L2JvZHk+XG4gICAgPC9odG1sPlxuICApO1xufVxuIl0sIm5hbWVzIjpbInVzZVBhdGhuYW1lIiwidXNlRWZmZWN0IiwiUGFyYWxsYXhQcm92aWRlciIsIlNjcm9sbFRvcCIsInVuYm91bmRlZCIsInBvcHBpbnMiLCJTY3JvbGxUb3BCZWhhdmlvdXIiLCJDb250ZXh0IiwidGhlbiIsIm1vZHVsZSIsIlJvb3RMYXlvdXQiLCJjaGlsZHJlbiIsInBhdGgiLCJ3b3ciLCJXT1ciLCJyZXF1aXJlIiwiZGVmYXVsdCIsImxpdmUiLCJtb2JpbGUiLCJpbml0IiwiaHRtbCIsImxhbmciLCJib2R5IiwiY2xhc3NOYW1lIiwidmFyaWFibGUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/layout.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/common/ScrollTop.jsx":
/*!*****************************************!*\
  !*** ./components/common/ScrollTop.jsx ***!
  \*****************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ScrollTop)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\nvar _s = $RefreshSig$();\n\nfunction ScrollTop() {\n    _s();\n    const [showScrollTop, setShowScrollTop] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(false);\n    const [scrolled, setScrolled] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(0);\n    const [scrollHeight, setScrollHeight] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(400);\n    const scrollToTop = ()=>{\n        if (window) {\n            window.scrollTo({\n                top: 0,\n                behavior: \"smooth\"\n            });\n        }\n    };\n    const handleScroll = ()=>{\n        setScrolled(document.body.scrollTop || document.documentElement.scrollTop);\n        setShowScrollTop(window.scrollY >= window.innerHeight);\n        setScrollHeight(document.documentElement.scrollHeight - document.documentElement.clientHeight);\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"ScrollTop.useEffect\": ()=>{\n            window.addEventListener(\"scroll\", handleScroll);\n            return ({\n                \"ScrollTop.useEffect\": ()=>{\n                    window.removeEventListener(\"scroll\", handleScroll);\n                }\n            })[\"ScrollTop.useEffect\"];\n        }\n    }[\"ScrollTop.useEffect\"], []);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        className: \"scroll-top \".concat(showScrollTop ? \"show\" : \"\", \" \"),\n        onClick: scrollToTop,\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"svg\", {\n            className: \"progress-circle svg-content\",\n            width: \"100%\",\n            height: \"100%\",\n            viewBox: \"-1 -1 102 102\",\n            children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"path\", {\n                d: \"M50,1 a49,49 0 0,1 0,98 a49,49 0 0,1 0,-98\",\n                style: {\n                    transition: \"stroke-dashoffset 10ms linear 0s\",\n                    strokeDasharray: \"307.919, 307.919\",\n                    strokeDashoffset: \"\".concat(307.919 - scrolled / scrollHeight * 307.919)\n                }\n            }, void 0, false, {\n                fileName: \"/Users/mventura/Documents/GitHub/morphe/components/common/ScrollTop.jsx\",\n                lineNumber: 43,\n                columnNumber: 9\n            }, this)\n        }, void 0, false, {\n            fileName: \"/Users/mventura/Documents/GitHub/morphe/components/common/ScrollTop.jsx\",\n            lineNumber: 37,\n            columnNumber: 7\n        }, this)\n    }, void 0, false, {\n        fileName: \"/Users/mventura/Documents/GitHub/morphe/components/common/ScrollTop.jsx\",\n        lineNumber: 33,\n        columnNumber: 5\n    }, this);\n}\n_s(ScrollTop, \"3tPLOuuqtJ5Rv8rci7kN2OHc7uo=\");\n_c = ScrollTop;\nvar _c;\n$RefreshReg$(_c, \"ScrollTop\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvY29tbW9uL1Njcm9sbFRvcC5qc3giLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQW1EO0FBRXBDLFNBQVNHOztJQUN0QixNQUFNLENBQUNDLGVBQWVDLGlCQUFpQixHQUFHSCwrQ0FBUUEsQ0FBQztJQUNuRCxNQUFNLENBQUNJLFVBQVVDLFlBQVksR0FBR0wsK0NBQVFBLENBQUM7SUFDekMsTUFBTSxDQUFDTSxjQUFjQyxnQkFBZ0IsR0FBR1AsK0NBQVFBLENBQUM7SUFFakQsTUFBTVEsY0FBYztRQUNsQixJQUFJQyxRQUFRO1lBQ1ZBLE9BQU9DLFFBQVEsQ0FBQztnQkFDZEMsS0FBSztnQkFDTEMsVUFBVTtZQUNaO1FBQ0Y7SUFDRjtJQUNBLE1BQU1DLGVBQWU7UUFDbkJSLFlBQVlTLFNBQVNDLElBQUksQ0FBQ0MsU0FBUyxJQUFJRixTQUFTRyxlQUFlLENBQUNELFNBQVM7UUFDekViLGlCQUFpQk0sT0FBT1MsT0FBTyxJQUFJVCxPQUFPVSxXQUFXO1FBRXJEWixnQkFDRU8sU0FBU0csZUFBZSxDQUFDWCxZQUFZLEdBQ25DUSxTQUFTRyxlQUFlLENBQUNHLFlBQVk7SUFFM0M7SUFDQXJCLGdEQUFTQTsrQkFBQztZQUNSVSxPQUFPWSxnQkFBZ0IsQ0FBQyxVQUFVUjtZQUNsQzt1Q0FBTztvQkFDTEosT0FBT2EsbUJBQW1CLENBQUMsVUFBVVQ7Z0JBQ3ZDOztRQUNGOzhCQUFHLEVBQUU7SUFFTCxxQkFDRSw4REFBQ1U7UUFDQ0MsV0FBVyxjQUEwQyxPQUE1QnRCLGdCQUFnQixTQUFTLElBQUc7UUFDckR1QixTQUFTakI7a0JBRVQsNEVBQUNrQjtZQUNDRixXQUFVO1lBQ1ZHLE9BQU07WUFDTkMsUUFBTztZQUNQQyxTQUFRO3NCQUVSLDRFQUFDQztnQkFDQ0MsR0FBRTtnQkFDRkMsT0FBTztvQkFDTEMsWUFBWTtvQkFDWkMsaUJBQWlCO29CQUNqQkMsa0JBQWtCLEdBRWpCLE9BREMsVUFBVSxXQUFZN0IsZUFBZ0I7Z0JBRTFDOzs7Ozs7Ozs7Ozs7Ozs7O0FBS1Y7R0FyRHdCTDtLQUFBQSIsInNvdXJjZXMiOlsiL1VzZXJzL212ZW50dXJhL0RvY3VtZW50cy9HaXRIdWIvbW9ycGhlL2NvbXBvbmVudHMvY29tbW9uL1Njcm9sbFRvcC5qc3giXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gU2Nyb2xsVG9wKCkge1xuICBjb25zdCBbc2hvd1Njcm9sbFRvcCwgc2V0U2hvd1Njcm9sbFRvcF0gPSB1c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtzY3JvbGxlZCwgc2V0U2Nyb2xsZWRdID0gdXNlU3RhdGUoMCk7XG4gIGNvbnN0IFtzY3JvbGxIZWlnaHQsIHNldFNjcm9sbEhlaWdodF0gPSB1c2VTdGF0ZSg0MDApO1xuXG4gIGNvbnN0IHNjcm9sbFRvVG9wID0gKCkgPT4ge1xuICAgIGlmICh3aW5kb3cpIHtcbiAgICAgIHdpbmRvdy5zY3JvbGxUbyh7XG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgYmVoYXZpb3I6IFwic21vb3RoXCIsIC8vIFlvdSBjYW4gdXNlICdhdXRvJyBvciAnaW5zdGFudCcgYXMgd2VsbFxuICAgICAgfSk7XG4gICAgfVxuICB9O1xuICBjb25zdCBoYW5kbGVTY3JvbGwgPSAoKSA9PiB7XG4gICAgc2V0U2Nyb2xsZWQoZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCk7XG4gICAgc2V0U2hvd1Njcm9sbFRvcCh3aW5kb3cuc2Nyb2xsWSA+PSB3aW5kb3cuaW5uZXJIZWlnaHQpO1xuXG4gICAgc2V0U2Nyb2xsSGVpZ2h0KFxuICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCAtXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHRcbiAgICApO1xuICB9O1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGhhbmRsZVNjcm9sbCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGhhbmRsZVNjcm9sbCk7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiAoXG4gICAgPGRpdlxuICAgICAgY2xhc3NOYW1lPXtgc2Nyb2xsLXRvcCAke3Nob3dTY3JvbGxUb3AgPyBcInNob3dcIiA6IFwiXCJ9IGB9XG4gICAgICBvbkNsaWNrPXtzY3JvbGxUb1RvcH1cbiAgICA+XG4gICAgICA8c3ZnXG4gICAgICAgIGNsYXNzTmFtZT1cInByb2dyZXNzLWNpcmNsZSBzdmctY29udGVudFwiXG4gICAgICAgIHdpZHRoPVwiMTAwJVwiXG4gICAgICAgIGhlaWdodD1cIjEwMCVcIlxuICAgICAgICB2aWV3Qm94PVwiLTEgLTEgMTAyIDEwMlwiXG4gICAgICA+XG4gICAgICAgIDxwYXRoXG4gICAgICAgICAgZD1cIk01MCwxIGE0OSw0OSAwIDAsMSAwLDk4IGE0OSw0OSAwIDAsMSAwLC05OFwiXG4gICAgICAgICAgc3R5bGU9e3tcbiAgICAgICAgICAgIHRyYW5zaXRpb246IFwic3Ryb2tlLWRhc2hvZmZzZXQgMTBtcyBsaW5lYXIgMHNcIixcbiAgICAgICAgICAgIHN0cm9rZURhc2hhcnJheTogXCIzMDcuOTE5LCAzMDcuOTE5XCIsXG4gICAgICAgICAgICBzdHJva2VEYXNob2Zmc2V0OiBgJHtcbiAgICAgICAgICAgICAgMzA3LjkxOSAtIChzY3JvbGxlZCAvIHNjcm9sbEhlaWdodCkgKiAzMDcuOTE5XG4gICAgICAgICAgICB9YCxcbiAgICAgICAgICB9fVxuICAgICAgICA+PC9wYXRoPlxuICAgICAgPC9zdmc+XG4gICAgPC9kaXY+XG4gICk7XG59XG4iXSwibmFtZXMiOlsiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VTdGF0ZSIsIlNjcm9sbFRvcCIsInNob3dTY3JvbGxUb3AiLCJzZXRTaG93U2Nyb2xsVG9wIiwic2Nyb2xsZWQiLCJzZXRTY3JvbGxlZCIsInNjcm9sbEhlaWdodCIsInNldFNjcm9sbEhlaWdodCIsInNjcm9sbFRvVG9wIiwid2luZG93Iiwic2Nyb2xsVG8iLCJ0b3AiLCJiZWhhdmlvciIsImhhbmRsZVNjcm9sbCIsImRvY3VtZW50IiwiYm9keSIsInNjcm9sbFRvcCIsImRvY3VtZW50RWxlbWVudCIsInNjcm9sbFkiLCJpbm5lckhlaWdodCIsImNsaWVudEhlaWdodCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZGl2IiwiY2xhc3NOYW1lIiwib25DbGljayIsInN2ZyIsIndpZHRoIiwiaGVpZ2h0Iiwidmlld0JveCIsInBhdGgiLCJkIiwic3R5bGUiLCJ0cmFuc2l0aW9uIiwic3Ryb2tlRGFzaGFycmF5Iiwic3Ryb2tlRGFzaG9mZnNldCJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/common/ScrollTop.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./components/common/ScrollTopBehavier.jsx":
/*!*************************************************!*\
  !*** ./components/common/ScrollTopBehavier.jsx ***!
  \*************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ ScrollTopBehaviour)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var next_navigation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/navigation */ \"(app-pages-browser)/./node_modules/next/dist/api/navigation.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n\nvar _s = $RefreshSig$();\n\n\nfunction ScrollTopBehaviour() {\n    _s();\n    const pathname = (0,next_navigation__WEBPACK_IMPORTED_MODULE_1__.usePathname)();\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"ScrollTopBehaviour.useEffect\": ()=>{\n            window.scrollTo({\n                top: 0,\n                behavior: \"instant\"\n            });\n        }\n    }[\"ScrollTopBehaviour.useEffect\"], [\n        pathname\n    ]);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {}, void 0, false);\n}\n_s(ScrollTopBehaviour, \"V/ldUoOTYUs0Cb2F6bbxKSn7KxI=\", false, function() {\n    return [\n        next_navigation__WEBPACK_IMPORTED_MODULE_1__.usePathname\n    ];\n});\n_c = ScrollTopBehaviour;\nvar _c;\n$RefreshReg$(_c, \"ScrollTopBehaviour\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2NvbXBvbmVudHMvY29tbW9uL1Njcm9sbFRvcEJlaGF2aWVyLmpzeCIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQThDO0FBQ1o7QUFFbkIsU0FBU0U7O0lBQ3RCLE1BQU1DLFdBQVdILDREQUFXQTtJQUU1QkMsZ0RBQVNBO3dDQUFDO1lBQ1JHLE9BQU9DLFFBQVEsQ0FBQztnQkFDZEMsS0FBSztnQkFDTEMsVUFBVTtZQUNaO1FBQ0Y7dUNBQUc7UUFBQ0o7S0FBUztJQUViLHFCQUFPO0FBQ1Q7R0FYd0JEOztRQUNMRix3REFBV0E7OztLQURORSIsInNvdXJjZXMiOlsiL1VzZXJzL212ZW50dXJhL0RvY3VtZW50cy9HaXRIdWIvbW9ycGhlL2NvbXBvbmVudHMvY29tbW9uL1Njcm9sbFRvcEJlaGF2aWVyLmpzeCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB1c2VQYXRobmFtZSB9IGZyb20gXCJuZXh0L25hdmlnYXRpb25cIjtcbmltcG9ydCB7IHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBTY3JvbGxUb3BCZWhhdmlvdXIoKSB7XG4gIGNvbnN0IHBhdGhuYW1lID0gdXNlUGF0aG5hbWUoKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIHdpbmRvdy5zY3JvbGxUbyh7XG4gICAgICB0b3A6IDAsXG4gICAgICBiZWhhdmlvcjogXCJpbnN0YW50XCIsIC8vIFlvdSBjYW4gdXNlICdhdXRvJyBvciAnaW5zdGFudCcgYXMgd2VsbFxuICAgIH0pO1xuICB9LCBbcGF0aG5hbWVdKTtcblxuICByZXR1cm4gPD48Lz47XG59XG4iXSwibmFtZXMiOlsidXNlUGF0aG5hbWUiLCJ1c2VFZmZlY3QiLCJTY3JvbGxUb3BCZWhhdmlvdXIiLCJwYXRobmFtZSIsIndpbmRvdyIsInNjcm9sbFRvIiwidG9wIiwiYmVoYXZpb3IiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./components/common/ScrollTopBehavier.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./context/Context.jsx":
/*!*****************************!*\
  !*** ./context/Context.jsx ***!
  \*****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ Context),\n/* harmony export */   useContextElement: () => (/* binding */ useContextElement)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var _data_products__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @/data/products */ \"(app-pages-browser)/./data/products.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* __next_internal_client_entry_do_not_use__ useContextElement,default auto */ \nvar _s = $RefreshSig$(), _s1 = $RefreshSig$();\n\n\n\nconst dataContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2___default().createContext();\nconst useContextElement = ()=>{\n    _s();\n    return (0,react__WEBPACK_IMPORTED_MODULE_2__.useContext)(dataContext);\n};\n_s(useContextElement, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\nfunction Context(param) {\n    let { children } = param;\n    _s1();\n    const [cartProducts, setCartProducts] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]);\n    const [totalPrice, setTotalPrice] = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(0);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"Context.useEffect\": ()=>{\n            const subtotal = cartProducts.reduce({\n                \"Context.useEffect.subtotal\": (accumulator, product)=>{\n                    return accumulator + product.quantity * product.price;\n                }\n            }[\"Context.useEffect.subtotal\"], 0);\n            setTotalPrice(subtotal);\n        }\n    }[\"Context.useEffect\"], [\n        cartProducts\n    ]);\n    const isAddedToCartProducts = (id)=>{\n        if (cartProducts.filter((elm)=>elm.id == id)[0]) {\n            return true;\n        }\n        return false;\n    };\n    const addProductToCart = (id, qty)=>{\n        if (!isAddedToCartProducts(id)) {\n            const item = {\n                ..._data_products__WEBPACK_IMPORTED_MODULE_1__.products.filter((elm)=>elm.id == id)[0],\n                quantity: qty ? qty : 1\n            };\n            setCartProducts((pre)=>[\n                    ...pre,\n                    item\n                ]);\n        }\n    };\n    const productQuantityInCart = (id)=>{\n        if (!isAddedToCartProducts(id)) {\n            const item = {\n                ..._data_products__WEBPACK_IMPORTED_MODULE_1__.products.filter((elm)=>elm.id == id)[0]\n            };\n            return item.quantity;\n        } else {\n            return 0;\n        }\n    };\n    const updateQuantity = (id, qty)=>{\n        if (isAddedToCartProducts(id) && qty > 0) {\n            let item = cartProducts.filter((elm)=>elm.id == id)[0];\n            let items = [\n                ...cartProducts\n            ];\n            const itemIndex = items.indexOf(item);\n            item.quantity = qty / 1;\n            items[itemIndex] = item;\n            setCartProducts(items);\n        }\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"Context.useEffect\": ()=>{\n            const items = JSON.parse(localStorage.getItem(\"cartList\"));\n            if (items === null || items === void 0 ? void 0 : items.length) {\n                setCartProducts(items);\n            }\n        }\n    }[\"Context.useEffect\"], []);\n    (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)({\n        \"Context.useEffect\": ()=>{\n            localStorage.setItem(\"cartList\", JSON.stringify(cartProducts));\n        }\n    }[\"Context.useEffect\"], [\n        cartProducts\n    ]);\n    const contextElement = {\n        cartProducts,\n        setCartProducts,\n        totalPrice,\n        addProductToCart,\n        isAddedToCartProducts,\n        productQuantityInCart,\n        updateQuantity\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(dataContext.Provider, {\n        value: contextElement,\n        children: children\n    }, void 0, false, {\n        fileName: \"/Users/mventura/Documents/GitHub/morphe/context/Context.jsx\",\n        lineNumber: 80,\n        columnNumber: 5\n    }, this);\n}\n_s1(Context, \"NQpYtROIsnSheBGaSWHUINEN/EY=\");\n_c = Context;\nvar _c;\n$RefreshReg$(_c, \"Context\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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L0RvY3VtZW50cy9HaXRIdWIvbW9ycGhlL2NvbnRleHQvQ29udGV4dC5qc3giXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2UgY2xpZW50XCI7XG5pbXBvcnQgeyBwcm9kdWN0cyB9IGZyb20gXCJAL2RhdGEvcHJvZHVjdHNcIjtcblxuaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHsgdXNlQ29udGV4dCwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcbmNvbnN0IGRhdGFDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCgpO1xuZXhwb3J0IGNvbnN0IHVzZUNvbnRleHRFbGVtZW50ID0gKCkgPT4ge1xuICByZXR1cm4gdXNlQ29udGV4dChkYXRhQ29udGV4dCk7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDb250ZXh0KHsgY2hpbGRyZW4gfSkge1xuICBjb25zdCBbY2FydFByb2R1Y3RzLCBzZXRDYXJ0UHJvZHVjdHNdID0gdXNlU3RhdGUoW10pO1xuXG4gIGNvbnN0IFt0b3RhbFByaWNlLCBzZXRUb3RhbFByaWNlXSA9IHVzZVN0YXRlKDApO1xuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHN1YnRvdGFsID0gY2FydFByb2R1Y3RzLnJlZHVjZSgoYWNjdW11bGF0b3IsIHByb2R1Y3QpID0+IHtcbiAgICAgIHJldHVybiBhY2N1bXVsYXRvciArIHByb2R1Y3QucXVhbnRpdHkgKiBwcm9kdWN0LnByaWNlO1xuICAgIH0sIDApO1xuICAgIHNldFRvdGFsUHJpY2Uoc3VidG90YWwpO1xuICB9LCBbY2FydFByb2R1Y3RzXSk7XG5cbiAgY29uc3QgaXNBZGRlZFRvQ2FydFByb2R1Y3RzID0gKGlkKSA9PiB7XG4gICAgaWYgKGNhcnRQcm9kdWN0cy5maWx0ZXIoKGVsbSkgPT4gZWxtLmlkID09IGlkKVswXSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbiAgY29uc3QgYWRkUHJvZHVjdFRvQ2FydCA9IChpZCwgcXR5KSA9PiB7XG4gICAgaWYgKCFpc0FkZGVkVG9DYXJ0UHJvZHVjdHMoaWQpKSB7XG4gICAgICBjb25zdCBpdGVtID0ge1xuICAgICAgICAuLi5wcm9kdWN0cy5maWx0ZXIoKGVsbSkgPT4gZWxtLmlkID09IGlkKVswXSxcbiAgICAgICAgcXVhbnRpdHk6IHF0eSA/IHF0eSA6IDEsXG4gICAgICB9O1xuICAgICAgc2V0Q2FydFByb2R1Y3RzKChwcmUpID0+IFsuLi5wcmUsIGl0ZW1dKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHByb2R1Y3RRdWFudGl0eUluQ2FydCA9IChpZCkgPT4ge1xuICAgIGlmICghaXNBZGRlZFRvQ2FydFByb2R1Y3RzKGlkKSkge1xuICAgICAgY29uc3QgaXRlbSA9IHtcbiAgICAgICAgLi4ucHJvZHVjdHMuZmlsdGVyKChlbG0pID0+IGVsbS5pZCA9PSBpZClbMF0sXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGl0ZW0ucXVhbnRpdHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfTtcblxuICBjb25zdCB1cGRhdGVRdWFudGl0eSA9IChpZCwgcXR5KSA9PiB7XG4gICAgaWYgKGlzQWRkZWRUb0NhcnRQcm9kdWN0cyhpZCkgJiYgcXR5ID4gMCkge1xuICAgICAgbGV0IGl0ZW0gPSBjYXJ0UHJvZHVjdHMuZmlsdGVyKChlbG0pID0+IGVsbS5pZCA9PSBpZClbMF07XG4gICAgICBsZXQgaXRlbXMgPSBbLi4uY2FydFByb2R1Y3RzXTtcbiAgICAgIGNvbnN0IGl0ZW1JbmRleCA9IGl0ZW1zLmluZGV4T2YoaXRlbSk7XG5cbiAgICAgIGl0ZW0ucXVhbnRpdHkgPSBxdHkgLyAxO1xuICAgICAgaXRlbXNbaXRlbUluZGV4XSA9IGl0ZW07XG4gICAgICBzZXRDYXJ0UHJvZHVjdHMoaXRlbXMpO1xuICAgIH1cbiAgfTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IGl0ZW1zID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShcImNhcnRMaXN0XCIpKTtcbiAgICBpZiAoaXRlbXM/Lmxlbmd0aCkge1xuICAgICAgc2V0Q2FydFByb2R1Y3RzKGl0ZW1zKTtcbiAgICB9XG4gIH0sIFtdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShcImNhcnRMaXN0XCIsIEpTT04uc3RyaW5naWZ5KGNhcnRQcm9kdWN0cykpO1xuICB9LCBbY2FydFByb2R1Y3RzXSk7XG5cbiAgY29uc3QgY29udGV4dEVsZW1lbnQgPSB7XG4gICAgY2FydFByb2R1Y3RzLFxuICAgIHNldENhcnRQcm9kdWN0cyxcbiAgICB0b3RhbFByaWNlLFxuICAgIGFkZFByb2R1Y3RUb0NhcnQsXG4gICAgaXNBZGRlZFRvQ2FydFByb2R1Y3RzLFxuICAgIHByb2R1Y3RRdWFudGl0eUluQ2FydCxcbiAgICB1cGRhdGVRdWFudGl0eSxcbiAgfTtcbiAgcmV0dXJuIChcbiAgICA8ZGF0YUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NvbnRleHRFbGVtZW50fT5cbiAgICAgIHtjaGlsZHJlbn1cbiAgICA8L2RhdGFDb250ZXh0LlByb3ZpZGVyPlxuICApO1xufVxuIl0sIm5hbWVzIjpbInByb2R1Y3RzIiwiUmVhY3QiLCJ1c2VFZmZlY3QiLCJ1c2VDb250ZXh0IiwidXNlU3RhdGUiLCJkYXRhQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJ1c2VDb250ZXh0RWxlbWVudCIsIkNvbnRleHQiLCJjaGlsZHJlbiIsImNhcnRQcm9kdWN0cyIsInNldENhcnRQcm9kdWN0cyIsInRvdGFsUHJpY2UiLCJzZXRUb3RhbFByaWNlIiwic3VidG90YWwiLCJyZWR1Y2UiLCJhY2N1bXVsYXRvciIsInByb2R1Y3QiLCJxdWFudGl0eSIsInByaWNlIiwiaXNBZGRlZFRvQ2FydFByb2R1Y3RzIiwiaWQiLCJmaWx0ZXIiLCJlbG0iLCJhZGRQcm9kdWN0VG9DYXJ0IiwicXR5IiwiaXRlbSIsInByZSIsInByb2R1Y3RRdWFudGl0eUluQ2FydCIsInVwZGF0ZVF1YW50aXR5IiwiaXRlbXMiLCJpdGVtSW5kZXgiLCJpbmRleE9mIiwiSlNPTiIsInBhcnNlIiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImxlbmd0aCIsInNldEl0ZW0iLCJzdHJpbmdpZnkiLCJjb250ZXh0RWxlbWVudCIsIlByb3ZpZGVyIiwidmFsdWUiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./context/Context.jsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./data/products.js":
/*!**************************!*\
  !*** ./data/products.js ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   categories: () => (/* binding */ categories),\n/* harmony export */   products: () => (/* binding */ products),\n/* harmony export */   socialLinks: () => (/* binding */ socialLinks),\n/* harmony export */   tags: () => (/* binding */ tags)\n/* harmony export */ });\nconst products = [\n    {\n        id: 1,\n        imgSrc: \"/assets/img/product/product_1_1.jpg\",\n        title: \"Printed T-Shirt\",\n        price: 20.5,\n        originalPrice: 29.5,\n        isSale: true\n    },\n    {\n        id: 2,\n        imgSrc: \"/assets/img/product/product_1_2.jpg\",\n        title: \"Card Wallet\",\n        price: 52\n    },\n    {\n        id: 3,\n        imgSrc: \"/assets/img/product/product_1_3.jpg\",\n        title: \"Kinto Tumbler\",\n        price: 38\n    },\n    {\n        id: 4,\n        imgSrc: \"/assets/img/product/product_1_4.jpg\",\n        title: \"Ripple Crewneck\",\n        price: 160.9\n    },\n    {\n        id: 5,\n        imgSrc: \"/assets/img/product/product_1_5.jpg\",\n        title: \"Herman Miller\",\n        price: 44.5\n    },\n    {\n        id: 6,\n        imgSrc: \"/assets/img/product/product_1_6.jpg\",\n        title: \"Knit Beanie\",\n        price: 30,\n        originalPrice: 50,\n        isSale: true\n    },\n    {\n        id: 7,\n        imgSrc: \"/assets/img/product/product_1_7.jpg\",\n        title: \"Bifold Wallet\",\n        price: 84.8,\n        originalPrice: 110.8,\n        isSale: true\n    },\n    {\n        id: 8,\n        imgSrc: \"/assets/img/product/product_1_8.jpg\",\n        title: \"Pillars Tee\",\n        price: 26.9\n    }\n];\nconst categories = [\n    {\n        name: \"Archive\",\n        count: 3\n    },\n    {\n        name: \"Branding\",\n        count: 6\n    },\n    {\n        name: \"Company\",\n        count: 2\n    },\n    {\n        name: \"Design\",\n        count: 1\n    },\n    {\n        name: \"Business\",\n        count: 4\n    },\n    {\n        name: \"Modern\",\n        count: 1\n    }\n];\nconst tags = [\n    \"Agency\",\n    \"Awards\",\n    \"Marketing\",\n    \"Brand\",\n    \"Contemporary\",\n    \"Design\",\n    \"Education\",\n    \"Business\",\n    \"Modern\"\n];\nconst socialLinks = [\n    {\n        url: \"https://www.facebook.com/\",\n        icon: \"fab fa-facebook\"\n    },\n    {\n        url: \"https://instagram.com/\",\n        icon: \"fab fa-instagram\"\n    },\n    {\n        url: \"https://twitter.com/\",\n        icon: \"fab fa-twitter\"\n    },\n    {\n        url: \"https://dribbble.com/\",\n        icon: \"fab fa-dribbble\"\n    }\n];\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2RhdGEvcHJvZHVjdHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFPLE1BQU1BLFdBQVc7SUFDdEI7UUFDRUMsSUFBSTtRQUNKQyxRQUFRO1FBQ1JDLE9BQU87UUFDUEMsT0FBTztRQUNQQyxlQUFlO1FBQ2ZDLFFBQVE7SUFDVjtJQUNBO1FBQ0VMLElBQUk7UUFDSkMsUUFBUTtRQUNSQyxPQUFPO1FBQ1BDLE9BQU87SUFDVDtJQUNBO1FBQ0VILElBQUk7UUFDSkMsUUFBUTtRQUNSQyxPQUFPO1FBQ1BDLE9BQU87SUFDVDtJQUNBO1FBQ0VILElBQUk7UUFDSkMsUUFBUTtRQUNSQyxPQUFPO1FBQ1BDLE9BQU87SUFDVDtJQUNBO1FBQ0VILElBQUk7UUFDSkMsUUFBUTtRQUNSQyxPQUFPO1FBQ1BDLE9BQU87SUFDVDtJQUNBO1FBQ0VILElBQUk7UUFDSkMsUUFBUTtRQUNSQyxPQUFPO1FBQ1BDLE9BQU87UUFDUEMsZUFBZTtRQUNmQyxRQUFRO0lBQ1Y7SUFDQTtRQUNFTCxJQUFJO1FBQ0pDLFFBQVE7UUFDUkMsT0FBTztRQUNQQyxPQUFPO1FBQ1BDLGVBQWU7UUFDZkMsUUFBUTtJQUNWO0lBQ0E7UUFDRUwsSUFBSTtRQUNKQyxRQUFRO1FBQ1JDLE9BQU87UUFDUEMsT0FBTztJQUNUO0NBQ0QsQ0FBQztBQUVLLE1BQU1HLGFBQWE7SUFDeEI7UUFBRUMsTUFBTTtRQUFXQyxPQUFPO0lBQUU7SUFDNUI7UUFBRUQsTUFBTTtRQUFZQyxPQUFPO0lBQUU7SUFDN0I7UUFBRUQsTUFBTTtRQUFXQyxPQUFPO0lBQUU7SUFDNUI7UUFBRUQsTUFBTTtRQUFVQyxPQUFPO0lBQUU7SUFDM0I7UUFBRUQsTUFBTTtRQUFZQyxPQUFPO0lBQUU7SUFDN0I7UUFBRUQsTUFBTTtRQUFVQyxPQUFPO0lBQUU7Q0FDNUIsQ0FBQztBQUVLLE1BQU1DLE9BQU87SUFDbEI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0QsQ0FBQztBQUVLLE1BQU1DLGNBQWM7SUFDekI7UUFDRUMsS0FBSztRQUNMQyxNQUFNO0lBQ1I7SUFDQTtRQUNFRCxLQUFLO1FBQ0xDLE1BQU07SUFDUjtJQUNBO1FBQ0VELEtBQUs7UUFDTEMsTUFBTTtJQUNSO0lBQ0E7UUFDRUQsS0FBSztRQUNMQyxNQUFNO0lBQ1I7Q0FDRCxDQUFDIiwic291cmNlcyI6WyIvVXNlcnMvbXZlbnR1cmEvRG9jdW1lbnRzL0dpdEh1Yi9tb3JwaGUvZGF0YS9wcm9kdWN0cy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY29uc3QgcHJvZHVjdHMgPSBbXG4gIHtcbiAgICBpZDogMSxcbiAgICBpbWdTcmM6IFwiL2Fzc2V0cy9pbWcvcHJvZHVjdC9wcm9kdWN0XzFfMS5qcGdcIixcbiAgICB0aXRsZTogXCJQcmludGVkIFQtU2hpcnRcIixcbiAgICBwcmljZTogMjAuNSxcbiAgICBvcmlnaW5hbFByaWNlOiAyOS41LFxuICAgIGlzU2FsZTogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIGlkOiAyLFxuICAgIGltZ1NyYzogXCIvYXNzZXRzL2ltZy9wcm9kdWN0L3Byb2R1Y3RfMV8yLmpwZ1wiLFxuICAgIHRpdGxlOiBcIkNhcmQgV2FsbGV0XCIsXG4gICAgcHJpY2U6IDUyLFxuICB9LFxuICB7XG4gICAgaWQ6IDMsXG4gICAgaW1nU3JjOiBcIi9hc3NldHMvaW1nL3Byb2R1Y3QvcHJvZHVjdF8xXzMuanBnXCIsXG4gICAgdGl0bGU6IFwiS2ludG8gVHVtYmxlclwiLFxuICAgIHByaWNlOiAzOCxcbiAgfSxcbiAge1xuICAgIGlkOiA0LFxuICAgIGltZ1NyYzogXCIvYXNzZXRzL2ltZy9wcm9kdWN0L3Byb2R1Y3RfMV80LmpwZ1wiLFxuICAgIHRpdGxlOiBcIlJpcHBsZSBDcmV3bmVja1wiLFxuICAgIHByaWNlOiAxNjAuOSxcbiAgfSxcbiAge1xuICAgIGlkOiA1LFxuICAgIGltZ1NyYzogXCIvYXNzZXRzL2ltZy9wcm9kdWN0L3Byb2R1Y3RfMV81LmpwZ1wiLFxuICAgIHRpdGxlOiBcIkhlcm1hbiBNaWxsZXJcIixcbiAgICBwcmljZTogNDQuNSxcbiAgfSxcbiAge1xuICAgIGlkOiA2LFxuICAgIGltZ1NyYzogXCIvYXNzZXRzL2ltZy9wcm9kdWN0L3Byb2R1Y3RfMV82LmpwZ1wiLFxuICAgIHRpdGxlOiBcIktuaXQgQmVhbmllXCIsXG4gICAgcHJpY2U6IDMwLFxuICAgIG9yaWdpbmFsUHJpY2U6IDUwLFxuICAgIGlzU2FsZTogdHJ1ZSxcbiAgfSxcbiAge1xuICAgIGlkOiA3LFxuICAgIGltZ1NyYzogXCIvYXNzZXRzL2ltZy9wcm9kdWN0L3Byb2R1Y3RfMV83LmpwZ1wiLFxuICAgIHRpdGxlOiBcIkJpZm9sZCBXYWxsZXRcIixcbiAgICBwcmljZTogODQuOCxcbiAgICBvcmlnaW5hbFByaWNlOiAxMTAuOCxcbiAgICBpc1NhbGU6IHRydWUsXG4gIH0sXG4gIHtcbiAgICBpZDogOCxcbiAgICBpbWdTcmM6IFwiL2Fzc2V0cy9pbWcvcHJvZHVjdC9wcm9kdWN0XzFfOC5qcGdcIixcbiAgICB0aXRsZTogXCJQaWxsYXJzIFRlZVwiLFxuICAgIHByaWNlOiAyNi45LFxuICB9LFxuXTtcblxuZXhwb3J0IGNvbnN0IGNhdGVnb3JpZXMgPSBbXG4gIHsgbmFtZTogXCJBcmNoaXZlXCIsIGNvdW50OiAzIH0sXG4gIHsgbmFtZTogXCJCcmFuZGluZ1wiLCBjb3VudDogNiB9LFxuICB7IG5hbWU6IFwiQ29tcGFueVwiLCBjb3VudDogMiB9LFxuICB7IG5hbWU6IFwiRGVzaWduXCIsIGNvdW50OiAxIH0sXG4gIHsgbmFtZTogXCJCdXNpbmVzc1wiLCBjb3VudDogNCB9LFxuICB7IG5hbWU6IFwiTW9kZXJuXCIsIGNvdW50OiAxIH0sXG5dO1xuXG5leHBvcnQgY29uc3QgdGFncyA9IFtcbiAgXCJBZ2VuY3lcIixcbiAgXCJBd2FyZHNcIixcbiAgXCJNYXJrZXRpbmdcIixcbiAgXCJCcmFuZFwiLFxuICBcIkNvbnRlbXBvcmFyeVwiLFxuICBcIkRlc2lnblwiLFxuICBcIkVkdWNhdGlvblwiLFxuICBcIkJ1c2luZXNzXCIsXG4gIFwiTW9kZXJuXCIsXG5dO1xuXG5leHBvcnQgY29uc3Qgc29jaWFsTGlua3MgPSBbXG4gIHtcbiAgICB1cmw6IFwiaHR0cHM6Ly93d3cuZmFjZWJvb2suY29tL1wiLFxuICAgIGljb246IFwiZmFiIGZhLWZhY2Vib29rXCIsXG4gIH0sXG4gIHtcbiAgICB1cmw6IFwiaHR0cHM6Ly9pbnN0YWdyYW0uY29tL1wiLFxuICAgIGljb246IFwiZmFiIGZhLWluc3RhZ3JhbVwiLFxuICB9LFxuICB7XG4gICAgdXJsOiBcImh0dHBzOi8vdHdpdHRlci5jb20vXCIsXG4gICAgaWNvbjogXCJmYWIgZmEtdHdpdHRlclwiLFxuICB9LFxuICB7XG4gICAgdXJsOiBcImh0dHBzOi8vZHJpYmJibGUuY29tL1wiLFxuICAgIGljb246IFwiZmFiIGZhLWRyaWJiYmxlXCIsXG4gIH0sXG5dO1xuIl0sIm5hbWVzIjpbInByb2R1Y3RzIiwiaWQiLCJpbWdTcmMiLCJ0aXRsZSIsInByaWNlIiwib3JpZ2luYWxQcmljZSIsImlzU2FsZSIsImNhdGVnb3JpZXMiLCJuYW1lIiwiY291bnQiLCJ0YWdzIiwic29jaWFsTGlua3MiLCJ1cmwiLCJpY29uIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./data/products.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./utils/wow.js":
/*!**********************!*\
  !*** ./utils/wow.js ***!
  \**********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WOW)\n/* harmony export */ });\nvar _MutationObserver;\nfunction isIn(needle, haystack) {\n    return haystack.indexOf(needle) >= 0;\n}\nfunction extend(custom, defaults) {\n    for(const key in defaults){\n        if (custom[key] == null) {\n            const value = defaults[key];\n            custom[key] = value;\n        }\n    }\n    return custom;\n}\nfunction isMobile(agent) {\n    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(agent);\n}\nfunction createEvent(event) {\n    let bubble = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false, cancel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, detail = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;\n    let customEvent;\n    if (document.createEvent != null) {\n        // W3C DOM\n        customEvent = document.createEvent(\"CustomEvent\");\n        customEvent.initCustomEvent(event, bubble, cancel, detail);\n    } else if (document.createEventObject != null) {\n        // IE DOM < 9\n        customEvent = document.createEventObject();\n        customEvent.eventType = event;\n    } else {\n        customEvent.eventName = event;\n    }\n    return customEvent;\n}\nfunction emitEvent(elem, event) {\n    if (elem.dispatchEvent != null) {\n        // W3C DOM\n        elem.dispatchEvent(event);\n    } else if (event in (elem != null)) {\n        elem[event]();\n    } else if (\"on\".concat(event) in (elem != null)) {\n        elem[\"on\".concat(event)]();\n    }\n}\nfunction addEvent(elem, event, fn) {\n    if (elem.addEventListener != null) {\n        // W3C DOM\n        elem.addEventListener(event, fn, false);\n    } else if (elem.attachEvent != null) {\n        // IE DOM\n        elem.attachEvent(\"on\".concat(event), fn);\n    } else {\n        // fallback\n        elem[event] = fn;\n    }\n}\nfunction removeEvent(elem, event, fn) {\n    if (elem.removeEventListener != null) {\n        // W3C DOM\n        elem.removeEventListener(event, fn, false);\n    } else if (elem.detachEvent != null) {\n        // IE DOM\n        elem.detachEvent(\"on\".concat(event), fn);\n    } else {\n        // fallback\n        delete elem[event];\n    }\n}\nfunction getInnerHeight() {\n    if (\"innerHeight\" in window) {\n        return window.innerHeight;\n    }\n    return document.documentElement.clientHeight;\n}\n// Minimalistic WeakMap shim, just in case.\nconst WeakMap = window.WeakMap || window.MozWeakMap || class WeakMap {\n    get(key) {\n        for(let i = 0; i < this.keys.length; i++){\n            const item = this.keys[i];\n            if (item === key) {\n                return this.values[i];\n            }\n        }\n        return undefined;\n    }\n    set(key, value) {\n        for(let i = 0; i < this.keys.length; i++){\n            const item = this.keys[i];\n            if (item === key) {\n                this.values[i] = value;\n                return this;\n            }\n        }\n        this.keys.push(key);\n        this.values.push(value);\n        return this;\n    }\n    constructor(){\n        this.keys = [];\n        this.values = [];\n    }\n};\n// Dummy MutationObserver, to avoid raising exceptions.\nconst MutationObserver = window.MutationObserver || window.WebkitMutationObserver || window.MozMutationObserver || (_MutationObserver = class MutationObserver {\n    observe() {}\n    constructor(){\n        if (typeof console !== \"undefined\" && console !== null) {\n            console.warn(\"MutationObserver is not supported by your browser.\");\n            console.warn(\"WOW.js cannot detect dom mutations, please call .sync() after loading new content.\");\n        }\n    }\n}, _MutationObserver.notSupported = true, _MutationObserver);\n// getComputedStyle shim, from http://stackoverflow.com/a/21797294\nconst getComputedStyle = window.getComputedStyle || function getComputedStyle(el) {\n    const getComputedStyleRX = /(\\-([a-z]){1})/g;\n    return {\n        getPropertyValue (prop) {\n            if (prop === \"float\") {\n                prop = \"styleFloat\";\n            }\n            if (getComputedStyleRX.test(prop)) {\n                prop.replace(getComputedStyleRX, (_, _char)=>_char.toUpperCase());\n            }\n            const { currentStyle } = el;\n            return (currentStyle != null ? currentStyle[prop] : void 0) || null;\n        }\n    };\n};\nclass WOW {\n    init() {\n        this.element = window.document.documentElement;\n        if (isIn(document.readyState, [\n            \"interactive\",\n            \"complete\"\n        ])) {\n            this.start();\n        } else {\n            addEvent(document, \"DOMContentLoaded\", this.start);\n        }\n        this.finished = [];\n    }\n    start() {\n        this.stopped = false;\n        this.boxes = [].slice.call(this.element.querySelectorAll(\".\".concat(this.config.boxClass)));\n        this.all = this.boxes.slice(0);\n        if (this.boxes.length) {\n            if (this.disabled()) {\n                this.resetStyle();\n            } else {\n                for(let i = 0; i < this.boxes.length; i++){\n                    const box = this.boxes[i];\n                    this.applyStyle(box, true);\n                }\n            }\n        }\n        if (!this.disabled()) {\n            addEvent(this.config.scrollContainer || window, \"scroll\", this.scrollHandler);\n            addEvent(window, \"resize\", this.scrollHandler);\n            this.interval = setInterval(this.scrollCallback, 50);\n        }\n        if (this.config.live) {\n            const mut = new MutationObserver((records)=>{\n                for(let j = 0; j < records.length; j++){\n                    const record = records[j];\n                    for(let k = 0; k < record.addedNodes.length; k++){\n                        const node = record.addedNodes[k];\n                        this.doSync(node);\n                    }\n                }\n                return undefined;\n            });\n            mut.observe(document.body, {\n                childList: true,\n                subtree: true\n            });\n        }\n    }\n    // unbind the scroll event\n    stop() {\n        this.stopped = true;\n        removeEvent(this.config.scrollContainer || window, \"scroll\", this.scrollHandler);\n        removeEvent(window, \"resize\", this.scrollHandler);\n        if (this.interval != null) {\n            clearInterval(this.interval);\n        }\n    }\n    sync() {\n        if (MutationObserver.notSupported) {\n            this.doSync(this.element);\n        }\n    }\n    doSync(element) {\n        if (typeof element === \"undefined\" || element === null) {\n            ({ element } = this);\n        }\n        if (element.nodeType !== 1) {\n            return;\n        }\n        element = element.parentNode || element;\n        const iterable = element.querySelectorAll(\".\".concat(this.config.boxClass));\n        for(let i = 0; i < iterable.length; i++){\n            const box = iterable[i];\n            if (!isIn(box, this.all)) {\n                this.boxes.push(box);\n                this.all.push(box);\n                if (this.stopped || this.disabled()) {\n                    this.resetStyle();\n                } else {\n                    this.applyStyle(box, true);\n                }\n                this.scrolled = true;\n            }\n        }\n    }\n    // show box element\n    show(box) {\n        this.applyStyle(box);\n        box.className = \"\".concat(box.className, \" \").concat(this.config.animateClass);\n        if (this.config.callback != null) {\n            this.config.callback(box);\n        }\n        emitEvent(box, this.wowEvent);\n        addEvent(box, \"animationend\", this.resetAnimation);\n        addEvent(box, \"oanimationend\", this.resetAnimation);\n        addEvent(box, \"webkitAnimationEnd\", this.resetAnimation);\n        addEvent(box, \"MSAnimationEnd\", this.resetAnimation);\n        return box;\n    }\n    applyStyle(box, hidden) {\n        const duration = box.getAttribute(\"data-wow-duration\");\n        const delay = box.getAttribute(\"data-wow-delay\");\n        const iteration = box.getAttribute(\"data-wow-iteration\");\n        return this.animate(()=>this.customStyle(box, hidden, duration, delay, iteration));\n    }\n    resetStyle() {\n        for(let i = 0; i < this.boxes.length; i++){\n            const box = this.boxes[i];\n            box.style.visibility = \"visible\";\n        }\n        return undefined;\n    }\n    resetAnimation(event) {\n        if (event.type.toLowerCase().indexOf(\"animationend\") >= 0) {\n            const target = event.target || event.srcElement;\n            target.className = target.className.replace(this.config.animateClass, \"\").trim();\n        }\n    }\n    customStyle(box, hidden, duration, delay, iteration) {\n        if (hidden) {\n            this.cacheAnimationName(box);\n        }\n        box.style.visibility = hidden ? \"hidden\" : \"visible\";\n        if (duration) {\n            this.vendorSet(box.style, {\n                animationDuration: duration\n            });\n        }\n        if (delay) {\n            this.vendorSet(box.style, {\n                animationDelay: delay\n            });\n        }\n        if (iteration) {\n            this.vendorSet(box.style, {\n                animationIterationCount: iteration\n            });\n        }\n        this.vendorSet(box.style, {\n            animationName: hidden ? \"none\" : this.cachedAnimationName(box)\n        });\n        return box;\n    }\n    vendorSet(elem, properties) {\n        for(const name in properties){\n            if (properties.hasOwnProperty(name)) {\n                const value = properties[name];\n                elem[\"\".concat(name)] = value;\n                for(let i = 0; i < this.vendors.length; i++){\n                    const vendor = this.vendors[i];\n                    elem[\"\".concat(vendor).concat(name.charAt(0).toUpperCase()).concat(name.substr(1))] = value;\n                }\n            }\n        }\n    }\n    vendorCSS(elem, property) {\n        const style = getComputedStyle(elem);\n        let result = style.getPropertyCSSValue(property);\n        for(let i = 0; i < this.vendors.length; i++){\n            const vendor = this.vendors[i];\n            result = result || style.getPropertyCSSValue(\"-\".concat(vendor, \"-\").concat(property));\n        }\n        return result;\n    }\n    animationName(box) {\n        let aName;\n        try {\n            aName = this.vendorCSS(box, \"animation-name\").cssText;\n        } catch (error) {\n            // Opera, fall back to plain property value\n            aName = getComputedStyle(box).getPropertyValue(\"animation-name\");\n        }\n        if (aName === \"none\") {\n            return \"\"; // SVG/Firefox, unable to get animation name?\n        }\n        return aName;\n    }\n    cacheAnimationName(box) {\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=921834\n        // box.dataset is not supported for SVG elements in Firefox\n        return this.animationNameCache.set(box, this.animationName(box));\n    }\n    cachedAnimationName(box) {\n        return this.animationNameCache.get(box);\n    }\n    // fast window.scroll callback\n    scrollHandler() {\n        this.scrolled = true;\n    }\n    scrollCallback() {\n        if (this.scrolled) {\n            this.scrolled = false;\n            const results = [];\n            for(let i = 0; i < this.boxes.length; i++){\n                const box = this.boxes[i];\n                if (box) {\n                    if (this.isVisible(box)) {\n                        this.show(box);\n                        continue;\n                    }\n                    results.push(box);\n                }\n            }\n            this.boxes = results;\n            if (!this.boxes.length && !this.config.live) {\n                this.stop();\n            }\n        }\n    }\n    // Calculate element offset top\n    offsetTop(element) {\n        // SVG elements don't have an offsetTop in Firefox.\n        // This will use their nearest parent that has an offsetTop.\n        // Also, using ('offsetTop' of element) causes an exception in Firefox.\n        while(element.offsetTop === undefined){\n            element = element.parentNode;\n        }\n        let top = element.offsetTop;\n        while(element.offsetParent){\n            element = element.offsetParent;\n            top += element.offsetTop;\n        }\n        return top;\n    }\n    // check if box is visible\n    isVisible(box) {\n        const offset = box.getAttribute(\"data-wow-offset\") || this.config.offset;\n        const viewTop = this.config.scrollContainer && this.config.scrollContainer.scrollTop || window.pageYOffset;\n        const viewBottom = viewTop + Math.min(this.element.clientHeight, getInnerHeight()) - offset;\n        const top = this.offsetTop(box);\n        const bottom = top + box.clientHeight;\n        return top <= viewBottom && bottom >= viewTop;\n    }\n    disabled() {\n        return !this.config.mobile && isMobile(navigator.userAgent);\n    }\n    constructor(options = {}){\n        this.defaults = {\n            boxClass: \"wow\",\n            animateClass: \"animated\",\n            offset: 0,\n            mobile: true,\n            live: true,\n            callback: null,\n            scrollContainer: null\n        };\n        this.animate = function animateFactory() {\n            if (\"requestAnimationFrame\" in window) {\n                return (callback)=>window.requestAnimationFrame(callback);\n            }\n            return (callback)=>callback();\n        }();\n        this.vendors = [\n            \"moz\",\n            \"webkit\"\n        ];\n        this.start = this.start.bind(this);\n        this.resetAnimation = this.resetAnimation.bind(this);\n        this.scrollHandler = this.scrollHandler.bind(this);\n        this.scrollCallback = this.scrollCallback.bind(this);\n        this.scrolled = true;\n        this.config = extend(options, this.defaults);\n        if (options.scrollContainer != null) {\n            this.config.scrollContainer = document.querySelector(options.scrollContainer);\n        }\n        // Map of elements to animation names:\n        this.animationNameCache = new WeakMap();\n        this.wowEvent = createEvent(this.config.boxClass);\n    }\n}\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3V0aWxzL3dvdy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFBLFNBQVNBLEtBQUtDLE1BQU0sRUFBRUMsUUFBUTtJQUM1QixPQUFPQSxTQUFTQyxPQUFPLENBQUNGLFdBQVc7QUFDckM7QUFFQSxTQUFTRyxPQUFPQyxNQUFNLEVBQUVDLFFBQVE7SUFDOUIsSUFBSyxNQUFNQyxPQUFPRCxTQUFVO1FBQzFCLElBQUlELE1BQU0sQ0FBQ0UsSUFBSSxJQUFJLE1BQU07WUFDdkIsTUFBTUMsUUFBUUYsUUFBUSxDQUFDQyxJQUFJO1lBQzNCRixNQUFNLENBQUNFLElBQUksR0FBR0M7UUFDaEI7SUFDRjtJQUNBLE9BQU9IO0FBQ1Q7QUFFQSxTQUFTSSxTQUFTQyxLQUFLO0lBQ3JCLE9BQU8saUVBQWlFQyxJQUFJLENBQzFFRDtBQUVKO0FBRUEsU0FBU0UsWUFBWUMsS0FBSztRQUFFQyxTQUFBQSxpRUFBUyxPQUFPQyxTQUFBQSxpRUFBUyxPQUFPQyxTQUFBQSxpRUFBUztJQUNuRSxJQUFJQztJQUNKLElBQUlDLFNBQVNOLFdBQVcsSUFBSSxNQUFNO1FBQ2hDLFVBQVU7UUFDVkssY0FBY0MsU0FBU04sV0FBVyxDQUFDO1FBQ25DSyxZQUFZRSxlQUFlLENBQUNOLE9BQU9DLFFBQVFDLFFBQVFDO0lBQ3JELE9BQU8sSUFBSUUsU0FBU0UsaUJBQWlCLElBQUksTUFBTTtRQUM3QyxhQUFhO1FBQ2JILGNBQWNDLFNBQVNFLGlCQUFpQjtRQUN4Q0gsWUFBWUksU0FBUyxHQUFHUjtJQUMxQixPQUFPO1FBQ0xJLFlBQVlLLFNBQVMsR0FBR1Q7SUFDMUI7SUFFQSxPQUFPSTtBQUNUO0FBRUEsU0FBU00sVUFBVUMsSUFBSSxFQUFFWCxLQUFLO0lBQzVCLElBQUlXLEtBQUtDLGFBQWEsSUFBSSxNQUFNO1FBQzlCLFVBQVU7UUFDVkQsS0FBS0MsYUFBYSxDQUFDWjtJQUNyQixPQUFPLElBQUlBLFNBQVVXLENBQUFBLFFBQVEsSUFBRyxHQUFJO1FBQ2xDQSxJQUFJLENBQUNYLE1BQU07SUFDYixPQUFPLElBQUksS0FBVyxPQUFOQSxVQUFZVyxDQUFBQSxRQUFRLElBQUcsR0FBSTtRQUN6Q0EsSUFBSSxDQUFDLEtBQVcsT0FBTlgsT0FBUTtJQUNwQjtBQUNGO0FBRUEsU0FBU2EsU0FBU0YsSUFBSSxFQUFFWCxLQUFLLEVBQUVjLEVBQUU7SUFDL0IsSUFBSUgsS0FBS0ksZ0JBQWdCLElBQUksTUFBTTtRQUNqQyxVQUFVO1FBQ1ZKLEtBQUtJLGdCQUFnQixDQUFDZixPQUFPYyxJQUFJO0lBQ25DLE9BQU8sSUFBSUgsS0FBS0ssV0FBVyxJQUFJLE1BQU07UUFDbkMsU0FBUztRQUNUTCxLQUFLSyxXQUFXLENBQUMsS0FBVyxPQUFOaEIsUUFBU2M7SUFDakMsT0FBTztRQUNMLFdBQVc7UUFDWEgsSUFBSSxDQUFDWCxNQUFNLEdBQUdjO0lBQ2hCO0FBQ0Y7QUFFQSxTQUFTRyxZQUFZTixJQUFJLEVBQUVYLEtBQUssRUFBRWMsRUFBRTtJQUNsQyxJQUFJSCxLQUFLTyxtQkFBbUIsSUFBSSxNQUFNO1FBQ3BDLFVBQVU7UUFDVlAsS0FBS08sbUJBQW1CLENBQUNsQixPQUFPYyxJQUFJO0lBQ3RDLE9BQU8sSUFBSUgsS0FBS1EsV0FBVyxJQUFJLE1BQU07UUFDbkMsU0FBUztRQUNUUixLQUFLUSxXQUFXLENBQUMsS0FBVyxPQUFObkIsUUFBU2M7SUFDakMsT0FBTztRQUNMLFdBQVc7UUFDWCxPQUFPSCxJQUFJLENBQUNYLE1BQU07SUFDcEI7QUFDRjtBQUVBLFNBQVNvQjtJQUNQLElBQUksaUJBQWlCQyxRQUFRO1FBQzNCLE9BQU9BLE9BQU9DLFdBQVc7SUFDM0I7SUFFQSxPQUFPakIsU0FBU2tCLGVBQWUsQ0FBQ0MsWUFBWTtBQUM5QztBQUVBLDJDQUEyQztBQUMzQyxNQUFNQyxVQUNKSixPQUFPSSxPQUFPLElBQ2RKLE9BQU9LLFVBQVUsSUFDakIsTUFBTUQ7SUFNSkUsSUFBSWpDLEdBQUcsRUFBRTtRQUNQLElBQUssSUFBSWtDLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNDLElBQUksQ0FBQ0MsTUFBTSxFQUFFRixJQUFLO1lBQ3pDLE1BQU1HLE9BQU8sSUFBSSxDQUFDRixJQUFJLENBQUNELEVBQUU7WUFDekIsSUFBSUcsU0FBU3JDLEtBQUs7Z0JBQ2hCLE9BQU8sSUFBSSxDQUFDc0MsTUFBTSxDQUFDSixFQUFFO1lBQ3ZCO1FBQ0Y7UUFDQSxPQUFPSztJQUNUO0lBRUFDLElBQUl4QyxHQUFHLEVBQUVDLEtBQUssRUFBRTtRQUNkLElBQUssSUFBSWlDLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNDLElBQUksQ0FBQ0MsTUFBTSxFQUFFRixJQUFLO1lBQ3pDLE1BQU1HLE9BQU8sSUFBSSxDQUFDRixJQUFJLENBQUNELEVBQUU7WUFDekIsSUFBSUcsU0FBU3JDLEtBQUs7Z0JBQ2hCLElBQUksQ0FBQ3NDLE1BQU0sQ0FBQ0osRUFBRSxHQUFHakM7Z0JBQ2pCLE9BQU8sSUFBSTtZQUNiO1FBQ0Y7UUFDQSxJQUFJLENBQUNrQyxJQUFJLENBQUNNLElBQUksQ0FBQ3pDO1FBQ2YsSUFBSSxDQUFDc0MsTUFBTSxDQUFDRyxJQUFJLENBQUN4QztRQUNqQixPQUFPLElBQUk7SUFDYjtJQTFCQXlDLGFBQWM7UUFDWixJQUFJLENBQUNQLElBQUksR0FBRyxFQUFFO1FBQ2QsSUFBSSxDQUFDRyxNQUFNLEdBQUcsRUFBRTtJQUNsQjtBQXdCRjtBQUVGLHVEQUF1RDtBQUN2RCxNQUFNSyxtQkFDSmhCLE9BQU9nQixnQkFBZ0IsSUFDdkJoQixPQUFPaUIsc0JBQXNCLElBQzdCakIsT0FBT2tCLG1CQUFtQix5QkFDMUIsTUFBTUY7SUFZSkcsVUFBVSxDQUFDO0lBWFhKLGFBQWM7UUFDWixJQUFJLE9BQU9LLFlBQVksZUFBZUEsWUFBWSxNQUFNO1lBQ3REQSxRQUFRQyxJQUFJLENBQUM7WUFDYkQsUUFBUUMsSUFBSSxDQUNWO1FBRUo7SUFDRjtBQUtGLHFCQUhTQyxlQUFlO0FBSzFCLGtFQUFrRTtBQUNsRSxNQUFNQyxtQkFDSnZCLE9BQU91QixnQkFBZ0IsSUFDdkIsU0FBU0EsaUJBQWlCQyxFQUFFO0lBQzFCLE1BQU1DLHFCQUFxQjtJQUMzQixPQUFPO1FBQ0xDLGtCQUFpQkMsSUFBSTtZQUNuQixJQUFJQSxTQUFTLFNBQVM7Z0JBQ3BCQSxPQUFPO1lBQ1Q7WUFDQSxJQUFJRixtQkFBbUJoRCxJQUFJLENBQUNrRCxPQUFPO2dCQUNqQ0EsS0FBS0MsT0FBTyxDQUFDSCxvQkFBb0IsQ0FBQ0ksR0FBR0MsUUFBVUEsTUFBTUMsV0FBVztZQUNsRTtZQUNBLE1BQU0sRUFBRUMsWUFBWSxFQUFFLEdBQUdSO1lBQ3pCLE9BQU8sQ0FBQ1EsZ0JBQWdCLE9BQU9BLFlBQVksQ0FBQ0wsS0FBSyxHQUFHLEtBQUssTUFBTTtRQUNqRTtJQUNGO0FBQ0Y7QUFFYSxNQUFNTTtJQTRCbkJDLE9BQU87UUFDTCxJQUFJLENBQUNDLE9BQU8sR0FBR25DLE9BQU9oQixRQUFRLENBQUNrQixlQUFlO1FBQzlDLElBQUlwQyxLQUFLa0IsU0FBU29ELFVBQVUsRUFBRTtZQUFDO1lBQWU7U0FBVyxHQUFHO1lBQzFELElBQUksQ0FBQ0MsS0FBSztRQUNaLE9BQU87WUFDTDdDLFNBQVNSLFVBQVUsb0JBQW9CLElBQUksQ0FBQ3FELEtBQUs7UUFDbkQ7UUFDQSxJQUFJLENBQUNDLFFBQVEsR0FBRyxFQUFFO0lBQ3BCO0lBRUFELFFBQVE7UUFDTixJQUFJLENBQUNFLE9BQU8sR0FBRztRQUNmLElBQUksQ0FBQ0MsS0FBSyxHQUFHLEVBQUUsQ0FBQ0MsS0FBSyxDQUFDQyxJQUFJLENBQ3hCLElBQUksQ0FBQ1AsT0FBTyxDQUFDUSxnQkFBZ0IsQ0FBQyxJQUF5QixPQUFyQixJQUFJLENBQUNDLE1BQU0sQ0FBQ0MsUUFBUTtRQUV4RCxJQUFJLENBQUNDLEdBQUcsR0FBRyxJQUFJLENBQUNOLEtBQUssQ0FBQ0MsS0FBSyxDQUFDO1FBQzVCLElBQUksSUFBSSxDQUFDRCxLQUFLLENBQUMvQixNQUFNLEVBQUU7WUFDckIsSUFBSSxJQUFJLENBQUNzQyxRQUFRLElBQUk7Z0JBQ25CLElBQUksQ0FBQ0MsVUFBVTtZQUNqQixPQUFPO2dCQUNMLElBQUssSUFBSXpDLElBQUksR0FBR0EsSUFBSSxJQUFJLENBQUNpQyxLQUFLLENBQUMvQixNQUFNLEVBQUVGLElBQUs7b0JBQzFDLE1BQU0wQyxNQUFNLElBQUksQ0FBQ1QsS0FBSyxDQUFDakMsRUFBRTtvQkFDekIsSUFBSSxDQUFDMkMsVUFBVSxDQUFDRCxLQUFLO2dCQUN2QjtZQUNGO1FBQ0Y7UUFDQSxJQUFJLENBQUMsSUFBSSxDQUFDRixRQUFRLElBQUk7WUFDcEJ2RCxTQUNFLElBQUksQ0FBQ29ELE1BQU0sQ0FBQ08sZUFBZSxJQUFJbkQsUUFDL0IsVUFDQSxJQUFJLENBQUNvRCxhQUFhO1lBRXBCNUQsU0FBU1EsUUFBUSxVQUFVLElBQUksQ0FBQ29ELGFBQWE7WUFDN0MsSUFBSSxDQUFDQyxRQUFRLEdBQUdDLFlBQVksSUFBSSxDQUFDQyxjQUFjLEVBQUU7UUFDbkQ7UUFDQSxJQUFJLElBQUksQ0FBQ1gsTUFBTSxDQUFDWSxJQUFJLEVBQUU7WUFDcEIsTUFBTUMsTUFBTSxJQUFJekMsaUJBQWlCLENBQUMwQztnQkFDaEMsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlELFFBQVFqRCxNQUFNLEVBQUVrRCxJQUFLO29CQUN2QyxNQUFNQyxTQUFTRixPQUFPLENBQUNDLEVBQUU7b0JBQ3pCLElBQUssSUFBSUUsSUFBSSxHQUFHQSxJQUFJRCxPQUFPRSxVQUFVLENBQUNyRCxNQUFNLEVBQUVvRCxJQUFLO3dCQUNqRCxNQUFNRSxPQUFPSCxPQUFPRSxVQUFVLENBQUNELEVBQUU7d0JBQ2pDLElBQUksQ0FBQ0csTUFBTSxDQUFDRDtvQkFDZDtnQkFDRjtnQkFDQSxPQUFPbkQ7WUFDVDtZQUNBNkMsSUFBSXRDLE9BQU8sQ0FBQ25DLFNBQVNpRixJQUFJLEVBQUU7Z0JBQ3pCQyxXQUFXO2dCQUNYQyxTQUFTO1lBQ1g7UUFDRjtJQUNGO0lBRUEsMEJBQTBCO0lBQzFCQyxPQUFPO1FBQ0wsSUFBSSxDQUFDN0IsT0FBTyxHQUFHO1FBQ2YzQyxZQUNFLElBQUksQ0FBQ2dELE1BQU0sQ0FBQ08sZUFBZSxJQUFJbkQsUUFDL0IsVUFDQSxJQUFJLENBQUNvRCxhQUFhO1FBRXBCeEQsWUFBWUksUUFBUSxVQUFVLElBQUksQ0FBQ29ELGFBQWE7UUFDaEQsSUFBSSxJQUFJLENBQUNDLFFBQVEsSUFBSSxNQUFNO1lBQ3pCZ0IsY0FBYyxJQUFJLENBQUNoQixRQUFRO1FBQzdCO0lBQ0Y7SUFFQWlCLE9BQU87UUFDTCxJQUFJdEQsaUJBQWlCTSxZQUFZLEVBQUU7WUFDakMsSUFBSSxDQUFDMEMsTUFBTSxDQUFDLElBQUksQ0FBQzdCLE9BQU87UUFDMUI7SUFDRjtJQUVBNkIsT0FBTzdCLE9BQU8sRUFBRTtRQUNkLElBQUksT0FBT0EsWUFBWSxlQUFlQSxZQUFZLE1BQU07WUFDckQsR0FBRUEsT0FBTyxFQUFFLEdBQUcsSUFBSTtRQUNyQjtRQUNBLElBQUlBLFFBQVFvQyxRQUFRLEtBQUssR0FBRztZQUMxQjtRQUNGO1FBQ0FwQyxVQUFVQSxRQUFRcUMsVUFBVSxJQUFJckM7UUFDaEMsTUFBTXNDLFdBQVd0QyxRQUFRUSxnQkFBZ0IsQ0FBQyxJQUF5QixPQUFyQixJQUFJLENBQUNDLE1BQU0sQ0FBQ0MsUUFBUTtRQUNsRSxJQUFLLElBQUl0QyxJQUFJLEdBQUdBLElBQUlrRSxTQUFTaEUsTUFBTSxFQUFFRixJQUFLO1lBQ3hDLE1BQU0wQyxNQUFNd0IsUUFBUSxDQUFDbEUsRUFBRTtZQUN2QixJQUFJLENBQUN6QyxLQUFLbUYsS0FBSyxJQUFJLENBQUNILEdBQUcsR0FBRztnQkFDeEIsSUFBSSxDQUFDTixLQUFLLENBQUMxQixJQUFJLENBQUNtQztnQkFDaEIsSUFBSSxDQUFDSCxHQUFHLENBQUNoQyxJQUFJLENBQUNtQztnQkFDZCxJQUFJLElBQUksQ0FBQ1YsT0FBTyxJQUFJLElBQUksQ0FBQ1EsUUFBUSxJQUFJO29CQUNuQyxJQUFJLENBQUNDLFVBQVU7Z0JBQ2pCLE9BQU87b0JBQ0wsSUFBSSxDQUFDRSxVQUFVLENBQUNELEtBQUs7Z0JBQ3ZCO2dCQUNBLElBQUksQ0FBQ3lCLFFBQVEsR0FBRztZQUNsQjtRQUNGO0lBQ0Y7SUFFQSxtQkFBbUI7SUFDbkJDLEtBQUsxQixHQUFHLEVBQUU7UUFDUixJQUFJLENBQUNDLFVBQVUsQ0FBQ0Q7UUFDaEJBLElBQUkyQixTQUFTLEdBQUcsR0FBb0IsT0FBakIzQixJQUFJMkIsU0FBUyxFQUFDLEtBQTRCLE9BQXpCLElBQUksQ0FBQ2hDLE1BQU0sQ0FBQ2lDLFlBQVk7UUFDNUQsSUFBSSxJQUFJLENBQUNqQyxNQUFNLENBQUNrQyxRQUFRLElBQUksTUFBTTtZQUNoQyxJQUFJLENBQUNsQyxNQUFNLENBQUNrQyxRQUFRLENBQUM3QjtRQUN2QjtRQUNBNUQsVUFBVTRELEtBQUssSUFBSSxDQUFDOEIsUUFBUTtRQUU1QnZGLFNBQVN5RCxLQUFLLGdCQUFnQixJQUFJLENBQUMrQixjQUFjO1FBQ2pEeEYsU0FBU3lELEtBQUssaUJBQWlCLElBQUksQ0FBQytCLGNBQWM7UUFDbER4RixTQUFTeUQsS0FBSyxzQkFBc0IsSUFBSSxDQUFDK0IsY0FBYztRQUN2RHhGLFNBQVN5RCxLQUFLLGtCQUFrQixJQUFJLENBQUMrQixjQUFjO1FBRW5ELE9BQU8vQjtJQUNUO0lBRUFDLFdBQVdELEdBQUcsRUFBRWdDLE1BQU0sRUFBRTtRQUN0QixNQUFNQyxXQUFXakMsSUFBSWtDLFlBQVksQ0FBQztRQUNsQyxNQUFNQyxRQUFRbkMsSUFBSWtDLFlBQVksQ0FBQztRQUMvQixNQUFNRSxZQUFZcEMsSUFBSWtDLFlBQVksQ0FBQztRQUVuQyxPQUFPLElBQUksQ0FBQ0csT0FBTyxDQUFDLElBQ2xCLElBQUksQ0FBQ0MsV0FBVyxDQUFDdEMsS0FBS2dDLFFBQVFDLFVBQVVFLE9BQU9DO0lBRW5EO0lBU0FyQyxhQUFhO1FBQ1gsSUFBSyxJQUFJekMsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ2lDLEtBQUssQ0FBQy9CLE1BQU0sRUFBRUYsSUFBSztZQUMxQyxNQUFNMEMsTUFBTSxJQUFJLENBQUNULEtBQUssQ0FBQ2pDLEVBQUU7WUFDekIwQyxJQUFJdUMsS0FBSyxDQUFDQyxVQUFVLEdBQUc7UUFDekI7UUFDQSxPQUFPN0U7SUFDVDtJQUVBb0UsZUFBZXJHLEtBQUssRUFBRTtRQUNwQixJQUFJQSxNQUFNK0csSUFBSSxDQUFDQyxXQUFXLEdBQUcxSCxPQUFPLENBQUMsbUJBQW1CLEdBQUc7WUFDekQsTUFBTTJILFNBQVNqSCxNQUFNaUgsTUFBTSxJQUFJakgsTUFBTWtILFVBQVU7WUFDL0NELE9BQU9oQixTQUFTLEdBQUdnQixPQUFPaEIsU0FBUyxDQUNoQ2hELE9BQU8sQ0FBQyxJQUFJLENBQUNnQixNQUFNLENBQUNpQyxZQUFZLEVBQUUsSUFDbENpQixJQUFJO1FBQ1Q7SUFDRjtJQUVBUCxZQUFZdEMsR0FBRyxFQUFFZ0MsTUFBTSxFQUFFQyxRQUFRLEVBQUVFLEtBQUssRUFBRUMsU0FBUyxFQUFFO1FBQ25ELElBQUlKLFFBQVE7WUFDVixJQUFJLENBQUNjLGtCQUFrQixDQUFDOUM7UUFDMUI7UUFDQUEsSUFBSXVDLEtBQUssQ0FBQ0MsVUFBVSxHQUFHUixTQUFTLFdBQVc7UUFFM0MsSUFBSUMsVUFBVTtZQUNaLElBQUksQ0FBQ2MsU0FBUyxDQUFDL0MsSUFBSXVDLEtBQUssRUFBRTtnQkFBRVMsbUJBQW1CZjtZQUFTO1FBQzFEO1FBQ0EsSUFBSUUsT0FBTztZQUNULElBQUksQ0FBQ1ksU0FBUyxDQUFDL0MsSUFBSXVDLEtBQUssRUFBRTtnQkFBRVUsZ0JBQWdCZDtZQUFNO1FBQ3BEO1FBQ0EsSUFBSUMsV0FBVztZQUNiLElBQUksQ0FBQ1csU0FBUyxDQUFDL0MsSUFBSXVDLEtBQUssRUFBRTtnQkFBRVcseUJBQXlCZDtZQUFVO1FBQ2pFO1FBQ0EsSUFBSSxDQUFDVyxTQUFTLENBQUMvQyxJQUFJdUMsS0FBSyxFQUFFO1lBQ3hCWSxlQUFlbkIsU0FBUyxTQUFTLElBQUksQ0FBQ29CLG1CQUFtQixDQUFDcEQ7UUFDNUQ7UUFFQSxPQUFPQTtJQUNUO0lBR0ErQyxVQUFVMUcsSUFBSSxFQUFFZ0gsVUFBVSxFQUFFO1FBQzFCLElBQUssTUFBTUMsUUFBUUQsV0FBWTtZQUM3QixJQUFJQSxXQUFXRSxjQUFjLENBQUNELE9BQU87Z0JBQ25DLE1BQU1qSSxRQUFRZ0ksVUFBVSxDQUFDQyxLQUFLO2dCQUM5QmpILElBQUksQ0FBQyxHQUFRLE9BQUxpSCxNQUFPLEdBQUdqSTtnQkFDbEIsSUFBSyxJQUFJaUMsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ2tHLE9BQU8sQ0FBQ2hHLE1BQU0sRUFBRUYsSUFBSztvQkFDNUMsTUFBTW1HLFNBQVMsSUFBSSxDQUFDRCxPQUFPLENBQUNsRyxFQUFFO29CQUM5QmpCLElBQUksQ0FBQyxHQUFZaUgsT0FBVEcsUUFBd0NILE9BQS9CQSxLQUFLSSxNQUFNLENBQUMsR0FBRzVFLFdBQVcsSUFBb0IsT0FBZndFLEtBQUtLLE1BQU0sQ0FBQyxJQUFLLEdBQy9EdEk7Z0JBQ0o7WUFDRjtRQUNGO0lBQ0Y7SUFDQXVJLFVBQVV2SCxJQUFJLEVBQUV3SCxRQUFRLEVBQUU7UUFDeEIsTUFBTXRCLFFBQVFqRSxpQkFBaUJqQztRQUMvQixJQUFJeUgsU0FBU3ZCLE1BQU13QixtQkFBbUIsQ0FBQ0Y7UUFDdkMsSUFBSyxJQUFJdkcsSUFBSSxHQUFHQSxJQUFJLElBQUksQ0FBQ2tHLE9BQU8sQ0FBQ2hHLE1BQU0sRUFBRUYsSUFBSztZQUM1QyxNQUFNbUcsU0FBUyxJQUFJLENBQUNELE9BQU8sQ0FBQ2xHLEVBQUU7WUFDOUJ3RyxTQUFTQSxVQUFVdkIsTUFBTXdCLG1CQUFtQixDQUFDLElBQWNGLE9BQVZKLFFBQU8sS0FBWSxPQUFUSTtRQUM3RDtRQUNBLE9BQU9DO0lBQ1Q7SUFFQVgsY0FBY25ELEdBQUcsRUFBRTtRQUNqQixJQUFJZ0U7UUFDSixJQUFJO1lBQ0ZBLFFBQVEsSUFBSSxDQUFDSixTQUFTLENBQUM1RCxLQUFLLGtCQUFrQmlFLE9BQU87UUFDdkQsRUFBRSxPQUFPQyxPQUFPO1lBQ2QsMkNBQTJDO1lBQzNDRixRQUFRMUYsaUJBQWlCMEIsS0FBS3ZCLGdCQUFnQixDQUFDO1FBQ2pEO1FBRUEsSUFBSXVGLFVBQVUsUUFBUTtZQUNwQixPQUFPLElBQUksNkNBQTZDO1FBQzFEO1FBRUEsT0FBT0E7SUFDVDtJQUVBbEIsbUJBQW1COUMsR0FBRyxFQUFFO1FBQ3RCLHNEQUFzRDtRQUN0RCwyREFBMkQ7UUFDM0QsT0FBTyxJQUFJLENBQUNtRSxrQkFBa0IsQ0FBQ3ZHLEdBQUcsQ0FBQ29DLEtBQUssSUFBSSxDQUFDbUQsYUFBYSxDQUFDbkQ7SUFDN0Q7SUFDQW9ELG9CQUFvQnBELEdBQUcsRUFBRTtRQUN2QixPQUFPLElBQUksQ0FBQ21FLGtCQUFrQixDQUFDOUcsR0FBRyxDQUFDMkM7SUFDckM7SUFFQSw4QkFBOEI7SUFDOUJHLGdCQUFnQjtRQUNkLElBQUksQ0FBQ3NCLFFBQVEsR0FBRztJQUNsQjtJQUVBbkIsaUJBQWlCO1FBQ2YsSUFBSSxJQUFJLENBQUNtQixRQUFRLEVBQUU7WUFDakIsSUFBSSxDQUFDQSxRQUFRLEdBQUc7WUFDaEIsTUFBTTJDLFVBQVUsRUFBRTtZQUNsQixJQUFLLElBQUk5RyxJQUFJLEdBQUdBLElBQUksSUFBSSxDQUFDaUMsS0FBSyxDQUFDL0IsTUFBTSxFQUFFRixJQUFLO2dCQUMxQyxNQUFNMEMsTUFBTSxJQUFJLENBQUNULEtBQUssQ0FBQ2pDLEVBQUU7Z0JBQ3pCLElBQUkwQyxLQUFLO29CQUNQLElBQUksSUFBSSxDQUFDcUUsU0FBUyxDQUFDckUsTUFBTTt3QkFDdkIsSUFBSSxDQUFDMEIsSUFBSSxDQUFDMUI7d0JBQ1Y7b0JBQ0Y7b0JBQ0FvRSxRQUFRdkcsSUFBSSxDQUFDbUM7Z0JBQ2Y7WUFDRjtZQUNBLElBQUksQ0FBQ1QsS0FBSyxHQUFHNkU7WUFDYixJQUFJLENBQUMsSUFBSSxDQUFDN0UsS0FBSyxDQUFDL0IsTUFBTSxJQUFJLENBQUMsSUFBSSxDQUFDbUMsTUFBTSxDQUFDWSxJQUFJLEVBQUU7Z0JBQzNDLElBQUksQ0FBQ1ksSUFBSTtZQUNYO1FBQ0Y7SUFDRjtJQUVBLCtCQUErQjtJQUMvQm1ELFVBQVVwRixPQUFPLEVBQUU7UUFDakIsbURBQW1EO1FBQ25ELDREQUE0RDtRQUM1RCx1RUFBdUU7UUFDdkUsTUFBT0EsUUFBUW9GLFNBQVMsS0FBSzNHLFVBQVc7WUFDdEN1QixVQUFVQSxRQUFRcUMsVUFBVTtRQUM5QjtRQUNBLElBQUlnRCxNQUFNckYsUUFBUW9GLFNBQVM7UUFDM0IsTUFBT3BGLFFBQVFzRixZQUFZLENBQUU7WUFDM0J0RixVQUFVQSxRQUFRc0YsWUFBWTtZQUM5QkQsT0FBT3JGLFFBQVFvRixTQUFTO1FBQzFCO1FBQ0EsT0FBT0M7SUFDVDtJQUVBLDBCQUEwQjtJQUMxQkYsVUFBVXJFLEdBQUcsRUFBRTtRQUNiLE1BQU15RSxTQUFTekUsSUFBSWtDLFlBQVksQ0FBQyxzQkFBc0IsSUFBSSxDQUFDdkMsTUFBTSxDQUFDOEUsTUFBTTtRQUN4RSxNQUFNQyxVQUNKLElBQUssQ0FBQy9FLE1BQU0sQ0FBQ08sZUFBZSxJQUFJLElBQUksQ0FBQ1AsTUFBTSxDQUFDTyxlQUFlLENBQUN5RSxTQUFTLElBQ3JFNUgsT0FBTzZILFdBQVc7UUFDcEIsTUFBTUMsYUFDSkgsVUFBVUksS0FBS0MsR0FBRyxDQUFDLElBQUksQ0FBQzdGLE9BQU8sQ0FBQ2hDLFlBQVksRUFBRUosb0JBQW9CMkg7UUFDcEUsTUFBTUYsTUFBTSxJQUFJLENBQUNELFNBQVMsQ0FBQ3RFO1FBQzNCLE1BQU1nRixTQUFTVCxNQUFNdkUsSUFBSTlDLFlBQVk7UUFFckMsT0FBT3FILE9BQU9NLGNBQWNHLFVBQVVOO0lBQ3hDO0lBRUE1RSxXQUFXO1FBQ1QsT0FBTyxDQUFDLElBQUksQ0FBQ0gsTUFBTSxDQUFDc0YsTUFBTSxJQUFJM0osU0FBUzRKLFVBQVVDLFNBQVM7SUFDNUQ7SUF0U0FySCxZQUFZc0gsVUFBVSxDQUFDLENBQUMsQ0FBRTthQVYxQmpLLFdBQVc7WUFDVHlFLFVBQVU7WUFDVmdDLGNBQWM7WUFDZDZDLFFBQVE7WUFDUlEsUUFBUTtZQUNSMUUsTUFBTTtZQUNOc0IsVUFBVTtZQUNWM0IsaUJBQWlCO1FBQ25CO2FBK0lBbUMsVUFBVSxTQUFVZ0Q7WUFDbEIsSUFBSSwyQkFBMkJ0SSxRQUFRO2dCQUNyQyxPQUFPLENBQUM4RSxXQUFhOUUsT0FBT3VJLHFCQUFxQixDQUFDekQ7WUFDcEQ7WUFDQSxPQUFPLENBQUNBLFdBQWFBO1FBQ3ZCO2FBeUNBMkIsVUFBVTtZQUFDO1lBQU87U0FBUztRQTFMekIsSUFBSSxDQUFDcEUsS0FBSyxHQUFHLElBQUksQ0FBQ0EsS0FBSyxDQUFDbUcsSUFBSSxDQUFDLElBQUk7UUFDakMsSUFBSSxDQUFDeEQsY0FBYyxHQUFHLElBQUksQ0FBQ0EsY0FBYyxDQUFDd0QsSUFBSSxDQUFDLElBQUk7UUFDbkQsSUFBSSxDQUFDcEYsYUFBYSxHQUFHLElBQUksQ0FBQ0EsYUFBYSxDQUFDb0YsSUFBSSxDQUFDLElBQUk7UUFDakQsSUFBSSxDQUFDakYsY0FBYyxHQUFHLElBQUksQ0FBQ0EsY0FBYyxDQUFDaUYsSUFBSSxDQUFDLElBQUk7UUFDbkQsSUFBSSxDQUFDOUQsUUFBUSxHQUFHO1FBQ2hCLElBQUksQ0FBQzlCLE1BQU0sR0FBRzFFLE9BQU9tSyxTQUFTLElBQUksQ0FBQ2pLLFFBQVE7UUFDM0MsSUFBSWlLLFFBQVFsRixlQUFlLElBQUksTUFBTTtZQUNuQyxJQUFJLENBQUNQLE1BQU0sQ0FBQ08sZUFBZSxHQUFHbkUsU0FBU3lKLGFBQWEsQ0FDbERKLFFBQVFsRixlQUFlO1FBRTNCO1FBQ0Esc0NBQXNDO1FBQ3RDLElBQUksQ0FBQ2lFLGtCQUFrQixHQUFHLElBQUloSDtRQUM5QixJQUFJLENBQUMyRSxRQUFRLEdBQUdyRyxZQUFZLElBQUksQ0FBQ2tFLE1BQU0sQ0FBQ0MsUUFBUTtJQUNsRDtBQXdSRjtBQUFDIiwic291cmNlcyI6WyIvVXNlcnMvbXZlbnR1cmEvRG9jdW1lbnRzL0dpdEh1Yi9tb3JwaGUvdXRpbHMvd293LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIGlzSW4obmVlZGxlLCBoYXlzdGFjaykge1xuICByZXR1cm4gaGF5c3RhY2suaW5kZXhPZihuZWVkbGUpID49IDA7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZChjdXN0b20sIGRlZmF1bHRzKSB7XG4gIGZvciAoY29uc3Qga2V5IGluIGRlZmF1bHRzKSB7XG4gICAgaWYgKGN1c3RvbVtrZXldID09IG51bGwpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gZGVmYXVsdHNba2V5XTtcbiAgICAgIGN1c3RvbVtrZXldID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBjdXN0b207XG59XG5cbmZ1bmN0aW9uIGlzTW9iaWxlKGFnZW50KSB7XG4gIHJldHVybiAvQW5kcm9pZHx3ZWJPU3xpUGhvbmV8aVBhZHxpUG9kfEJsYWNrQmVycnl8SUVNb2JpbGV8T3BlcmEgTWluaS9pLnRlc3QoXG4gICAgYWdlbnRcbiAgKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRXZlbnQoZXZlbnQsIGJ1YmJsZSA9IGZhbHNlLCBjYW5jZWwgPSBmYWxzZSwgZGV0YWlsID0gbnVsbCkge1xuICBsZXQgY3VzdG9tRXZlbnQ7XG4gIGlmIChkb2N1bWVudC5jcmVhdGVFdmVudCAhPSBudWxsKSB7XG4gICAgLy8gVzNDIERPTVxuICAgIGN1c3RvbUV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJDdXN0b21FdmVudFwiKTtcbiAgICBjdXN0b21FdmVudC5pbml0Q3VzdG9tRXZlbnQoZXZlbnQsIGJ1YmJsZSwgY2FuY2VsLCBkZXRhaWwpO1xuICB9IGVsc2UgaWYgKGRvY3VtZW50LmNyZWF0ZUV2ZW50T2JqZWN0ICE9IG51bGwpIHtcbiAgICAvLyBJRSBET00gPCA5XG4gICAgY3VzdG9tRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudE9iamVjdCgpO1xuICAgIGN1c3RvbUV2ZW50LmV2ZW50VHlwZSA9IGV2ZW50O1xuICB9IGVsc2Uge1xuICAgIGN1c3RvbUV2ZW50LmV2ZW50TmFtZSA9IGV2ZW50O1xuICB9XG5cbiAgcmV0dXJuIGN1c3RvbUV2ZW50O1xufVxuXG5mdW5jdGlvbiBlbWl0RXZlbnQoZWxlbSwgZXZlbnQpIHtcbiAgaWYgKGVsZW0uZGlzcGF0Y2hFdmVudCAhPSBudWxsKSB7XG4gICAgLy8gVzNDIERPTVxuICAgIGVsZW0uZGlzcGF0Y2hFdmVudChldmVudCk7XG4gIH0gZWxzZSBpZiAoZXZlbnQgaW4gKGVsZW0gIT0gbnVsbCkpIHtcbiAgICBlbGVtW2V2ZW50XSgpO1xuICB9IGVsc2UgaWYgKGBvbiR7ZXZlbnR9YCBpbiAoZWxlbSAhPSBudWxsKSkge1xuICAgIGVsZW1bYG9uJHtldmVudH1gXSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGFkZEV2ZW50KGVsZW0sIGV2ZW50LCBmbikge1xuICBpZiAoZWxlbS5hZGRFdmVudExpc3RlbmVyICE9IG51bGwpIHtcbiAgICAvLyBXM0MgRE9NXG4gICAgZWxlbS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmbiwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKGVsZW0uYXR0YWNoRXZlbnQgIT0gbnVsbCkge1xuICAgIC8vIElFIERPTVxuICAgIGVsZW0uYXR0YWNoRXZlbnQoYG9uJHtldmVudH1gLCBmbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gZmFsbGJhY2tcbiAgICBlbGVtW2V2ZW50XSA9IGZuO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50KGVsZW0sIGV2ZW50LCBmbikge1xuICBpZiAoZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICE9IG51bGwpIHtcbiAgICAvLyBXM0MgRE9NXG4gICAgZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBmbiwgZmFsc2UpO1xuICB9IGVsc2UgaWYgKGVsZW0uZGV0YWNoRXZlbnQgIT0gbnVsbCkge1xuICAgIC8vIElFIERPTVxuICAgIGVsZW0uZGV0YWNoRXZlbnQoYG9uJHtldmVudH1gLCBmbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gZmFsbGJhY2tcbiAgICBkZWxldGUgZWxlbVtldmVudF07XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0SW5uZXJIZWlnaHQoKSB7XG4gIGlmIChcImlubmVySGVpZ2h0XCIgaW4gd2luZG93KSB7XG4gICAgcmV0dXJuIHdpbmRvdy5pbm5lckhlaWdodDtcbiAgfVxuXG4gIHJldHVybiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xufVxuXG4vLyBNaW5pbWFsaXN0aWMgV2Vha01hcCBzaGltLCBqdXN0IGluIGNhc2UuXG5jb25zdCBXZWFrTWFwID1cbiAgd2luZG93LldlYWtNYXAgfHxcbiAgd2luZG93Lk1veldlYWtNYXAgfHxcbiAgY2xhc3MgV2Vha01hcCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICB0aGlzLmtleXMgPSBbXTtcbiAgICAgIHRoaXMudmFsdWVzID0gW107XG4gICAgfVxuXG4gICAgZ2V0KGtleSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMua2V5c1tpXTtcbiAgICAgICAgaWYgKGl0ZW0gPT09IGtleSkge1xuICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlc1tpXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBzZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMua2V5c1tpXTtcbiAgICAgICAgaWYgKGl0ZW0gPT09IGtleSkge1xuICAgICAgICAgIHRoaXMudmFsdWVzW2ldID0gdmFsdWU7XG4gICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMua2V5cy5wdXNoKGtleSk7XG4gICAgICB0aGlzLnZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcblxuLy8gRHVtbXkgTXV0YXRpb25PYnNlcnZlciwgdG8gYXZvaWQgcmFpc2luZyBleGNlcHRpb25zLlxuY29uc3QgTXV0YXRpb25PYnNlcnZlciA9XG4gIHdpbmRvdy5NdXRhdGlvbk9ic2VydmVyIHx8XG4gIHdpbmRvdy5XZWJraXRNdXRhdGlvbk9ic2VydmVyIHx8XG4gIHdpbmRvdy5Nb3pNdXRhdGlvbk9ic2VydmVyIHx8XG4gIGNsYXNzIE11dGF0aW9uT2JzZXJ2ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnNvbGUgIT09IG51bGwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiTXV0YXRpb25PYnNlcnZlciBpcyBub3Qgc3VwcG9ydGVkIGJ5IHlvdXIgYnJvd3Nlci5cIik7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBcIldPVy5qcyBjYW5ub3QgZGV0ZWN0IGRvbSBtdXRhdGlvbnMsIHBsZWFzZSBjYWxsIC5zeW5jKCkgYWZ0ZXIgbG9hZGluZyBuZXcgY29udGVudC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRpYyBub3RTdXBwb3J0ZWQgPSB0cnVlO1xuXG4gICAgb2JzZXJ2ZSgpIHt9XG4gIH07XG5cbi8vIGdldENvbXB1dGVkU3R5bGUgc2hpbSwgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMTc5NzI5NFxuY29uc3QgZ2V0Q29tcHV0ZWRTdHlsZSA9XG4gIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlIHx8XG4gIGZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUoZWwpIHtcbiAgICBjb25zdCBnZXRDb21wdXRlZFN0eWxlUlggPSAvKFxcLShbYS16XSl7MX0pL2c7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdldFByb3BlcnR5VmFsdWUocHJvcCkge1xuICAgICAgICBpZiAocHJvcCA9PT0gXCJmbG9hdFwiKSB7XG4gICAgICAgICAgcHJvcCA9IFwic3R5bGVGbG9hdFwiO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZXRDb21wdXRlZFN0eWxlUlgudGVzdChwcm9wKSkge1xuICAgICAgICAgIHByb3AucmVwbGFjZShnZXRDb21wdXRlZFN0eWxlUlgsIChfLCBfY2hhcikgPT4gX2NoYXIudG9VcHBlckNhc2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjdXJyZW50U3R5bGUgfSA9IGVsO1xuICAgICAgICByZXR1cm4gKGN1cnJlbnRTdHlsZSAhPSBudWxsID8gY3VycmVudFN0eWxlW3Byb3BdIDogdm9pZCAwKSB8fCBudWxsO1xuICAgICAgfSxcbiAgICB9O1xuICB9O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXT1cge1xuICBkZWZhdWx0cyA9IHtcbiAgICBib3hDbGFzczogXCJ3b3dcIixcbiAgICBhbmltYXRlQ2xhc3M6IFwiYW5pbWF0ZWRcIixcbiAgICBvZmZzZXQ6IDAsXG4gICAgbW9iaWxlOiB0cnVlLFxuICAgIGxpdmU6IHRydWUsXG4gICAgY2FsbGJhY2s6IG51bGwsXG4gICAgc2Nyb2xsQ29udGFpbmVyOiBudWxsLFxuICB9O1xuXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHRoaXMuc3RhcnQgPSB0aGlzLnN0YXJ0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5yZXNldEFuaW1hdGlvbiA9IHRoaXMucmVzZXRBbmltYXRpb24uYmluZCh0aGlzKTtcbiAgICB0aGlzLnNjcm9sbEhhbmRsZXIgPSB0aGlzLnNjcm9sbEhhbmRsZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLnNjcm9sbENhbGxiYWNrID0gdGhpcy5zY3JvbGxDYWxsYmFjay5iaW5kKHRoaXMpO1xuICAgIHRoaXMuc2Nyb2xsZWQgPSB0cnVlO1xuICAgIHRoaXMuY29uZmlnID0gZXh0ZW5kKG9wdGlvbnMsIHRoaXMuZGVmYXVsdHMpO1xuICAgIGlmIChvcHRpb25zLnNjcm9sbENvbnRhaW5lciAhPSBudWxsKSB7XG4gICAgICB0aGlzLmNvbmZpZy5zY3JvbGxDb250YWluZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFxuICAgICAgICBvcHRpb25zLnNjcm9sbENvbnRhaW5lclxuICAgICAgKTtcbiAgICB9XG4gICAgLy8gTWFwIG9mIGVsZW1lbnRzIHRvIGFuaW1hdGlvbiBuYW1lczpcbiAgICB0aGlzLmFuaW1hdGlvbk5hbWVDYWNoZSA9IG5ldyBXZWFrTWFwKCk7XG4gICAgdGhpcy53b3dFdmVudCA9IGNyZWF0ZUV2ZW50KHRoaXMuY29uZmlnLmJveENsYXNzKTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgdGhpcy5lbGVtZW50ID0gd2luZG93LmRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICBpZiAoaXNJbihkb2N1bWVudC5yZWFkeVN0YXRlLCBbXCJpbnRlcmFjdGl2ZVwiLCBcImNvbXBsZXRlXCJdKSkge1xuICAgICAgdGhpcy5zdGFydCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZGRFdmVudChkb2N1bWVudCwgXCJET01Db250ZW50TG9hZGVkXCIsIHRoaXMuc3RhcnQpO1xuICAgIH1cbiAgICB0aGlzLmZpbmlzaGVkID0gW107XG4gIH1cblxuICBzdGFydCgpIHtcbiAgICB0aGlzLnN0b3BwZWQgPSBmYWxzZTtcbiAgICB0aGlzLmJveGVzID0gW10uc2xpY2UuY2FsbChcbiAgICAgIHRoaXMuZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKGAuJHt0aGlzLmNvbmZpZy5ib3hDbGFzc31gKVxuICAgICk7XG4gICAgdGhpcy5hbGwgPSB0aGlzLmJveGVzLnNsaWNlKDApO1xuICAgIGlmICh0aGlzLmJveGVzLmxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMuZGlzYWJsZWQoKSkge1xuICAgICAgICB0aGlzLnJlc2V0U3R5bGUoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ib3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGJveCA9IHRoaXMuYm94ZXNbaV07XG4gICAgICAgICAgdGhpcy5hcHBseVN0eWxlKGJveCwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLmRpc2FibGVkKCkpIHtcbiAgICAgIGFkZEV2ZW50KFxuICAgICAgICB0aGlzLmNvbmZpZy5zY3JvbGxDb250YWluZXIgfHwgd2luZG93LFxuICAgICAgICBcInNjcm9sbFwiLFxuICAgICAgICB0aGlzLnNjcm9sbEhhbmRsZXJcbiAgICAgICk7XG4gICAgICBhZGRFdmVudCh3aW5kb3csIFwicmVzaXplXCIsIHRoaXMuc2Nyb2xsSGFuZGxlcik7XG4gICAgICB0aGlzLmludGVydmFsID0gc2V0SW50ZXJ2YWwodGhpcy5zY3JvbGxDYWxsYmFjaywgNTApO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb25maWcubGl2ZSkge1xuICAgICAgY29uc3QgbXV0ID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoKHJlY29yZHMpID0+IHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByZWNvcmRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgY29uc3QgcmVjb3JkID0gcmVjb3Jkc1tqXTtcbiAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IHJlY29yZC5hZGRlZE5vZGVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlID0gcmVjb3JkLmFkZGVkTm9kZXNba107XG4gICAgICAgICAgICB0aGlzLmRvU3luYyhub2RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgIH0pO1xuICAgICAgbXV0Lm9ic2VydmUoZG9jdW1lbnQuYm9keSwge1xuICAgICAgICBjaGlsZExpc3Q6IHRydWUsXG4gICAgICAgIHN1YnRyZWU6IHRydWUsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvLyB1bmJpbmQgdGhlIHNjcm9sbCBldmVudFxuICBzdG9wKCkge1xuICAgIHRoaXMuc3RvcHBlZCA9IHRydWU7XG4gICAgcmVtb3ZlRXZlbnQoXG4gICAgICB0aGlzLmNvbmZpZy5zY3JvbGxDb250YWluZXIgfHwgd2luZG93LFxuICAgICAgXCJzY3JvbGxcIixcbiAgICAgIHRoaXMuc2Nyb2xsSGFuZGxlclxuICAgICk7XG4gICAgcmVtb3ZlRXZlbnQod2luZG93LCBcInJlc2l6ZVwiLCB0aGlzLnNjcm9sbEhhbmRsZXIpO1xuICAgIGlmICh0aGlzLmludGVydmFsICE9IG51bGwpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5pbnRlcnZhbCk7XG4gICAgfVxuICB9XG5cbiAgc3luYygpIHtcbiAgICBpZiAoTXV0YXRpb25PYnNlcnZlci5ub3RTdXBwb3J0ZWQpIHtcbiAgICAgIHRoaXMuZG9TeW5jKHRoaXMuZWxlbWVudCk7XG4gICAgfVxuICB9XG5cbiAgZG9TeW5jKGVsZW1lbnQpIHtcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQgPT09IFwidW5kZWZpbmVkXCIgfHwgZWxlbWVudCA9PT0gbnVsbCkge1xuICAgICAgKHsgZWxlbWVudCB9ID0gdGhpcyk7XG4gICAgfVxuICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlICE9PSAxKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGUgfHwgZWxlbWVudDtcbiAgICBjb25zdCBpdGVyYWJsZSA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChgLiR7dGhpcy5jb25maWcuYm94Q2xhc3N9YCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpdGVyYWJsZS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgYm94ID0gaXRlcmFibGVbaV07XG4gICAgICBpZiAoIWlzSW4oYm94LCB0aGlzLmFsbCkpIHtcbiAgICAgICAgdGhpcy5ib3hlcy5wdXNoKGJveCk7XG4gICAgICAgIHRoaXMuYWxsLnB1c2goYm94KTtcbiAgICAgICAgaWYgKHRoaXMuc3RvcHBlZCB8fCB0aGlzLmRpc2FibGVkKCkpIHtcbiAgICAgICAgICB0aGlzLnJlc2V0U3R5bGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmFwcGx5U3R5bGUoYm94LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNjcm9sbGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBzaG93IGJveCBlbGVtZW50XG4gIHNob3coYm94KSB7XG4gICAgdGhpcy5hcHBseVN0eWxlKGJveCk7XG4gICAgYm94LmNsYXNzTmFtZSA9IGAke2JveC5jbGFzc05hbWV9ICR7dGhpcy5jb25maWcuYW5pbWF0ZUNsYXNzfWA7XG4gICAgaWYgKHRoaXMuY29uZmlnLmNhbGxiYWNrICE9IG51bGwpIHtcbiAgICAgIHRoaXMuY29uZmlnLmNhbGxiYWNrKGJveCk7XG4gICAgfVxuICAgIGVtaXRFdmVudChib3gsIHRoaXMud293RXZlbnQpO1xuXG4gICAgYWRkRXZlbnQoYm94LCBcImFuaW1hdGlvbmVuZFwiLCB0aGlzLnJlc2V0QW5pbWF0aW9uKTtcbiAgICBhZGRFdmVudChib3gsIFwib2FuaW1hdGlvbmVuZFwiLCB0aGlzLnJlc2V0QW5pbWF0aW9uKTtcbiAgICBhZGRFdmVudChib3gsIFwid2Via2l0QW5pbWF0aW9uRW5kXCIsIHRoaXMucmVzZXRBbmltYXRpb24pO1xuICAgIGFkZEV2ZW50KGJveCwgXCJNU0FuaW1hdGlvbkVuZFwiLCB0aGlzLnJlc2V0QW5pbWF0aW9uKTtcblxuICAgIHJldHVybiBib3g7XG4gIH1cblxuICBhcHBseVN0eWxlKGJveCwgaGlkZGVuKSB7XG4gICAgY29uc3QgZHVyYXRpb24gPSBib3guZ2V0QXR0cmlidXRlKFwiZGF0YS13b3ctZHVyYXRpb25cIik7XG4gICAgY29uc3QgZGVsYXkgPSBib3guZ2V0QXR0cmlidXRlKFwiZGF0YS13b3ctZGVsYXlcIik7XG4gICAgY29uc3QgaXRlcmF0aW9uID0gYm94LmdldEF0dHJpYnV0ZShcImRhdGEtd293LWl0ZXJhdGlvblwiKTtcblxuICAgIHJldHVybiB0aGlzLmFuaW1hdGUoKCkgPT5cbiAgICAgIHRoaXMuY3VzdG9tU3R5bGUoYm94LCBoaWRkZW4sIGR1cmF0aW9uLCBkZWxheSwgaXRlcmF0aW9uKVxuICAgICk7XG4gIH1cblxuICBhbmltYXRlID0gKGZ1bmN0aW9uIGFuaW1hdGVGYWN0b3J5KCkge1xuICAgIGlmIChcInJlcXVlc3RBbmltYXRpb25GcmFtZVwiIGluIHdpbmRvdykge1xuICAgICAgcmV0dXJuIChjYWxsYmFjaykgPT4gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShjYWxsYmFjayk7XG4gICAgfVxuICAgIHJldHVybiAoY2FsbGJhY2spID0+IGNhbGxiYWNrKCk7XG4gIH0pKCk7XG5cbiAgcmVzZXRTdHlsZSgpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYm94ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGJveCA9IHRoaXMuYm94ZXNbaV07XG4gICAgICBib3guc3R5bGUudmlzaWJpbGl0eSA9IFwidmlzaWJsZVwiO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG5cbiAgcmVzZXRBbmltYXRpb24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQudHlwZS50b0xvd2VyQ2FzZSgpLmluZGV4T2YoXCJhbmltYXRpb25lbmRcIikgPj0gMCkge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IHx8IGV2ZW50LnNyY0VsZW1lbnQ7XG4gICAgICB0YXJnZXQuY2xhc3NOYW1lID0gdGFyZ2V0LmNsYXNzTmFtZVxuICAgICAgICAucmVwbGFjZSh0aGlzLmNvbmZpZy5hbmltYXRlQ2xhc3MsIFwiXCIpXG4gICAgICAgIC50cmltKCk7XG4gICAgfVxuICB9XG5cbiAgY3VzdG9tU3R5bGUoYm94LCBoaWRkZW4sIGR1cmF0aW9uLCBkZWxheSwgaXRlcmF0aW9uKSB7XG4gICAgaWYgKGhpZGRlbikge1xuICAgICAgdGhpcy5jYWNoZUFuaW1hdGlvbk5hbWUoYm94KTtcbiAgICB9XG4gICAgYm94LnN0eWxlLnZpc2liaWxpdHkgPSBoaWRkZW4gPyBcImhpZGRlblwiIDogXCJ2aXNpYmxlXCI7XG5cbiAgICBpZiAoZHVyYXRpb24pIHtcbiAgICAgIHRoaXMudmVuZG9yU2V0KGJveC5zdHlsZSwgeyBhbmltYXRpb25EdXJhdGlvbjogZHVyYXRpb24gfSk7XG4gICAgfVxuICAgIGlmIChkZWxheSkge1xuICAgICAgdGhpcy52ZW5kb3JTZXQoYm94LnN0eWxlLCB7IGFuaW1hdGlvbkRlbGF5OiBkZWxheSB9KTtcbiAgICB9XG4gICAgaWYgKGl0ZXJhdGlvbikge1xuICAgICAgdGhpcy52ZW5kb3JTZXQoYm94LnN0eWxlLCB7IGFuaW1hdGlvbkl0ZXJhdGlvbkNvdW50OiBpdGVyYXRpb24gfSk7XG4gICAgfVxuICAgIHRoaXMudmVuZG9yU2V0KGJveC5zdHlsZSwge1xuICAgICAgYW5pbWF0aW9uTmFtZTogaGlkZGVuID8gXCJub25lXCIgOiB0aGlzLmNhY2hlZEFuaW1hdGlvbk5hbWUoYm94KSxcbiAgICB9KTtcblxuICAgIHJldHVybiBib3g7XG4gIH1cblxuICB2ZW5kb3JzID0gW1wibW96XCIsIFwid2Via2l0XCJdO1xuICB2ZW5kb3JTZXQoZWxlbSwgcHJvcGVydGllcykge1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHByb3BlcnRpZXNbbmFtZV07XG4gICAgICAgIGVsZW1bYCR7bmFtZX1gXSA9IHZhbHVlO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudmVuZG9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IHZlbmRvciA9IHRoaXMudmVuZG9yc1tpXTtcbiAgICAgICAgICBlbGVtW2Ake3ZlbmRvcn0ke25hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCl9JHtuYW1lLnN1YnN0cigxKX1gXSA9XG4gICAgICAgICAgICB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2ZW5kb3JDU1MoZWxlbSwgcHJvcGVydHkpIHtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbSk7XG4gICAgbGV0IHJlc3VsdCA9IHN0eWxlLmdldFByb3BlcnR5Q1NTVmFsdWUocHJvcGVydHkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy52ZW5kb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCB2ZW5kb3IgPSB0aGlzLnZlbmRvcnNbaV07XG4gICAgICByZXN1bHQgPSByZXN1bHQgfHwgc3R5bGUuZ2V0UHJvcGVydHlDU1NWYWx1ZShgLSR7dmVuZG9yfS0ke3Byb3BlcnR5fWApO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgYW5pbWF0aW9uTmFtZShib3gpIHtcbiAgICBsZXQgYU5hbWU7XG4gICAgdHJ5IHtcbiAgICAgIGFOYW1lID0gdGhpcy52ZW5kb3JDU1MoYm94LCBcImFuaW1hdGlvbi1uYW1lXCIpLmNzc1RleHQ7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIE9wZXJhLCBmYWxsIGJhY2sgdG8gcGxhaW4gcHJvcGVydHkgdmFsdWVcbiAgICAgIGFOYW1lID0gZ2V0Q29tcHV0ZWRTdHlsZShib3gpLmdldFByb3BlcnR5VmFsdWUoXCJhbmltYXRpb24tbmFtZVwiKTtcbiAgICB9XG5cbiAgICBpZiAoYU5hbWUgPT09IFwibm9uZVwiKSB7XG4gICAgICByZXR1cm4gXCJcIjsgLy8gU1ZHL0ZpcmVmb3gsIHVuYWJsZSB0byBnZXQgYW5pbWF0aW9uIG5hbWU/XG4gICAgfVxuXG4gICAgcmV0dXJuIGFOYW1lO1xuICB9XG5cbiAgY2FjaGVBbmltYXRpb25OYW1lKGJveCkge1xuICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTkyMTgzNFxuICAgIC8vIGJveC5kYXRhc2V0IGlzIG5vdCBzdXBwb3J0ZWQgZm9yIFNWRyBlbGVtZW50cyBpbiBGaXJlZm94XG4gICAgcmV0dXJuIHRoaXMuYW5pbWF0aW9uTmFtZUNhY2hlLnNldChib3gsIHRoaXMuYW5pbWF0aW9uTmFtZShib3gpKTtcbiAgfVxuICBjYWNoZWRBbmltYXRpb25OYW1lKGJveCkge1xuICAgIHJldHVybiB0aGlzLmFuaW1hdGlvbk5hbWVDYWNoZS5nZXQoYm94KTtcbiAgfVxuXG4gIC8vIGZhc3Qgd2luZG93LnNjcm9sbCBjYWxsYmFja1xuICBzY3JvbGxIYW5kbGVyKCkge1xuICAgIHRoaXMuc2Nyb2xsZWQgPSB0cnVlO1xuICB9XG5cbiAgc2Nyb2xsQ2FsbGJhY2soKSB7XG4gICAgaWYgKHRoaXMuc2Nyb2xsZWQpIHtcbiAgICAgIHRoaXMuc2Nyb2xsZWQgPSBmYWxzZTtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5ib3hlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBib3ggPSB0aGlzLmJveGVzW2ldO1xuICAgICAgICBpZiAoYm94KSB7XG4gICAgICAgICAgaWYgKHRoaXMuaXNWaXNpYmxlKGJveCkpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvdyhib3gpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdHMucHVzaChib3gpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmJveGVzID0gcmVzdWx0cztcbiAgICAgIGlmICghdGhpcy5ib3hlcy5sZW5ndGggJiYgIXRoaXMuY29uZmlnLmxpdmUpIHtcbiAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQ2FsY3VsYXRlIGVsZW1lbnQgb2Zmc2V0IHRvcFxuICBvZmZzZXRUb3AoZWxlbWVudCkge1xuICAgIC8vIFNWRyBlbGVtZW50cyBkb24ndCBoYXZlIGFuIG9mZnNldFRvcCBpbiBGaXJlZm94LlxuICAgIC8vIFRoaXMgd2lsbCB1c2UgdGhlaXIgbmVhcmVzdCBwYXJlbnQgdGhhdCBoYXMgYW4gb2Zmc2V0VG9wLlxuICAgIC8vIEFsc28sIHVzaW5nICgnb2Zmc2V0VG9wJyBvZiBlbGVtZW50KSBjYXVzZXMgYW4gZXhjZXB0aW9uIGluIEZpcmVmb3guXG4gICAgd2hpbGUgKGVsZW1lbnQub2Zmc2V0VG9wID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgfVxuICAgIGxldCB0b3AgPSBlbGVtZW50Lm9mZnNldFRvcDtcbiAgICB3aGlsZSAoZWxlbWVudC5vZmZzZXRQYXJlbnQpIHtcbiAgICAgIGVsZW1lbnQgPSBlbGVtZW50Lm9mZnNldFBhcmVudDtcbiAgICAgIHRvcCArPSBlbGVtZW50Lm9mZnNldFRvcDtcbiAgICB9XG4gICAgcmV0dXJuIHRvcDtcbiAgfVxuXG4gIC8vIGNoZWNrIGlmIGJveCBpcyB2aXNpYmxlXG4gIGlzVmlzaWJsZShib3gpIHtcbiAgICBjb25zdCBvZmZzZXQgPSBib3guZ2V0QXR0cmlidXRlKFwiZGF0YS13b3ctb2Zmc2V0XCIpIHx8IHRoaXMuY29uZmlnLm9mZnNldDtcbiAgICBjb25zdCB2aWV3VG9wID1cbiAgICAgICh0aGlzLmNvbmZpZy5zY3JvbGxDb250YWluZXIgJiYgdGhpcy5jb25maWcuc2Nyb2xsQ29udGFpbmVyLnNjcm9sbFRvcCkgfHxcbiAgICAgIHdpbmRvdy5wYWdlWU9mZnNldDtcbiAgICBjb25zdCB2aWV3Qm90dG9tID1cbiAgICAgIHZpZXdUb3AgKyBNYXRoLm1pbih0aGlzLmVsZW1lbnQuY2xpZW50SGVpZ2h0LCBnZXRJbm5lckhlaWdodCgpKSAtIG9mZnNldDtcbiAgICBjb25zdCB0b3AgPSB0aGlzLm9mZnNldFRvcChib3gpO1xuICAgIGNvbnN0IGJvdHRvbSA9IHRvcCArIGJveC5jbGllbnRIZWlnaHQ7XG5cbiAgICByZXR1cm4gdG9wIDw9IHZpZXdCb3R0b20gJiYgYm90dG9tID49IHZpZXdUb3A7XG4gIH1cblxuICBkaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gIXRoaXMuY29uZmlnLm1vYmlsZSAmJiBpc01vYmlsZShuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbImlzSW4iLCJuZWVkbGUiLCJoYXlzdGFjayIsImluZGV4T2YiLCJleHRlbmQiLCJjdXN0b20iLCJkZWZhdWx0cyIsImtleSIsInZhbHVlIiwiaXNNb2JpbGUiLCJhZ2VudCIsInRlc3QiLCJjcmVhdGVFdmVudCIsImV2ZW50IiwiYnViYmxlIiwiY2FuY2VsIiwiZGV0YWlsIiwiY3VzdG9tRXZlbnQiLCJkb2N1bWVudCIsImluaXRDdXN0b21FdmVudCIsImNyZWF0ZUV2ZW50T2JqZWN0IiwiZXZlbnRUeXBlIiwiZXZlbnROYW1lIiwiZW1pdEV2ZW50IiwiZWxlbSIsImRpc3BhdGNoRXZlbnQiLCJhZGRFdmVudCIsImZuIiwiYWRkRXZlbnRMaXN0ZW5lciIsImF0dGFjaEV2ZW50IiwicmVtb3ZlRXZlbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZGV0YWNoRXZlbnQiLCJnZXRJbm5lckhlaWdodCIsIndpbmRvdyIsImlubmVySGVpZ2h0IiwiZG9jdW1lbnRFbGVtZW50IiwiY2xpZW50SGVpZ2h0IiwiV2Vha01hcCIsIk1veldlYWtNYXAiLCJnZXQiLCJpIiwia2V5cyIsImxlbmd0aCIsIml0ZW0iLCJ2YWx1ZXMiLCJ1bmRlZmluZWQiLCJzZXQiLCJwdXNoIiwiY29uc3RydWN0b3IiLCJNdXRhdGlvbk9ic2VydmVyIiwiV2Via2l0TXV0YXRpb25PYnNlcnZlciIsIk1vek11dGF0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlIiwiY29uc29sZSIsIndhcm4iLCJub3RTdXBwb3J0ZWQiLCJnZXRDb21wdXRlZFN0eWxlIiwiZWwiLCJnZXRDb21wdXRlZFN0eWxlUlgiLCJnZXRQcm9wZXJ0eVZhbHVlIiwicHJvcCIsInJlcGxhY2UiLCJfIiwiX2NoYXIiLCJ0b1VwcGVyQ2FzZSIsImN1cnJlbnRTdHlsZSIsIldPVyIsImluaXQiLCJlbGVtZW50IiwicmVhZHlTdGF0ZSIsInN0YXJ0IiwiZmluaXNoZWQiLCJzdG9wcGVkIiwiYm94ZXMiLCJzbGljZSIsImNhbGwiLCJxdWVyeVNlbGVjdG9yQWxsIiwiY29uZmlnIiwiYm94Q2xhc3MiLCJhbGwiLCJkaXNhYmxlZCIsInJlc2V0U3R5bGUiLCJib3giLCJhcHBseVN0eWxlIiwic2Nyb2xsQ29udGFpbmVyIiwic2Nyb2xsSGFuZGxlciIsImludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJzY3JvbGxDYWxsYmFjayIsImxpdmUiLCJtdXQiLCJyZWNvcmRzIiwiaiIsInJlY29yZCIsImsiLCJhZGRlZE5vZGVzIiwibm9kZSIsImRvU3luYyIsImJvZHkiLCJjaGlsZExpc3QiLCJzdWJ0cmVlIiwic3RvcCIsImNsZWFySW50ZXJ2YWwiLCJzeW5jIiwibm9kZVR5cGUiLCJwYXJlbnROb2RlIiwiaXRlcmFibGUiLCJzY3JvbGxlZCIsInNob3ciLCJjbGFzc05hbWUiLCJhbmltYXRlQ2xhc3MiLCJjYWxsYmFjayIsIndvd0V2ZW50IiwicmVzZXRBbmltYXRpb24iLCJoaWRkZW4iLCJkdXJhdGlvbiIsImdldEF0dHJpYnV0ZSIsImRlbGF5IiwiaXRlcmF0aW9uIiwiYW5pbWF0ZSIsImN1c3RvbVN0eWxlIiwic3R5bGUiLCJ2aXNpYmlsaXR5IiwidHlwZSIsInRvTG93ZXJDYXNlIiwidGFyZ2V0Iiwic3JjRWxlbWVudCIsInRyaW0iLCJjYWNoZUFuaW1hdGlvbk5hbWUiLCJ2ZW5kb3JTZXQiLCJhbmltYXRpb25EdXJhdGlvbiIsImFuaW1hdGlvbkRlbGF5IiwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQiLCJhbmltYXRpb25OYW1lIiwiY2FjaGVkQW5pbWF0aW9uTmFtZSIsInByb3BlcnRpZXMiLCJuYW1lIiwiaGFzT3duUHJvcGVydHkiLCJ2ZW5kb3JzIiwidmVuZG9yIiwiY2hhckF0Iiwic3Vic3RyIiwidmVuZG9yQ1NTIiwicHJvcGVydHkiLCJyZXN1bHQiLCJnZXRQcm9wZXJ0eUNTU1ZhbHVlIiwiYU5hbWUiLCJjc3NUZXh0IiwiZXJyb3IiLCJhbmltYXRpb25OYW1lQ2FjaGUiLCJyZXN1bHRzIiwiaXNWaXNpYmxlIiwib2Zmc2V0VG9wIiwidG9wIiwib2Zmc2V0UGFyZW50Iiwib2Zmc2V0Iiwidmlld1RvcCIsInNjcm9sbFRvcCIsInBhZ2VZT2Zmc2V0Iiwidmlld0JvdHRvbSIsIk1hdGgiLCJtaW4iLCJib3R0b20iLCJtb2JpbGUiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJvcHRpb25zIiwiYW5pbWF0ZUZhY3RvcnkiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJiaW5kIiwicXVlcnlTZWxlY3RvciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./utils/wow.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"app/layout.jsx\",\"import\":\"Poppins\",\"arguments\":[{\"subsets\":[\"latin\"],\"weight\":[\"300\",\"400\",\"500\",\"600\",\"700\",\"800\"],\"variable\":\"--body-font\"}],\"variableName\":\"poppins\"}":
/*!************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/font/google/target.css?{"path":"app/layout.jsx","import":"Poppins","arguments":[{"subsets":["latin"],"weight":["300","400","500","600","700","800"],"variable":"--body-font"}],"variableName":"poppins"} ***!
  \************************************************************************************************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'Poppins', 'Poppins Fallback'\",\"fontStyle\":\"normal\"},\"className\":\"__className_1ba102\",\"variable\":\"__variable_1ba102\"};\n    if(true) {\n      // 1740329794014\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/e1wicGF0aFwiOlwiYXBwL2xheW91dC5qc3hcIixcImltcG9ydFwiOlwiUG9wcGluc1wiLFwiYXJndW1lbnRzXCI6W3tcInN1YnNldHNcIjpbXCJsYXRpblwiXSxcIndlaWdodFwiOltcIjMwMFwiLFwiNDAwXCIsXCI1MDBcIixcIjYwMFwiLFwiNzAwXCIsXCI4MDBcIl0sXCJ2YXJpYWJsZVwiOlwiLS1ib2R5LWZvbnRcIn1dLFwidmFyaWFibGVOYW1lXCI6XCJwb3BwaW5zXCJ9IiwibWFwcGluZ3MiOiJBQUFBO0FBQ0Esa0JBQWtCLFNBQVMsa0VBQWtFO0FBQzdGLE9BQU8sSUFBVTtBQUNqQjtBQUNBLHNCQUFzQixtQkFBTyxDQUFDLHdNQUE2SCxjQUFjLHNEQUFzRDtBQUMvTixNQUFNLFVBQVU7QUFDaEI7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvbXZlbnR1cmEvRG9jdW1lbnRzL0dpdEh1Yi9tb3JwaGUvbm9kZV9tb2R1bGVzL25leHQvZm9udC9nb29nbGUvdGFyZ2V0LmNzcz97XCJwYXRoXCI6XCJhcHAvbGF5b3V0LmpzeFwiLFwiaW1wb3J0XCI6XCJQb3BwaW5zXCIsXCJhcmd1bWVudHNcIjpbe1wic3Vic2V0c1wiOltcImxhdGluXCJdLFwid2VpZ2h0XCI6W1wiMzAwXCIsXCI0MDBcIixcIjUwMFwiLFwiNjAwXCIsXCI3MDBcIixcIjgwMFwiXSxcInZhcmlhYmxlXCI6XCItLWJvZHktZm9udFwifV0sXCJ2YXJpYWJsZU5hbWVcIjpcInBvcHBpbnNcIn0iXSwic291cmNlc0NvbnRlbnQiOlsiLy8gZXh0cmFjdGVkIGJ5IG1pbmktY3NzLWV4dHJhY3QtcGx1Z2luXG5tb2R1bGUuZXhwb3J0cyA9IHtcInN0eWxlXCI6e1wiZm9udEZhbWlseVwiOlwiJ1BvcHBpbnMnLCAnUG9wcGlucyBGYWxsYmFjaydcIixcImZvbnRTdHlsZVwiOlwibm9ybWFsXCJ9LFwiY2xhc3NOYW1lXCI6XCJfX2NsYXNzTmFtZV8xYmExMDJcIixcInZhcmlhYmxlXCI6XCJfX3ZhcmlhYmxlXzFiYTEwMlwifTtcbiAgICBpZihtb2R1bGUuaG90KSB7XG4gICAgICAvLyAxNzQwMzI5Nzk0MDE0XG4gICAgICB2YXIgY3NzUmVsb2FkID0gcmVxdWlyZShcIi9Vc2Vycy9tdmVudHVyYS9Eb2N1bWVudHMvR2l0SHViL21vcnBoZS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qc1wiKShtb2R1bGUuaWQsIHtcInB1YmxpY1BhdGhcIjpcIi9fbmV4dC9cIixcImVzTW9kdWxlXCI6ZmFsc2UsXCJsb2NhbHNcIjp0cnVlfSk7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoY3NzUmVsb2FkKTtcbiAgICAgIFxuICAgIH1cbiAgIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"app/layout.jsx\",\"import\":\"Poppins\",\"arguments\":[{\"subsets\":[\"latin\"],\"weight\":[\"300\",\"400\",\"500\",\"600\",\"700\",\"800\"],\"variable\":\"--body-font\"}],\"variableName\":\"poppins\"}\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"app/layout.jsx\",\"import\":\"Unbounded\",\"arguments\":[{\"subsets\":[\"latin\"],\"weight\":[\"400\",\"500\",\"600\",\"700\"],\"variable\":\"--title-font\"}],\"variableName\":\"unbounded\"}":
/*!*****************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/font/google/target.css?{"path":"app/layout.jsx","import":"Unbounded","arguments":[{"subsets":["latin"],"weight":["400","500","600","700"],"variable":"--title-font"}],"variableName":"unbounded"} ***!
  \*****************************************************************************************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval(__webpack_require__.ts("// extracted by mini-css-extract-plugin\nmodule.exports = {\"style\":{\"fontFamily\":\"'Unbounded', 'Unbounded Fallback'\",\"fontStyle\":\"normal\"},\"className\":\"__className_97d819\",\"variable\":\"__variable_97d819\"};\n    if(true) {\n      // 1740329794013\n      var cssReload = __webpack_require__(/*! ./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/mini-css-extract-plugin/hmr/hotModuleReplacement.js\")(module.id, {\"publicPath\":\"/_next/\",\"esModule\":false,\"locals\":true});\n      module.hot.dispose(cssReload);\n      \n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/e1wicGF0aFwiOlwiYXBwL2xheW91dC5qc3hcIixcImltcG9ydFwiOlwiVW5ib3VuZGVkXCIsXCJhcmd1bWVudHNcIjpbe1wic3Vic2V0c1wiOltcImxhdGluXCJdLFwid2VpZ2h0XCI6W1wiNDAwXCIsXCI1MDBcIixcIjYwMFwiLFwiNzAwXCJdLFwidmFyaWFibGVcIjpcIi0tdGl0bGUtZm9udFwifV0sXCJ2YXJpYWJsZU5hbWVcIjpcInVuYm91bmRlZFwifSIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLGtCQUFrQixTQUFTLHNFQUFzRTtBQUNqRyxPQUFPLElBQVU7QUFDakI7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyx3TUFBNkgsY0FBYyxzREFBc0Q7QUFDL04sTUFBTSxVQUFVO0FBQ2hCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL212ZW50dXJhL0RvY3VtZW50cy9HaXRIdWIvbW9ycGhlL25vZGVfbW9kdWxlcy9uZXh0L2ZvbnQvZ29vZ2xlL3RhcmdldC5jc3M/e1wicGF0aFwiOlwiYXBwL2xheW91dC5qc3hcIixcImltcG9ydFwiOlwiVW5ib3VuZGVkXCIsXCJhcmd1bWVudHNcIjpbe1wic3Vic2V0c1wiOltcImxhdGluXCJdLFwid2VpZ2h0XCI6W1wiNDAwXCIsXCI1MDBcIixcIjYwMFwiLFwiNzAwXCJdLFwidmFyaWFibGVcIjpcIi0tdGl0bGUtZm9udFwifV0sXCJ2YXJpYWJsZU5hbWVcIjpcInVuYm91bmRlZFwifSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBleHRyYWN0ZWQgYnkgbWluaS1jc3MtZXh0cmFjdC1wbHVnaW5cbm1vZHVsZS5leHBvcnRzID0ge1wic3R5bGVcIjp7XCJmb250RmFtaWx5XCI6XCInVW5ib3VuZGVkJywgJ1VuYm91bmRlZCBGYWxsYmFjaydcIixcImZvbnRTdHlsZVwiOlwibm9ybWFsXCJ9LFwiY2xhc3NOYW1lXCI6XCJfX2NsYXNzTmFtZV85N2Q4MTlcIixcInZhcmlhYmxlXCI6XCJfX3ZhcmlhYmxlXzk3ZDgxOVwifTtcbiAgICBpZihtb2R1bGUuaG90KSB7XG4gICAgICAvLyAxNzQwMzI5Nzk0MDEzXG4gICAgICB2YXIgY3NzUmVsb2FkID0gcmVxdWlyZShcIi9Vc2Vycy9tdmVudHVyYS9Eb2N1bWVudHMvR2l0SHViL21vcnBoZS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL21pbmktY3NzLWV4dHJhY3QtcGx1Z2luL2htci9ob3RNb2R1bGVSZXBsYWNlbWVudC5qc1wiKShtb2R1bGUuaWQsIHtcInB1YmxpY1BhdGhcIjpcIi9fbmV4dC9cIixcImVzTW9kdWxlXCI6ZmFsc2UsXCJsb2NhbHNcIjp0cnVlfSk7XG4gICAgICBtb2R1bGUuaG90LmRpc3Bvc2UoY3NzUmVsb2FkKTtcbiAgICAgIFxuICAgIH1cbiAgIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/font/google/target.css?{\"path\":\"app/layout.jsx\",\"import\":\"Unbounded\",\"arguments\":[{\"subsets\":[\"latin\"],\"weight\":[\"400\",\"500\",\"600\",\"700\"],\"variable\":\"--title-font\"}],\"variableName\":\"unbounded\"}\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n true &&\n  (function () {\n    function getComponentNameFromType(type) {\n      if (null == type) return null;\n      if (\"function\" === typeof type)\n        return type.$$typeof === REACT_CLIENT_REFERENCE$2\n          ? null\n          : type.displayName || type.name || null;\n      if (\"string\" === typeof type) return type;\n      switch (type) {\n        case REACT_FRAGMENT_TYPE:\n          return \"Fragment\";\n        case REACT_PORTAL_TYPE:\n          return \"Portal\";\n        case REACT_PROFILER_TYPE:\n          return \"Profiler\";\n        case REACT_STRICT_MODE_TYPE:\n          return \"StrictMode\";\n        case REACT_SUSPENSE_TYPE:\n          return \"Suspense\";\n        case REACT_SUSPENSE_LIST_TYPE:\n          return \"SuspenseList\";\n      }\n      if (\"object\" === typeof type)\n        switch (\n          (\"number\" === typeof type.tag &&\n            console.error(\n              \"Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.\"\n            ),\n          type.$$typeof)\n        ) {\n          case REACT_CONTEXT_TYPE:\n            return (type.displayName || \"Context\") + \".Provider\";\n          case REACT_CONSUMER_TYPE:\n            return (type._context.displayName || \"Context\") + \".Consumer\";\n          case REACT_FORWARD_REF_TYPE:\n            var innerType = type.render;\n            type = type.displayName;\n            type ||\n              ((type = innerType.displayName || innerType.name || \"\"),\n              (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n            return type;\n          case REACT_MEMO_TYPE:\n            return (\n              (innerType = type.displayName || null),\n              null !== innerType\n                ? innerType\n                : getComponentNameFromType(type.type) || \"Memo\"\n            );\n          case REACT_LAZY_TYPE:\n            innerType = type._payload;\n            type = type._init;\n            try {\n              return getComponentNameFromType(type(innerType));\n            } catch (x) {}\n        }\n      return null;\n    }\n    function testStringCoercion(value) {\n      return \"\" + value;\n    }\n    function checkKeyStringCoercion(value) {\n      try {\n        testStringCoercion(value);\n        var JSCompiler_inline_result = !1;\n      } catch (e) {\n        JSCompiler_inline_result = !0;\n      }\n      if (JSCompiler_inline_result) {\n        JSCompiler_inline_result = console;\n        var JSCompiler_temp_const = JSCompiler_inline_result.error;\n        var JSCompiler_inline_result$jscomp$0 =\n          (\"function\" === typeof Symbol &&\n            Symbol.toStringTag &&\n            value[Symbol.toStringTag]) ||\n          value.constructor.name ||\n          \"Object\";\n        JSCompiler_temp_const.call(\n          JSCompiler_inline_result,\n          \"The provided key is an unsupported type %s. This value must be coerced to a string before using it here.\",\n          JSCompiler_inline_result$jscomp$0\n        );\n        return testStringCoercion(value);\n      }\n    }\n    function disabledLog() {}\n    function disableLogs() {\n      if (0 === disabledDepth) {\n        prevLog = console.log;\n        prevInfo = console.info;\n        prevWarn = console.warn;\n        prevError = console.error;\n        prevGroup = console.group;\n        prevGroupCollapsed = console.groupCollapsed;\n        prevGroupEnd = console.groupEnd;\n        var props = {\n          configurable: !0,\n          enumerable: !0,\n          value: disabledLog,\n          writable: !0\n        };\n        Object.defineProperties(console, {\n          info: props,\n          log: props,\n          warn: props,\n          error: props,\n          group: props,\n          groupCollapsed: props,\n          groupEnd: props\n        });\n      }\n      disabledDepth++;\n    }\n    function reenableLogs() {\n      disabledDepth--;\n      if (0 === disabledDepth) {\n        var props = { configurable: !0, enumerable: !0, writable: !0 };\n        Object.defineProperties(console, {\n          log: assign({}, props, { value: prevLog }),\n          info: assign({}, props, { value: prevInfo }),\n          warn: assign({}, props, { value: prevWarn }),\n          error: assign({}, props, { value: prevError }),\n          group: assign({}, props, { value: prevGroup }),\n          groupCollapsed: assign({}, props, { value: prevGroupCollapsed }),\n          groupEnd: assign({}, props, { value: prevGroupEnd })\n        });\n      }\n      0 > disabledDepth &&\n        console.error(\n          \"disabledDepth fell below zero. This is a bug in React. Please file an issue.\"\n        );\n    }\n    function describeBuiltInComponentFrame(name) {\n      if (void 0 === prefix)\n        try {\n          throw Error();\n        } catch (x) {\n          var match = x.stack.trim().match(/\\n( *(at )?)/);\n          prefix = (match && match[1]) || \"\";\n          suffix =\n            -1 < x.stack.indexOf(\"\\n    at\")\n              ? \" (<anonymous>)\"\n              : -1 < x.stack.indexOf(\"@\")\n                ? \"@unknown:0:0\"\n                : \"\";\n        }\n      return \"\\n\" + prefix + name + suffix;\n    }\n    function describeNativeComponentFrame(fn, construct) {\n      if (!fn || reentry) return \"\";\n      var frame = componentFrameCache.get(fn);\n      if (void 0 !== frame) return frame;\n      reentry = !0;\n      frame = Error.prepareStackTrace;\n      Error.prepareStackTrace = void 0;\n      var previousDispatcher = null;\n      previousDispatcher = ReactSharedInternals.H;\n      ReactSharedInternals.H = null;\n      disableLogs();\n      try {\n        var RunInRootFrame = {\n          DetermineComponentFrameRoot: function () {\n            try {\n              if (construct) {\n                var Fake = function () {\n                  throw Error();\n                };\n                Object.defineProperty(Fake.prototype, \"props\", {\n                  set: function () {\n                    throw Error();\n                  }\n                });\n                if (\"object\" === typeof Reflect && Reflect.construct) {\n                  try {\n                    Reflect.construct(Fake, []);\n                  } catch (x) {\n                    var control = x;\n                  }\n                  Reflect.construct(fn, [], Fake);\n                } else {\n                  try {\n                    Fake.call();\n                  } catch (x$0) {\n                    control = x$0;\n                  }\n                  fn.call(Fake.prototype);\n                }\n              } else {\n                try {\n                  throw Error();\n                } catch (x$1) {\n                  control = x$1;\n                }\n                (Fake = fn()) &&\n                  \"function\" === typeof Fake.catch &&\n                  Fake.catch(function () {});\n              }\n            } catch (sample) {\n              if (sample && control && \"string\" === typeof sample.stack)\n                return [sample.stack, control.stack];\n            }\n            return [null, null];\n          }\n        };\n        RunInRootFrame.DetermineComponentFrameRoot.displayName =\n          \"DetermineComponentFrameRoot\";\n        var namePropDescriptor = Object.getOwnPropertyDescriptor(\n          RunInRootFrame.DetermineComponentFrameRoot,\n          \"name\"\n        );\n        namePropDescriptor &&\n          namePropDescriptor.configurable &&\n          Object.defineProperty(\n            RunInRootFrame.DetermineComponentFrameRoot,\n            \"name\",\n            { value: \"DetermineComponentFrameRoot\" }\n          );\n        var _RunInRootFrame$Deter =\n            RunInRootFrame.DetermineComponentFrameRoot(),\n          sampleStack = _RunInRootFrame$Deter[0],\n          controlStack = _RunInRootFrame$Deter[1];\n        if (sampleStack && controlStack) {\n          var sampleLines = sampleStack.split(\"\\n\"),\n            controlLines = controlStack.split(\"\\n\");\n          for (\n            _RunInRootFrame$Deter = namePropDescriptor = 0;\n            namePropDescriptor < sampleLines.length &&\n            !sampleLines[namePropDescriptor].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            namePropDescriptor++;\n          for (\n            ;\n            _RunInRootFrame$Deter < controlLines.length &&\n            !controlLines[_RunInRootFrame$Deter].includes(\n              \"DetermineComponentFrameRoot\"\n            );\n\n          )\n            _RunInRootFrame$Deter++;\n          if (\n            namePropDescriptor === sampleLines.length ||\n            _RunInRootFrame$Deter === controlLines.length\n          )\n            for (\n              namePropDescriptor = sampleLines.length - 1,\n                _RunInRootFrame$Deter = controlLines.length - 1;\n              1 <= namePropDescriptor &&\n              0 <= _RunInRootFrame$Deter &&\n              sampleLines[namePropDescriptor] !==\n                controlLines[_RunInRootFrame$Deter];\n\n            )\n              _RunInRootFrame$Deter--;\n          for (\n            ;\n            1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter;\n            namePropDescriptor--, _RunInRootFrame$Deter--\n          )\n            if (\n              sampleLines[namePropDescriptor] !==\n              controlLines[_RunInRootFrame$Deter]\n            ) {\n              if (1 !== namePropDescriptor || 1 !== _RunInRootFrame$Deter) {\n                do\n                  if (\n                    (namePropDescriptor--,\n                    _RunInRootFrame$Deter--,\n                    0 > _RunInRootFrame$Deter ||\n                      sampleLines[namePropDescriptor] !==\n                        controlLines[_RunInRootFrame$Deter])\n                  ) {\n                    var _frame =\n                      \"\\n\" +\n                      sampleLines[namePropDescriptor].replace(\n                        \" at new \",\n                        \" at \"\n                      );\n                    fn.displayName &&\n                      _frame.includes(\"<anonymous>\") &&\n                      (_frame = _frame.replace(\"<anonymous>\", fn.displayName));\n                    \"function\" === typeof fn &&\n                      componentFrameCache.set(fn, _frame);\n                    return _frame;\n                  }\n                while (1 <= namePropDescriptor && 0 <= _RunInRootFrame$Deter);\n              }\n              break;\n            }\n        }\n      } finally {\n        (reentry = !1),\n          (ReactSharedInternals.H = previousDispatcher),\n          reenableLogs(),\n          (Error.prepareStackTrace = frame);\n      }\n      sampleLines = (sampleLines = fn ? fn.displayName || fn.name : \"\")\n        ? describeBuiltInComponentFrame(sampleLines)\n        : \"\";\n      \"function\" === typeof fn && componentFrameCache.set(fn, sampleLines);\n      return sampleLines;\n    }\n    function describeUnknownElementTypeFrameInDEV(type) {\n      if (null == type) return \"\";\n      if (\"function\" === typeof type) {\n        var prototype = type.prototype;\n        return describeNativeComponentFrame(\n          type,\n          !(!prototype || !prototype.isReactComponent)\n        );\n      }\n      if (\"string\" === typeof type) return describeBuiltInComponentFrame(type);\n      switch (type) {\n        case REACT_SUSPENSE_TYPE:\n          return describeBuiltInComponentFrame(\"Suspense\");\n        case REACT_SUSPENSE_LIST_TYPE:\n          return describeBuiltInComponentFrame(\"SuspenseList\");\n      }\n      if (\"object\" === typeof type)\n        switch (type.$$typeof) {\n          case REACT_FORWARD_REF_TYPE:\n            return (type = describeNativeComponentFrame(type.render, !1)), type;\n          case REACT_MEMO_TYPE:\n            return describeUnknownElementTypeFrameInDEV(type.type);\n          case REACT_LAZY_TYPE:\n            prototype = type._payload;\n            type = type._init;\n            try {\n              return describeUnknownElementTypeFrameInDEV(type(prototype));\n            } catch (x) {}\n        }\n      return \"\";\n    }\n    function getOwner() {\n      var dispatcher = ReactSharedInternals.A;\n      return null === dispatcher ? null : dispatcher.getOwner();\n    }\n    function hasValidKey(config) {\n      if (hasOwnProperty.call(config, \"key\")) {\n        var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n        if (getter && getter.isReactWarning) return !1;\n      }\n      return void 0 !== config.key;\n    }\n    function defineKeyPropWarningGetter(props, displayName) {\n      function warnAboutAccessingKey() {\n        specialPropKeyWarningShown ||\n          ((specialPropKeyWarningShown = !0),\n          console.error(\n            \"%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)\",\n            displayName\n          ));\n      }\n      warnAboutAccessingKey.isReactWarning = !0;\n      Object.defineProperty(props, \"key\", {\n        get: warnAboutAccessingKey,\n        configurable: !0\n      });\n    }\n    function elementRefGetterWithDeprecationWarning() {\n      var componentName = getComponentNameFromType(this.type);\n      didWarnAboutElementRef[componentName] ||\n        ((didWarnAboutElementRef[componentName] = !0),\n        console.error(\n          \"Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release.\"\n        ));\n      componentName = this.props.ref;\n      return void 0 !== componentName ? componentName : null;\n    }\n    function ReactElement(type, key, self, source, owner, props) {\n      self = props.ref;\n      type = {\n        $$typeof: REACT_ELEMENT_TYPE,\n        type: type,\n        key: key,\n        props: props,\n        _owner: owner\n      };\n      null !== (void 0 !== self ? self : null)\n        ? Object.defineProperty(type, \"ref\", {\n            enumerable: !1,\n            get: elementRefGetterWithDeprecationWarning\n          })\n        : Object.defineProperty(type, \"ref\", { enumerable: !1, value: null });\n      type._store = {};\n      Object.defineProperty(type._store, \"validated\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: 0\n      });\n      Object.defineProperty(type, \"_debugInfo\", {\n        configurable: !1,\n        enumerable: !1,\n        writable: !0,\n        value: null\n      });\n      Object.freeze && (Object.freeze(type.props), Object.freeze(type));\n      return type;\n    }\n    function jsxDEVImpl(\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      if (\n        \"string\" === typeof type ||\n        \"function\" === typeof type ||\n        type === REACT_FRAGMENT_TYPE ||\n        type === REACT_PROFILER_TYPE ||\n        type === REACT_STRICT_MODE_TYPE ||\n        type === REACT_SUSPENSE_TYPE ||\n        type === REACT_SUSPENSE_LIST_TYPE ||\n        type === REACT_OFFSCREEN_TYPE ||\n        (\"object\" === typeof type &&\n          null !== type &&\n          (type.$$typeof === REACT_LAZY_TYPE ||\n            type.$$typeof === REACT_MEMO_TYPE ||\n            type.$$typeof === REACT_CONTEXT_TYPE ||\n            type.$$typeof === REACT_CONSUMER_TYPE ||\n            type.$$typeof === REACT_FORWARD_REF_TYPE ||\n            type.$$typeof === REACT_CLIENT_REFERENCE$1 ||\n            void 0 !== type.getModuleId))\n      ) {\n        var children = config.children;\n        if (void 0 !== children)\n          if (isStaticChildren)\n            if (isArrayImpl(children)) {\n              for (\n                isStaticChildren = 0;\n                isStaticChildren < children.length;\n                isStaticChildren++\n              )\n                validateChildKeys(children[isStaticChildren], type);\n              Object.freeze && Object.freeze(children);\n            } else\n              console.error(\n                \"React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.\"\n              );\n          else validateChildKeys(children, type);\n      } else {\n        children = \"\";\n        if (\n          void 0 === type ||\n          (\"object\" === typeof type &&\n            null !== type &&\n            0 === Object.keys(type).length)\n        )\n          children +=\n            \" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.\";\n        null === type\n          ? (isStaticChildren = \"null\")\n          : isArrayImpl(type)\n            ? (isStaticChildren = \"array\")\n            : void 0 !== type && type.$$typeof === REACT_ELEMENT_TYPE\n              ? ((isStaticChildren =\n                  \"<\" +\n                  (getComponentNameFromType(type.type) || \"Unknown\") +\n                  \" />\"),\n                (children =\n                  \" Did you accidentally export a JSX literal instead of a component?\"))\n              : (isStaticChildren = typeof type);\n        console.error(\n          \"React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s\",\n          isStaticChildren,\n          children\n        );\n      }\n      if (hasOwnProperty.call(config, \"key\")) {\n        children = getComponentNameFromType(type);\n        var keys = Object.keys(config).filter(function (k) {\n          return \"key\" !== k;\n        });\n        isStaticChildren =\n          0 < keys.length\n            ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\"\n            : \"{key: someKey}\";\n        didWarnAboutKeySpread[children + isStaticChildren] ||\n          ((keys =\n            0 < keys.length ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\"),\n          console.error(\n            'A props object containing a \"key\" prop is being spread into JSX:\\n  let props = %s;\\n  <%s {...props} />\\nReact keys must be passed directly to JSX without using spread:\\n  let props = %s;\\n  <%s key={someKey} {...props} />',\n            isStaticChildren,\n            children,\n            keys,\n            children\n          ),\n          (didWarnAboutKeySpread[children + isStaticChildren] = !0));\n      }\n      children = null;\n      void 0 !== maybeKey &&\n        (checkKeyStringCoercion(maybeKey), (children = \"\" + maybeKey));\n      hasValidKey(config) &&\n        (checkKeyStringCoercion(config.key), (children = \"\" + config.key));\n      if (\"key\" in config) {\n        maybeKey = {};\n        for (var propName in config)\n          \"key\" !== propName && (maybeKey[propName] = config[propName]);\n      } else maybeKey = config;\n      children &&\n        defineKeyPropWarningGetter(\n          maybeKey,\n          \"function\" === typeof type\n            ? type.displayName || type.name || \"Unknown\"\n            : type\n        );\n      return ReactElement(type, children, self, source, getOwner(), maybeKey);\n    }\n    function validateChildKeys(node, parentType) {\n      if (\n        \"object\" === typeof node &&\n        node &&\n        node.$$typeof !== REACT_CLIENT_REFERENCE\n      )\n        if (isArrayImpl(node))\n          for (var i = 0; i < node.length; i++) {\n            var child = node[i];\n            isValidElement(child) && validateExplicitKey(child, parentType);\n          }\n        else if (isValidElement(node))\n          node._store && (node._store.validated = 1);\n        else if (\n          (null === node || \"object\" !== typeof node\n            ? (i = null)\n            : ((i =\n                (MAYBE_ITERATOR_SYMBOL && node[MAYBE_ITERATOR_SYMBOL]) ||\n                node[\"@@iterator\"]),\n              (i = \"function\" === typeof i ? i : null)),\n          \"function\" === typeof i &&\n            i !== node.entries &&\n            ((i = i.call(node)), i !== node))\n        )\n          for (; !(node = i.next()).done; )\n            isValidElement(node.value) &&\n              validateExplicitKey(node.value, parentType);\n    }\n    function isValidElement(object) {\n      return (\n        \"object\" === typeof object &&\n        null !== object &&\n        object.$$typeof === REACT_ELEMENT_TYPE\n      );\n    }\n    function validateExplicitKey(element, parentType) {\n      if (\n        element._store &&\n        !element._store.validated &&\n        null == element.key &&\n        ((element._store.validated = 1),\n        (parentType = getCurrentComponentErrorInfo(parentType)),\n        !ownerHasKeyUseWarning[parentType])\n      ) {\n        ownerHasKeyUseWarning[parentType] = !0;\n        var childOwner = \"\";\n        element &&\n          null != element._owner &&\n          element._owner !== getOwner() &&\n          ((childOwner = null),\n          \"number\" === typeof element._owner.tag\n            ? (childOwner = getComponentNameFromType(element._owner.type))\n            : \"string\" === typeof element._owner.name &&\n              (childOwner = element._owner.name),\n          (childOwner = \" It was passed a child from \" + childOwner + \".\"));\n        var prevGetCurrentStack = ReactSharedInternals.getCurrentStack;\n        ReactSharedInternals.getCurrentStack = function () {\n          var stack = describeUnknownElementTypeFrameInDEV(element.type);\n          prevGetCurrentStack && (stack += prevGetCurrentStack() || \"\");\n          return stack;\n        };\n        console.error(\n          'Each child in a list should have a unique \"key\" prop.%s%s See https://react.dev/link/warning-keys for more information.',\n          parentType,\n          childOwner\n        );\n        ReactSharedInternals.getCurrentStack = prevGetCurrentStack;\n      }\n    }\n    function getCurrentComponentErrorInfo(parentType) {\n      var info = \"\",\n        owner = getOwner();\n      owner &&\n        (owner = getComponentNameFromType(owner.type)) &&\n        (info = \"\\n\\nCheck the render method of `\" + owner + \"`.\");\n      info ||\n        ((parentType = getComponentNameFromType(parentType)) &&\n          (info =\n            \"\\n\\nCheck the top-level render call using <\" + parentType + \">.\"));\n      return info;\n    }\n    var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\"),\n      REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n      REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n      REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n      REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n      REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n    Symbol.for(\"react.provider\");\n    var REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n      REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n      REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n      REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n      REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n      REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n      REACT_LAZY_TYPE = Symbol.for(\"react.lazy\"),\n      REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\"),\n      MAYBE_ITERATOR_SYMBOL = Symbol.iterator,\n      REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\"),\n      ReactSharedInternals =\n        React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n      hasOwnProperty = Object.prototype.hasOwnProperty,\n      assign = Object.assign,\n      REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"),\n      isArrayImpl = Array.isArray,\n      disabledDepth = 0,\n      prevLog,\n      prevInfo,\n      prevWarn,\n      prevError,\n      prevGroup,\n      prevGroupCollapsed,\n      prevGroupEnd;\n    disabledLog.__reactDisabledLog = !0;\n    var prefix,\n      suffix,\n      reentry = !1;\n    var componentFrameCache = new (\n      \"function\" === typeof WeakMap ? WeakMap : Map\n    )();\n    var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\"),\n      specialPropKeyWarningShown;\n    var didWarnAboutElementRef = {};\n    var didWarnAboutKeySpread = {},\n      ownerHasKeyUseWarning = {};\n    exports.Fragment = REACT_FRAGMENT_TYPE;\n    exports.jsxDEV = function (\n      type,\n      config,\n      maybeKey,\n      isStaticChildren,\n      source,\n      self\n    ) {\n      return jsxDEVImpl(type, config, maybeKey, isStaticChildren, source, self);\n    };\n  })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYixLQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLHdCQUF3QixXQUFXLGdCQUFnQjtBQUNuRCx5QkFBeUIsV0FBVyxpQkFBaUI7QUFDckQseUJBQXlCLFdBQVcsaUJBQWlCO0FBQ3JELDBCQUEwQixXQUFXLGtCQUFrQjtBQUN2RCwwQkFBMEIsV0FBVyxrQkFBa0I7QUFDdkQsbUNBQW1DLFdBQVcsMkJBQTJCO0FBQ3pFLDZCQUE2QixXQUFXLHFCQUFxQjtBQUM3RCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsK0NBQStDLDZCQUE2QjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxnQkFBZ0IsZ0RBQWdEO0FBQ2hFLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQSxnQ0FBZ0Msa0NBQWtDLE9BQU87QUFDekU7QUFDQSxnR0FBZ0csU0FBUyxVQUFVLHNGQUFzRixhQUFhLFVBQVUsVUFBVTtBQUMxTztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixpQkFBaUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIseUJBQXlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUJBQU8sQ0FBQyxzR0FBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQSxJQUFJLGdCQUFnQjtBQUNwQixJQUFJLGNBQWM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyIsInNvdXJjZXMiOlsiL1VzZXJzL212ZW50dXJhL0RvY3VtZW50cy9HaXRIdWIvbW9ycGhlL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cblwidXNlIHN0cmljdFwiO1xuXCJwcm9kdWN0aW9uXCIgIT09IHByb2Nlc3MuZW52Lk5PREVfRU5WICYmXG4gIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgICAgIGlmIChudWxsID09IHR5cGUpIHJldHVybiBudWxsO1xuICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHJldHVybiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDJcbiAgICAgICAgICA/IG51bGxcbiAgICAgICAgICA6IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHR5cGUpIHJldHVybiB0eXBlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgICByZXR1cm4gXCJGcmFnbWVudFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlBvcnRhbFwiO1xuICAgICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIFwiUHJvZmlsZXJcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN0cmljdE1vZGVcIjtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlXCI7XG4gICAgICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBcIlN1c3BlbnNlTGlzdFwiO1xuICAgICAgfVxuICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiB0eXBlKVxuICAgICAgICBzd2l0Y2ggKFxuICAgICAgICAgIChcIm51bWJlclwiID09PSB0eXBlb2YgdHlwZS50YWcgJiZcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICAgICAgICAgIFwiUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS5cIlxuICAgICAgICAgICAgKSxcbiAgICAgICAgICB0eXBlLiQkdHlwZW9mKVxuICAgICAgICApIHtcbiAgICAgICAgICBjYXNlIFJFQUNUX0NPTlRFWFRfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Qcm92aWRlclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZS5fY29udGV4dC5kaXNwbGF5TmFtZSB8fCBcIkNvbnRleHRcIikgKyBcIi5Db25zdW1lclwiO1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHZhciBpbm5lclR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgICAgIHR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgICAgdHlwZSB8fFxuICAgICAgICAgICAgICAoKHR5cGUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgXCJcIiksXG4gICAgICAgICAgICAgICh0eXBlID0gXCJcIiAhPT0gdHlwZSA/IFwiRm9yd2FyZFJlZihcIiArIHR5cGUgKyBcIilcIiA6IFwiRm9yd2FyZFJlZlwiKSk7XG4gICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgIChpbm5lclR5cGUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGwpLFxuICAgICAgICAgICAgICBudWxsICE9PSBpbm5lclR5cGVcbiAgICAgICAgICAgICAgICA/IGlubmVyVHlwZVxuICAgICAgICAgICAgICAgIDogZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJNZW1vXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBpbm5lclR5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUoaW5uZXJUeXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gXCJcIiArIHZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gICAgICB0cnkge1xuICAgICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0ID0gITE7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCA9ICEwO1xuICAgICAgfVxuICAgICAgaWYgKEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCkge1xuICAgICAgICBKU0NvbXBpbGVyX2lubGluZV9yZXN1bHQgPSBjb25zb2xlO1xuICAgICAgICB2YXIgSlNDb21waWxlcl90ZW1wX2NvbnN0ID0gSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0LmVycm9yO1xuICAgICAgICB2YXIgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwID1cbiAgICAgICAgICAoXCJmdW5jdGlvblwiID09PSB0eXBlb2YgU3ltYm9sICYmXG4gICAgICAgICAgICBTeW1ib2wudG9TdHJpbmdUYWcgJiZcbiAgICAgICAgICAgIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10pIHx8XG4gICAgICAgICAgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fFxuICAgICAgICAgIFwiT2JqZWN0XCI7XG4gICAgICAgIEpTQ29tcGlsZXJfdGVtcF9jb25zdC5jYWxsKFxuICAgICAgICAgIEpTQ29tcGlsZXJfaW5saW5lX3Jlc3VsdCxcbiAgICAgICAgICBcIlRoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4gVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuXCIsXG4gICAgICAgICAgSlNDb21waWxlcl9pbmxpbmVfcmVzdWx0JGpzY29tcCQwXG4gICAgICAgICk7XG4gICAgICAgIHJldHVybiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG4gICAgZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gICAgICBpZiAoMCA9PT0gZGlzYWJsZWREZXB0aCkge1xuICAgICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDtcbiAgICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogITAsXG4gICAgICAgICAgZW51bWVyYWJsZTogITAsXG4gICAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICAgIHdyaXRhYmxlOiAhMFxuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkaXNhYmxlZERlcHRoKys7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAgICAgIGRpc2FibGVkRGVwdGgtLTtcbiAgICAgIGlmICgwID09PSBkaXNhYmxlZERlcHRoKSB7XG4gICAgICAgIHZhciBwcm9wcyA9IHsgY29uZmlndXJhYmxlOiAhMCwgZW51bWVyYWJsZTogITAsIHdyaXRhYmxlOiAhMCB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2TG9nIH0pLFxuICAgICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZJbmZvIH0pLFxuICAgICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZXYXJuIH0pLFxuICAgICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2RXJyb3IgfSksXG4gICAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHsgdmFsdWU6IHByZXZHcm91cCB9KSxcbiAgICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywgeyB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkIH0pLFxuICAgICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7IHZhbHVlOiBwcmV2R3JvdXBFbmQgfSlcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICAwID4gZGlzYWJsZWREZXB0aCAmJlxuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgIFwiZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLlwiXG4gICAgICAgICk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIHtcbiAgICAgIGlmICh2b2lkIDAgPT09IHByZWZpeClcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgICBwcmVmaXggPSAobWF0Y2ggJiYgbWF0Y2hbMV0pIHx8IFwiXCI7XG4gICAgICAgICAgc3VmZml4ID1cbiAgICAgICAgICAgIC0xIDwgeC5zdGFjay5pbmRleE9mKFwiXFxuICAgIGF0XCIpXG4gICAgICAgICAgICAgID8gXCIgKDxhbm9ueW1vdXM+KVwiXG4gICAgICAgICAgICAgIDogLTEgPCB4LnN0YWNrLmluZGV4T2YoXCJAXCIpXG4gICAgICAgICAgICAgICAgPyBcIkB1bmtub3duOjA6MFwiXG4gICAgICAgICAgICAgICAgOiBcIlwiO1xuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcXG5cIiArIHByZWZpeCArIG5hbWUgKyBzdWZmaXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAgICAgaWYgKCFmbiB8fCByZWVudHJ5KSByZXR1cm4gXCJcIjtcbiAgICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcbiAgICAgIGlmICh2b2lkIDAgIT09IGZyYW1lKSByZXR1cm4gZnJhbWU7XG4gICAgICByZWVudHJ5ID0gITA7XG4gICAgICBmcmFtZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlO1xuICAgICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB2b2lkIDA7XG4gICAgICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyID0gbnVsbDtcbiAgICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gbnVsbDtcbiAgICAgIGRpc2FibGVMb2dzKCk7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgICAgICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEZha2UucHJvdG90eXBlLCBcInByb3BzXCIsIHtcbiAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2YgUmVmbGVjdCAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udHJvbCA9IHg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sID0geCQwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgkMSkge1xuICAgICAgICAgICAgICAgICAgY29udHJvbCA9IHgkMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKEZha2UgPSBmbigpKSAmJlxuICAgICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgRmFrZS5jYXRjaCAmJlxuICAgICAgICAgICAgICAgICAgRmFrZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgICAgICAgICAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgXCJzdHJpbmdcIiA9PT0gdHlwZW9mIHNhbXBsZS5zdGFjaylcbiAgICAgICAgICAgICAgICByZXR1cm4gW3NhbXBsZS5zdGFjaywgY29udHJvbC5zdGFja107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID1cbiAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiO1xuICAgICAgICB2YXIgbmFtZVByb3BEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihcbiAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsXG4gICAgICAgICAgXCJuYW1lXCJcbiAgICAgICAgKTtcbiAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSAmJlxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgIFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCxcbiAgICAgICAgICAgIFwibmFtZVwiLFxuICAgICAgICAgICAgeyB2YWx1ZTogXCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3RcIiB9XG4gICAgICAgICAgKTtcbiAgICAgICAgdmFyIF9SdW5JblJvb3RGcmFtZSREZXRlciA9XG4gICAgICAgICAgICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgICBzYW1wbGVTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclswXSxcbiAgICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG4gICAgICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdChcIlxcblwiKSxcbiAgICAgICAgICAgIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2xTdGFjay5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gbmFtZVByb3BEZXNjcmlwdG9yID0gMDtcbiAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIXNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0uaW5jbHVkZXMoXG4gICAgICAgICAgICAgIFwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290XCJcbiAgICAgICAgICAgICk7XG5cbiAgICAgICAgICApXG4gICAgICAgICAgICBuYW1lUHJvcERlc2NyaXB0b3IrKztcbiAgICAgICAgICBmb3IgKFxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJlxuICAgICAgICAgICAgIWNvbnRyb2xMaW5lc1tfUnVuSW5Sb290RnJhbWUkRGV0ZXJdLmluY2x1ZGVzKFxuICAgICAgICAgICAgICBcIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdFwiXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgKVxuICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyKys7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHxcbiAgICAgICAgICAgIF9SdW5JblJvb3RGcmFtZSREZXRlciA9PT0gY29udHJvbExpbmVzLmxlbmd0aFxuICAgICAgICAgIClcbiAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgIG5hbWVQcm9wRGVzY3JpcHRvciA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmXG4gICAgICAgICAgICAgIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyICYmXG4gICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgY29udHJvbExpbmVzW19SdW5JblJvb3RGcmFtZSREZXRlcl07XG5cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgX1J1bkluUm9vdEZyYW1lJERldGVyLS07XG4gICAgICAgICAgZm9yIChcbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIDEgPD0gbmFtZVByb3BEZXNjcmlwdG9yICYmIDAgPD0gX1J1bkluUm9vdEZyYW1lJERldGVyO1xuICAgICAgICAgICAgbmFtZVByb3BEZXNjcmlwdG9yLS0sIF9SdW5JblJvb3RGcmFtZSREZXRlci0tXG4gICAgICAgICAgKVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdICE9PVxuICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXVxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGlmICgxICE9PSBuYW1lUHJvcERlc2NyaXB0b3IgfHwgMSAhPT0gX1J1bkluUm9vdEZyYW1lJERldGVyKSB7XG4gICAgICAgICAgICAgICAgZG9cbiAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgKG5hbWVQcm9wRGVzY3JpcHRvci0tLFxuICAgICAgICAgICAgICAgICAgICBfUnVuSW5Sb290RnJhbWUkRGV0ZXItLSxcbiAgICAgICAgICAgICAgICAgICAgMCA+IF9SdW5JblJvb3RGcmFtZSREZXRlciB8fFxuICAgICAgICAgICAgICAgICAgICAgIHNhbXBsZUxpbmVzW25hbWVQcm9wRGVzY3JpcHRvcl0gIT09XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sTGluZXNbX1J1bkluUm9vdEZyYW1lJERldGVyXSlcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID1cbiAgICAgICAgICAgICAgICAgICAgICBcIlxcblwiICtcbiAgICAgICAgICAgICAgICAgICAgICBzYW1wbGVMaW5lc1tuYW1lUHJvcERlc2NyaXB0b3JdLnJlcGxhY2UoXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBuZXcgXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBhdCBcIlxuICAgICAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgICAgIGZuLmRpc3BsYXlOYW1lICYmXG4gICAgICAgICAgICAgICAgICAgICAgX2ZyYW1lLmluY2x1ZGVzKFwiPGFub255bW91cz5cIikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAoX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoXCI8YW5vbnltb3VzPlwiLCBmbi5kaXNwbGF5TmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBmbiAmJlxuICAgICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBfZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2ZyYW1lO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdoaWxlICgxIDw9IG5hbWVQcm9wRGVzY3JpcHRvciAmJiAwIDw9IF9SdW5JblJvb3RGcmFtZSREZXRlcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIChyZWVudHJ5ID0gITEpLFxuICAgICAgICAgIChSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldmlvdXNEaXNwYXRjaGVyKSxcbiAgICAgICAgICByZWVuYWJsZUxvZ3MoKSxcbiAgICAgICAgICAoRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBmcmFtZSk7XG4gICAgICB9XG4gICAgICBzYW1wbGVMaW5lcyA9IChzYW1wbGVMaW5lcyA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6IFwiXCIpXG4gICAgICAgID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoc2FtcGxlTGluZXMpXG4gICAgICAgIDogXCJcIjtcbiAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIGZuICYmIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzYW1wbGVMaW5lcyk7XG4gICAgICByZXR1cm4gc2FtcGxlTGluZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlKSB7XG4gICAgICBpZiAobnVsbCA9PSB0eXBlKSByZXR1cm4gXCJcIjtcbiAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlKSB7XG4gICAgICAgIHZhciBwcm90b3R5cGUgPSB0eXBlLnByb3RvdHlwZTtcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoXG4gICAgICAgICAgdHlwZSxcbiAgICAgICAgICAhKCFwcm90b3R5cGUgfHwgIXByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiB0eXBlKSByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShcIlN1c3BlbnNlXCIpO1xuICAgICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoXCJTdXNwZW5zZUxpc3RcIik7XG4gICAgICB9XG4gICAgICBpZiAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUpXG4gICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgIHJldHVybiAodHlwZSA9IGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIsICExKSksIHR5cGU7XG4gICAgICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSk7XG4gICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICBwcm90b3R5cGUgPSB0eXBlLl9wYXlsb2FkO1xuICAgICAgICAgICAgdHlwZSA9IHR5cGUuX2luaXQ7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUocHJvdG90eXBlKSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0T3duZXIoKSB7XG4gICAgICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkE7XG4gICAgICByZXR1cm4gbnVsbCA9PT0gZGlzcGF0Y2hlciA/IG51bGwgOiBkaXNwYXRjaGVyLmdldE93bmVyKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCBcImtleVwiKSkge1xuICAgICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsIFwia2V5XCIpLmdldDtcbiAgICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHJldHVybiAhMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbmZpZy5rZXk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICAgICAgZnVuY3Rpb24gd2FybkFib3V0QWNjZXNzaW5nS2V5KCkge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biB8fFxuICAgICAgICAgICgoc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSAhMCksXG4gICAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICAgIFwiJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSB2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50IHByb3AuIChodHRwczovL3JlYWN0LmRldi9saW5rL3NwZWNpYWwtcHJvcHMpXCIsXG4gICAgICAgICAgICBkaXNwbGF5TmFtZVxuICAgICAgICAgICkpO1xuICAgICAgfVxuICAgICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gITA7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsIFwia2V5XCIsIHtcbiAgICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITBcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbGVtZW50UmVmR2V0dGVyV2l0aERlcHJlY2F0aW9uV2FybmluZygpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHRoaXMudHlwZSk7XG4gICAgICBkaWRXYXJuQWJvdXRFbGVtZW50UmVmW2NvbXBvbmVudE5hbWVdIHx8XG4gICAgICAgICgoZGlkV2FybkFib3V0RWxlbWVudFJlZltjb21wb25lbnROYW1lXSA9ICEwKSxcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIkFjY2Vzc2luZyBlbGVtZW50LnJlZiB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gcmVmIGlzIG5vdyBhIHJlZ3VsYXIgcHJvcC4gSXQgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIEpTWCBFbGVtZW50IHR5cGUgaW4gYSBmdXR1cmUgcmVsZWFzZS5cIlxuICAgICAgICApKTtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSB0aGlzLnByb3BzLnJlZjtcbiAgICAgIHJldHVybiB2b2lkIDAgIT09IGNvbXBvbmVudE5hbWUgPyBjb21wb25lbnROYW1lIDogbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gUmVhY3RFbGVtZW50KHR5cGUsIGtleSwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgICAgIHNlbGYgPSBwcm9wcy5yZWY7XG4gICAgICB0eXBlID0ge1xuICAgICAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgcHJvcHM6IHByb3BzLFxuICAgICAgICBfb3duZXI6IG93bmVyXG4gICAgICB9O1xuICAgICAgbnVsbCAhPT0gKHZvaWQgMCAhPT0gc2VsZiA/IHNlbGYgOiBudWxsKVxuICAgICAgICA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiAhMSxcbiAgICAgICAgICAgIGdldDogZWxlbWVudFJlZkdldHRlcldpdGhEZXByZWNhdGlvbldhcm5pbmdcbiAgICAgICAgICB9KVxuICAgICAgICA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0eXBlLCBcInJlZlwiLCB7IGVudW1lcmFibGU6ICExLCB2YWx1ZTogbnVsbCB9KTtcbiAgICAgIHR5cGUuX3N0b3JlID0ge307XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodHlwZS5fc3RvcmUsIFwidmFsaWRhdGVkXCIsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiAhMSxcbiAgICAgICAgZW51bWVyYWJsZTogITEsXG4gICAgICAgIHdyaXRhYmxlOiAhMCxcbiAgICAgICAgdmFsdWU6IDBcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHR5cGUsIFwiX2RlYnVnSW5mb1wiLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogITEsXG4gICAgICAgIGVudW1lcmFibGU6ICExLFxuICAgICAgICB3cml0YWJsZTogITAsXG4gICAgICAgIHZhbHVlOiBudWxsXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5mcmVlemUgJiYgKE9iamVjdC5mcmVlemUodHlwZS5wcm9wcyksIE9iamVjdC5mcmVlemUodHlwZSkpO1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGpzeERFVkltcGwoXG4gICAgICB0eXBlLFxuICAgICAgY29uZmlnLFxuICAgICAgbWF5YmVLZXksXG4gICAgICBpc1N0YXRpY0NoaWxkcmVuLFxuICAgICAgc291cmNlLFxuICAgICAgc2VsZlxuICAgICkge1xuICAgICAgaWYgKFxuICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgdHlwZSB8fFxuICAgICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiB0eXBlIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fFxuICAgICAgICB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHxcbiAgICAgICAgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8XG4gICAgICAgIHR5cGUgPT09IFJFQUNUX09GRlNDUkVFTl9UWVBFIHx8XG4gICAgICAgIChcIm9iamVjdFwiID09PSB0eXBlb2YgdHlwZSAmJlxuICAgICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8XG4gICAgICAgICAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NRU1PX1RZUEUgfHxcbiAgICAgICAgICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OU1VNRVJfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSB8fFxuICAgICAgICAgICAgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQxIHx8XG4gICAgICAgICAgICB2b2lkIDAgIT09IHR5cGUuZ2V0TW9kdWxlSWQpKVxuICAgICAgKSB7XG4gICAgICAgIHZhciBjaGlsZHJlbiA9IGNvbmZpZy5jaGlsZHJlbjtcbiAgICAgICAgaWYgKHZvaWQgMCAhPT0gY2hpbGRyZW4pXG4gICAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pXG4gICAgICAgICAgICBpZiAoaXNBcnJheUltcGwoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICAgIGZvciAoXG4gICAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA9IDA7XG4gICAgICAgICAgICAgICAgaXNTdGF0aWNDaGlsZHJlbiA8IGNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpc1N0YXRpY0NoaWxkcmVuKytcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuW2lzU3RhdGljQ2hpbGRyZW5dLCB0eXBlKTtcbiAgICAgICAgICAgICAgT2JqZWN0LmZyZWV6ZSAmJiBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgICAgIFwiUmVhY3QuanN4OiBTdGF0aWMgY2hpbGRyZW4gc2hvdWxkIGFsd2F5cyBiZSBhbiBhcnJheS4gWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiBVc2UgdGhlIEJhYmVsIHRyYW5zZm9ybSBpbnN0ZWFkLlwiXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgZWxzZSB2YWxpZGF0ZUNoaWxkS2V5cyhjaGlsZHJlbiwgdHlwZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGlsZHJlbiA9IFwiXCI7XG4gICAgICAgIGlmIChcbiAgICAgICAgICB2b2lkIDAgPT09IHR5cGUgfHxcbiAgICAgICAgICAoXCJvYmplY3RcIiA9PT0gdHlwZW9mIHR5cGUgJiZcbiAgICAgICAgICAgIG51bGwgIT09IHR5cGUgJiZcbiAgICAgICAgICAgIDAgPT09IE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aClcbiAgICAgICAgKVxuICAgICAgICAgIGNoaWxkcmVuICs9XG4gICAgICAgICAgICBcIiBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSBpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICAgIG51bGwgPT09IHR5cGVcbiAgICAgICAgICA/IChpc1N0YXRpY0NoaWxkcmVuID0gXCJudWxsXCIpXG4gICAgICAgICAgOiBpc0FycmF5SW1wbCh0eXBlKVxuICAgICAgICAgICAgPyAoaXNTdGF0aWNDaGlsZHJlbiA9IFwiYXJyYXlcIilcbiAgICAgICAgICAgIDogdm9pZCAwICE9PSB0eXBlICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgICAgICAgICA/ICgoaXNTdGF0aWNDaGlsZHJlbiA9XG4gICAgICAgICAgICAgICAgICBcIjxcIiArXG4gICAgICAgICAgICAgICAgICAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgXCJVbmtub3duXCIpICtcbiAgICAgICAgICAgICAgICAgIFwiIC8+XCIpLFxuICAgICAgICAgICAgICAgIChjaGlsZHJlbiA9XG4gICAgICAgICAgICAgICAgICBcIiBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50P1wiKSlcbiAgICAgICAgICAgICAgOiAoaXNTdGF0aWNDaGlsZHJlbiA9IHR5cGVvZiB0eXBlKTtcbiAgICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgICBcIlJlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lc1wiLFxuICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgY2hpbGRyZW5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgXCJrZXlcIikpIHtcbiAgICAgICAgY2hpbGRyZW4gPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY29uZmlnKS5maWx0ZXIoZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICByZXR1cm4gXCJrZXlcIiAhPT0gaztcbiAgICAgICAgfSk7XG4gICAgICAgIGlzU3RhdGljQ2hpbGRyZW4gPVxuICAgICAgICAgIDAgPCBrZXlzLmxlbmd0aFxuICAgICAgICAgICAgPyBcIntrZXk6IHNvbWVLZXksIFwiICsga2V5cy5qb2luKFwiOiAuLi4sIFwiKSArIFwiOiAuLi59XCJcbiAgICAgICAgICAgIDogXCJ7a2V5OiBzb21lS2V5fVwiO1xuICAgICAgICBkaWRXYXJuQWJvdXRLZXlTcHJlYWRbY2hpbGRyZW4gKyBpc1N0YXRpY0NoaWxkcmVuXSB8fFxuICAgICAgICAgICgoa2V5cyA9XG4gICAgICAgICAgICAwIDwga2V5cy5sZW5ndGggPyBcIntcIiArIGtleXMuam9pbihcIjogLi4uLCBcIikgKyBcIjogLi4ufVwiIDogXCJ7fVwiKSxcbiAgICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICAgJ0EgcHJvcHMgb2JqZWN0IGNvbnRhaW5pbmcgYSBcImtleVwiIHByb3AgaXMgYmVpbmcgc3ByZWFkIGludG8gSlNYOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMgey4uLnByb3BzfSAvPlxcblJlYWN0IGtleXMgbXVzdCBiZSBwYXNzZWQgZGlyZWN0bHkgdG8gSlNYIHdpdGhvdXQgdXNpbmcgc3ByZWFkOlxcbiAgbGV0IHByb3BzID0gJXM7XFxuICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JyxcbiAgICAgICAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgICAgIGtleXMsXG4gICAgICAgICAgICBjaGlsZHJlblxuICAgICAgICAgICksXG4gICAgICAgICAgKGRpZFdhcm5BYm91dEtleVNwcmVhZFtjaGlsZHJlbiArIGlzU3RhdGljQ2hpbGRyZW5dID0gITApKTtcbiAgICAgIH1cbiAgICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgICAgIHZvaWQgMCAhPT0gbWF5YmVLZXkgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24obWF5YmVLZXkpLCAoY2hpbGRyZW4gPSBcIlwiICsgbWF5YmVLZXkpKTtcbiAgICAgIGhhc1ZhbGlkS2V5KGNvbmZpZykgJiZcbiAgICAgICAgKGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oY29uZmlnLmtleSksIChjaGlsZHJlbiA9IFwiXCIgKyBjb25maWcua2V5KSk7XG4gICAgICBpZiAoXCJrZXlcIiBpbiBjb25maWcpIHtcbiAgICAgICAgbWF5YmVLZXkgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gY29uZmlnKVxuICAgICAgICAgIFwia2V5XCIgIT09IHByb3BOYW1lICYmIChtYXliZUtleVtwcm9wTmFtZV0gPSBjb25maWdbcHJvcE5hbWVdKTtcbiAgICAgIH0gZWxzZSBtYXliZUtleSA9IGNvbmZpZztcbiAgICAgIGNoaWxkcmVuICYmXG4gICAgICAgIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKFxuICAgICAgICAgIG1heWJlS2V5LFxuICAgICAgICAgIFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIHR5cGVcbiAgICAgICAgICAgID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgXCJVbmtub3duXCJcbiAgICAgICAgICAgIDogdHlwZVxuICAgICAgICApO1xuICAgICAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBjaGlsZHJlbiwgc2VsZiwgc291cmNlLCBnZXRPd25lcigpLCBtYXliZUtleSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgICAgIGlmIChcbiAgICAgICAgXCJvYmplY3RcIiA9PT0gdHlwZW9mIG5vZGUgJiZcbiAgICAgICAgbm9kZSAmJlxuICAgICAgICBub2RlLiQkdHlwZW9mICE9PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFXG4gICAgICApXG4gICAgICAgIGlmIChpc0FycmF5SW1wbChub2RlKSlcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IG5vZGVbaV07XG4gICAgICAgICAgICBpc1ZhbGlkRWxlbWVudChjaGlsZCkgJiYgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1ZhbGlkRWxlbWVudChub2RlKSlcbiAgICAgICAgICBub2RlLl9zdG9yZSAmJiAobm9kZS5fc3RvcmUudmFsaWRhdGVkID0gMSk7XG4gICAgICAgIGVsc2UgaWYgKFxuICAgICAgICAgIChudWxsID09PSBub2RlIHx8IFwib2JqZWN0XCIgIT09IHR5cGVvZiBub2RlXG4gICAgICAgICAgICA/IChpID0gbnVsbClcbiAgICAgICAgICAgIDogKChpID1cbiAgICAgICAgICAgICAgICAoTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG5vZGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSkgfHxcbiAgICAgICAgICAgICAgICBub2RlW1wiQEBpdGVyYXRvclwiXSksXG4gICAgICAgICAgICAgIChpID0gXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaSA/IGkgOiBudWxsKSksXG4gICAgICAgICAgXCJmdW5jdGlvblwiID09PSB0eXBlb2YgaSAmJlxuICAgICAgICAgICAgaSAhPT0gbm9kZS5lbnRyaWVzICYmXG4gICAgICAgICAgICAoKGkgPSBpLmNhbGwobm9kZSkpLCBpICE9PSBub2RlKSlcbiAgICAgICAgKVxuICAgICAgICAgIGZvciAoOyAhKG5vZGUgPSBpLm5leHQoKSkuZG9uZTsgKVxuICAgICAgICAgICAgaXNWYWxpZEVsZW1lbnQobm9kZS52YWx1ZSkgJiZcbiAgICAgICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShub2RlLnZhbHVlLCBwYXJlbnRUeXBlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBcIm9iamVjdFwiID09PSB0eXBlb2Ygb2JqZWN0ICYmXG4gICAgICAgIG51bGwgIT09IG9iamVjdCAmJlxuICAgICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRVxuICAgICAgKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gICAgICBpZiAoXG4gICAgICAgIGVsZW1lbnQuX3N0b3JlICYmXG4gICAgICAgICFlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgJiZcbiAgICAgICAgbnVsbCA9PSBlbGVtZW50LmtleSAmJlxuICAgICAgICAoKGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IDEpLFxuICAgICAgICAocGFyZW50VHlwZSA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkpLFxuICAgICAgICAhb3duZXJIYXNLZXlVc2VXYXJuaW5nW3BhcmVudFR5cGVdKVxuICAgICAgKSB7XG4gICAgICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1twYXJlbnRUeXBlXSA9ICEwO1xuICAgICAgICB2YXIgY2hpbGRPd25lciA9IFwiXCI7XG4gICAgICAgIGVsZW1lbnQgJiZcbiAgICAgICAgICBudWxsICE9IGVsZW1lbnQuX293bmVyICYmXG4gICAgICAgICAgZWxlbWVudC5fb3duZXIgIT09IGdldE93bmVyKCkgJiZcbiAgICAgICAgICAoKGNoaWxkT3duZXIgPSBudWxsKSxcbiAgICAgICAgICBcIm51bWJlclwiID09PSB0eXBlb2YgZWxlbWVudC5fb3duZXIudGFnXG4gICAgICAgICAgICA/IChjaGlsZE93bmVyID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGVsZW1lbnQuX293bmVyLnR5cGUpKVxuICAgICAgICAgICAgOiBcInN0cmluZ1wiID09PSB0eXBlb2YgZWxlbWVudC5fb3duZXIubmFtZSAmJlxuICAgICAgICAgICAgICAoY2hpbGRPd25lciA9IGVsZW1lbnQuX293bmVyLm5hbWUpLFxuICAgICAgICAgIChjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBjaGlsZE93bmVyICsgXCIuXCIpKTtcbiAgICAgICAgdmFyIHByZXZHZXRDdXJyZW50U3RhY2sgPSBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2s7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlKTtcbiAgICAgICAgICBwcmV2R2V0Q3VycmVudFN0YWNrICYmIChzdGFjayArPSBwcmV2R2V0Q3VycmVudFN0YWNrKCkgfHwgXCJcIik7XG4gICAgICAgICAgcmV0dXJuIHN0YWNrO1xuICAgICAgICB9O1xuICAgICAgICBjb25zb2xlLmVycm9yKFxuICAgICAgICAgICdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay93YXJuaW5nLWtleXMgZm9yIG1vcmUgaW5mb3JtYXRpb24uJyxcbiAgICAgICAgICBwYXJlbnRUeXBlLFxuICAgICAgICAgIGNoaWxkT3duZXJcbiAgICAgICAgKTtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID0gcHJldkdldEN1cnJlbnRTdGFjaztcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9IFwiXCIsXG4gICAgICAgIG93bmVyID0gZ2V0T3duZXIoKTtcbiAgICAgIG93bmVyICYmXG4gICAgICAgIChvd25lciA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShvd25lci50eXBlKSkgJiZcbiAgICAgICAgKGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGBcIiArIG93bmVyICsgXCJgLlwiKTtcbiAgICAgIGluZm8gfHxcbiAgICAgICAgKChwYXJlbnRUeXBlID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHBhcmVudFR5cGUpKSAmJlxuICAgICAgICAgIChpbmZvID1cbiAgICAgICAgICAgIFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnRUeXBlICsgXCI+LlwiKSk7XG4gICAgICByZXR1cm4gaW5mbztcbiAgICB9XG4gICAgdmFyIFJlYWN0ID0gcmVxdWlyZShcIm5leHQvZGlzdC9jb21waWxlZC9yZWFjdFwiKSxcbiAgICAgIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC50cmFuc2l0aW9uYWwuZWxlbWVudFwiKSxcbiAgICAgIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnBvcnRhbFwiKSxcbiAgICAgIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZnJhZ21lbnRcIiksXG4gICAgICBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN0cmljdF9tb2RlXCIpLFxuICAgICAgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5wcm9maWxlclwiKTtcbiAgICBTeW1ib2wuZm9yKFwicmVhY3QucHJvdmlkZXJcIik7XG4gICAgdmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29uc3VtZXJcIiksXG4gICAgICBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuY29udGV4dFwiKSxcbiAgICAgIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QuZm9yd2FyZF9yZWZcIiksXG4gICAgICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlXCIpLFxuICAgICAgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcihcInJlYWN0LnN1c3BlbnNlX2xpc3RcIiksXG4gICAgICBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3QubWVtb1wiKSxcbiAgICAgIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5sYXp5XCIpLFxuICAgICAgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKFwicmVhY3Qub2Zmc2NyZWVuXCIpLFxuICAgICAgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yLFxuICAgICAgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSQyID0gU3ltYm9sLmZvcihcInJlYWN0LmNsaWVudC5yZWZlcmVuY2VcIiksXG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscyA9XG4gICAgICAgIFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERSxcbiAgICAgIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgIGFzc2lnbiA9IE9iamVjdC5hc3NpZ24sXG4gICAgICBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKFwicmVhY3QuY2xpZW50LnJlZmVyZW5jZVwiKSxcbiAgICAgIGlzQXJyYXlJbXBsID0gQXJyYXkuaXNBcnJheSxcbiAgICAgIGRpc2FibGVkRGVwdGggPSAwLFxuICAgICAgcHJldkxvZyxcbiAgICAgIHByZXZJbmZvLFxuICAgICAgcHJldldhcm4sXG4gICAgICBwcmV2RXJyb3IsXG4gICAgICBwcmV2R3JvdXAsXG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQsXG4gICAgICBwcmV2R3JvdXBFbmQ7XG4gICAgZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gITA7XG4gICAgdmFyIHByZWZpeCxcbiAgICAgIHN1ZmZpeCxcbiAgICAgIHJlZW50cnkgPSAhMTtcbiAgICB2YXIgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyAoXG4gICAgICBcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBXZWFrTWFwID8gV2Vha01hcCA6IE1hcFxuICAgICkoKTtcbiAgICB2YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoXCJyZWFjdC5jbGllbnQucmVmZXJlbmNlXCIpLFxuICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG4gICAgdmFyIGRpZFdhcm5BYm91dEVsZW1lbnRSZWYgPSB7fTtcbiAgICB2YXIgZGlkV2FybkFib3V0S2V5U3ByZWFkID0ge30sXG4gICAgICBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcbiAgICBleHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbiAgICBleHBvcnRzLmpzeERFViA9IGZ1bmN0aW9uIChcbiAgICAgIHR5cGUsXG4gICAgICBjb25maWcsXG4gICAgICBtYXliZUtleSxcbiAgICAgIGlzU3RhdGljQ2hpbGRyZW4sXG4gICAgICBzb3VyY2UsXG4gICAgICBzZWxmXG4gICAgKSB7XG4gICAgICByZXR1cm4ganN4REVWSW1wbCh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpO1xuICAgIH07XG4gIH0pKCk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSw4TEFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tdmVudHVyYS9Eb2N1bWVudHMvR2l0SHViL21vcnBoZS9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ })

},
/******/ __webpack_require__ => { // webpackRuntimeModules
/******/ var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
/******/ __webpack_require__.O(0, ["main-app"], () => (__webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%7B%22request%22%3A%22%2FUsers%2Fmventura%2FDocuments%2FGitHub%2Fmorphe%2Fapp%2Flayout.jsx%22%2C%22ids%22%3A%5B%5D%7D&server=false!")));
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);